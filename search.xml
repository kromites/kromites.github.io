<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客介绍</title>
    <url>/posts/e627a59/</url>
    <content><![CDATA[<blockquote>
<p>欢迎您访问此博客！ 点开阅读全文可了解到博客的基本信息</p>
</blockquote>
<span id="more"></span>

<p>本博客创建于2021.7.1。作为一名22届毕业的学生，目前的主要精力放在找工作上，因此最近上传的大部分是自己的学习笔记。笔记内容涉及到以下几个主要方面：</p>
<ul>
<li>数据结构与算法</li>
<li>计算机网络</li>
<li>操作系统</li>
<li>网络编程</li>
<li>数据库</li>
<li>项目心得</li>
</ul>
<p>希望自己能够在这个夏天拿到心满意足的Offer！</p>
<p>TO BE CONTINUE~</p>
]]></content>
      <categories>
        <category>非技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp语法</title>
    <url>/posts/14ad0c05/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章用问答的方式记录一些C++(11及11以前）常见的语法，常见语法包括基本关键字，面向对象特性等。</p>
</blockquote>
<span id="more"></span>



<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h4><p>static关键字既可以修饰函数也可以修饰变量，用来定义静态函数和静态变量。其作用是根据其作用域来决定的。</p>
<ul>
<li><p>当static关键字的作用域为整个文件时(即全局静态变量/函数)</p>
<ul>
<li>该全局变量和函数只能被本文件所”看见“——<strong>全局静态变量只能在本文件中访问，全局静态变量函数只能在本文件中调用。在其他文件中是不可见的。</strong></li>
<li>该全局变量的生命周期是整个程序。</li>
</ul>
</li>
<li><p>当static关键字的作用域为一个类时（即类内静态成员变量/函数）</p>
<ul>
<li><p><strong>静态成员变量在类内进行声明，在类外进行定义和初始化，类外定义和初始化的时候不能带有static关键字</strong>。</p>
</li>
<li><p>静态成员变量是类作用域的全局变量，被所有类的对象共享，包括派生类的对象。因此计算对象大小要把static变量剔除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof A = 4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//	int b;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sizeof B = 1</span></span><br></pre></td></tr></table></figure></li>
<li><p>静态成员在类第一次创建对象的时候就已经创建了，生命周期为类的生命周期。</p>
</li>
<li><p>静态成员变量可以作为成员函数的参数，因为在调用该函数的时候，静态成员变量已经被定义了</p>
</li>
<li><p><strong>静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> A s_var; <span class="comment">// 正确，静态数据成员</span></span><br><span class="line">    A var;          <span class="comment">// error: field &#x27;var&#x27; has incomplete type &#x27;A&#x27;</span></span><br><span class="line">    A *p;           <span class="comment">// 正确，指针</span></span><br><span class="line">    A &amp;var1;        <span class="comment">// 正确，引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>静态成员函数是类作用域的全局函数，<strong>没有this指针</strong>，因此不能调用非静态成员变量和非静态成员函数</p>
</li>
<li><p>静态成员函数不能被声明为虚函数，const函数和volatile函数，因为没有this指针，修饰它没有任何意义。</p>
</li>
</ul>
</li>
<li><p>当static的作用域为一个函数时，称为局部变量</p>
<ul>
<li>局部变量的生命周期为该函数，在函数定义时开始，从函数结束时结束</li>
</ul>
</li>
<li><p>static修饰的变量都被放在<code>.data</code>和<code>.bss</code>段</p>
</li>
</ul>
<h4 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h4><p><strong>作用</strong>：</p>
<ul>
<li><p>const 修饰<strong>成员变量</strong>，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。</p>
</li>
<li><p>const 修饰<strong>函数参数</strong>，使得传递过来的函数参数的值不能改变。</p>
</li>
<li><p>const 修饰<strong>成员函数</strong>，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用</p>
<p>非 const <strong>成员函数</strong>，因为非 const 成员函数可能会修改成员变量。</p>
</li>
</ul>
<p><strong>在类中的用法</strong>：</p>
<ul>
<li><p>const 成员变量：</p>
<ul>
<li>c<strong>onst 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化</strong>。</li>
<li>const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此<strong>不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。</strong></li>
</ul>
</li>
<li><p>const 成员函数：</p>
<ul>
<li>不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。</li>
<li>不能调用非常量成员函数，以防修改成员变量的值。</li>
</ul>
</li>
</ul>
<p><strong>底层const和顶层const:</strong></p>
<ul>
<li>顶层const:  对象本身是const； （常量的定义就是一个top-level const的对象类型）</li>
<li>底层const：指针（对象本身）所指的对象是const（一般来说本身是个指针）</li>
</ul>
<p><strong>它和constexpr的区别:</strong></p>
<ul>
<li>const关键字只是在编译期编译器将其标记为一个常量，但是其具体的值并不清楚。</li>
<li>constexpr关键字在编译期不仅知道其为一个常量，还知道具体的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 在编译期，a被标记为整型常量，b被标记为整型数字4</span></span><br></pre></td></tr></table></figure>

<p><strong>它和define的区别：</strong></p>
<ul>
<li><p><strong>编译阶段</strong>：define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值。</p>
</li>
<li><p><strong>安全性</strong>：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</p>
</li>
<li><p><strong>内存占用</strong>：define 定义的宏常量，<strong>在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的局部常量在栈上，全局常量在<code>.data</code>段，程序运行过程中只有一份。</strong></p>
</li>
<li><p><strong>调试</strong>：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const 定义的常量可以进行调试。</p>
</li>
</ul>
<h4 id="inline关键字"><a href="#inline关键字" class="headerlink" title="inline关键字"></a>inline关键字</h4><p>inline关键字用来修饰内联函数。</p>
<p><strong>内联函数的作用</strong>：</p>
<ul>
<li><p><strong>消除函数调用的开销。</strong><br>在内联函数出现之前，程序员通常用 #define 定义一些“函数”来消除调用这些函数的开销。内联函数设计的目的之一，就是取代 #define 的这项功能。</p>
</li>
<li><p><strong>去除函数只能定义一次的限制</strong>。<br><strong>内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。</strong></p>
</li>
</ul>
<p><strong>关于减少函数调用的开销：</strong></p>
<ul>
<li>内联函数一定会被编译器在调用点展开吗？<ul>
<li>错<strong>，inline 只是对编译器的建议，而非命令</strong>。编译器可以选择忽视 inline。当程序员定义的 inline 函数包含复杂递归，或者 inlinie 函数本身比较长，编译器一般不会将其展开，而仍然会选择函数调用。</li>
</ul>
</li>
<li>“调用”普通函数时，一定是调用吗？<ul>
<li>错，<strong>即使是普通函数，编译器也可以选择进行优化，将普通函数在“调用”点展开</strong>。</li>
</ul>
</li>
<li>既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？<ul>
<li>错。首先，如第一点所言，编译器可以选择调用内联函数，而非展开内联函数。因此，内存中仍然需要一份内联函数的定义，以供调用。<br>而且，一致性是所有语言都应该遵守的准则。普通函数可以有指向它的函数指针，那么，内联函数也可以有指向它的函数指针，因此，内存中需要一份内联函数的定义，使得这样的函数指针可以存在。</li>
</ul>
</li>
</ul>
<p><strong>关于去除函数只能定义一次的限制：</strong></p>
<ul>
<li><p>该程序会报错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;function 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;function 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">myPrint</span>();  <span class="comment">// error，会出现链接时错误， myPrint 函数被定义了两次。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用内联函数不会报错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;inline function 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;inline function 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">myPrint</span>()	<span class="comment">// 正常运行;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>因此，<strong>内联函数可以在头文件中定义</strong>（即多个 .cpp 源文件可以定义函数名、参数都一样的内联函数，而不会有重定义错误）</p>
</li>
</ul>
<p><strong>内联函数缺点</strong>：</p>
<ul>
<li>导致代码膨胀</li>
</ul>
<h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p><strong>volatile关键字的作用：</strong></p>
<ul>
<li>该关键字的作用很简单，仅仅是<strong>让编译器不会对相应的对象进行优化，即不会将变量从内存中写入寄存器中。</strong></li>
</ul>
<p><strong>延伸：</strong></p>
<ul>
<li>虽然作用很简单，但是这个作用让变量值一直在内存中，这样多线程对该变量进行操作的时候，就只能对该变量本身操作，而不会出现既操作内存又操作寄存器的场景，这样很可能会在操作变量时出错。</li>
<li><strong>volatile和原子性无关</strong></li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>当多线程都用到某一变量，而且该变量可能会改变时，那就用volatile关键字修饰它，防止操作出错。</li>
<li>中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 <code>volatile</code> 关键字修饰。</li>
</ul>
<h4 id="new-free关键字"><a href="#new-free关键字" class="headerlink" title="new/free关键字"></a>new/free关键字</h4><p>new/free关键字是C++用来动态分配/释放内存空间的函数组。</p>
<p><strong>new/free函数</strong></p>
<p>new函数分为两个步骤</p>
<ul>
<li><strong>首先分配一块内存 （operator new 这个步骤和malloc是一样的（都是在堆上调用mmap系统调用，都是面向内存的）</strong></li>
<li><strong>然后针对对象类型进行构造 （placement new 这个步骤保证了new的类型安全</strong>）</li>
</ul>
<p>free则是反向操作。</p>
<p>和malloc/delete之间还有个差别是new/free自动计算分配空间大小，而malloc需要自己指定。</p>
<h4 id="std-move-和-std-forward是什么？std-forward为何可以称为完美转发"><a href="#std-move-和-std-forward是什么？std-forward为何可以称为完美转发" class="headerlink" title="std::move 和 std:forward是什么？std::forward为何可以称为完美转发"></a>std::move 和 std:forward是什么？std::forward为何可以称为完美转发</h4><p>std::move的作用很简单，只是将变量本身类型转换成<strong>右值引用类型（&amp;&amp;）</strong></p>
<p><strong>引用</strong></p>
<p>引用分为左值引用(&amp;)和右值引用（&amp;&amp;）。</p>
<ul>
<li><p>左值引用我们都很熟悉，在汇编层面相当于普通的指针，不过定义引用变量必须初始化，和一个对象或变量进行绑定。那如果是一个常数呢，左值引用就不行了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;var = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>因为数字10无法进行取地址操作，毕竟10存在寄存器中，而非在内存中，没有地址。</p>
<p>当然我们可以，const能够生成临时变量保存const，不过这样就不可能修改数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; var = <span class="number">10</span>;	</span><br></pre></td></tr></table></figure>

<p>于是c++引入了右值引用的概念</p>
</li>
<li><p>右值引用</p>
<ul>
<li>可以取地址的，有名字的，<strong>非临时</strong>的就是左值引用；</li>
<li>不能取地址的，没有名字的，<strong>临时</strong>，<strong>即将消散</strong>的就是右值引用；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; var = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>右值引用如果修饰对象的话，那么该对象之后会消失（析构）</p>
</li>
<li><p>类中使用</p>
<p>在类中在左值引用基础上引申出<strong>拷贝语义</strong>——拷贝构造函数和拷贝运算符，右值引用基础上引申出<strong>移动语义</strong>——移动构造函数和移动运算符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span>	<span class="comment">// 省略掉类内信息，具体语法在面向对象中详细说明  </span></span><br><span class="line">A a;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;		<span class="comment">// 如果是有拷贝语义，那么b复制了份a，现在内存中有两个A对象实例； </span></span><br><span class="line">  			<span class="comment">// 如果是有移动语义，那么就是将a移动到了b对象所有权下面，此时内存中只有一个A对象实例b</span></span><br></pre></td></tr></table></figure>

<p>拷贝语义：当使用拷贝构造函数创建对象的时候，相当于是复制了个对象。</p>
<p>移动语义：在内存层次将对象移动到新对象实例之中。</p>
<p><strong>拷贝操作是很昂贵的，因为要新建一个完全相同的对象，而移动操作只是控制对象从a移动到b，因此如果不需要保留a的情况下，尽量使用移动操作</strong></p>
</li>
</ul>
<p><strong>std::move</strong></p>
<p>​    说清楚了引用，剩下的都很好办，std::move只有一个作用，<strong>执行强制型别转换：无条件地将实参转换成右值。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面代码是move的实现，就是进行static_cast转换成右值。不过当值转换成右值了，那么就可以进行移动操作了。</p>
<p><strong>std::forward</strong></p>
<p>​    T&amp;&amp;其实有两种含义，一种就是右值引用，另外一种就是既可以是右值引用，也可以是左值引用，称之为万能引用。但是后者一般要涉及到型别推导，当然涉及到形参推演只是一个必要条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;		<span class="comment">// 万能引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;		<span class="comment">// 万能引用</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果没型别推导</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A&amp;&amp; param)</span></span>;		<span class="comment">// 右值引用</span></span><br></pre></td></tr></table></figure>

<p>​    万能引用有一个规则：如果采用右值初始化万能引用，那么就会得到右值引用，如果采用左值初始化，那么得到的是左值引用。</p>
<p>std::forward和std::move一样，也只是强制型别转换：<strong>和一个可供移动的对象进行绑定，只有右值初始化时才会将该对象强制类型成右值型别。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span>&#123;</span><br><span class="line">    name = std::forward&lt;T&gt;(<span class="keyword">new</span> Name);		<span class="comment">// 万能引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这样</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span>&#123;</span><br><span class="line">    name = std::<span class="built_in">move</span>(<span class="keyword">new</span> Name);				<span class="comment">// 也是万能引用，但编译起来糟糕透顶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们必须遵循：<strong>针对右值引用实施std::move,针对万能引用实施std::forward</strong>，别用错了！！</p>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。</p>
<p><strong>智能指针的作用</strong></p>
<ul>
<li>智能指针的作用是管理一个指针，防止造成堆上的内存泄漏。</li>
<li>智能指针是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。</li>
<li>所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</li>
</ul>
<p><strong>auto_ptr</strong>(C98)</p>
<p>采取所有权模式，存在潜在的内存崩溃问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt; <span class="built_in">string</span>&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;I reigned lonely as a cloud.”));</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">// 此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。                                 </span></span></span></span><br></pre></td></tr></table></figure>



<p><strong>unique_ptr</strong>(替换auto_ptr)</p>
<p>依旧采取所有权模式，实现独占式拥有或严格拥有的概念。<strong>保证同一时间内只有一个智能指针可以指向该对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt;;		<span class="comment">// 会生成一个指向A特定实例的指针。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">unique_ptr 和 单例模式的区别</span></span><br><span class="line"><span class="comment">	-&gt; 会生成一个指向A特定实例的指针，unique_ptr&lt;A&gt;不会阻止创建其他A实例对象,</span></span><br><span class="line"><span class="comment">		即不能有两个unique_ptr&lt;A&gt;指向同一个对象</span></span><br><span class="line"><span class="comment">	-&gt; 单例模式是只能有一个A的实例对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;auto&quot;</span>))</span></span>;     </span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4;   	<span class="comment">// 	没问题，如果是单例的话这个时候就出问题了       </span></span><br><span class="line"></span><br><span class="line">p4 = p3;					<span class="comment">//	指向同一个对象，那此时会报错！！</span></span><br></pre></td></tr></table></figure>

<p>当然如果创建一个unique_ptr对象的话，不要用new，而是直接用<code>std::make_unique</code></p>
<p><strong>shared_ptr</strong></p>
<p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用<strong>引用计数机制来表明资源被几个指针共享</strong>。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>当然如果创建一个share_ptr对象的话，不要用new，而是直接用<code>std::make_shared</code></p>
<p><strong>weak_ptr</strong></p>
<p>weak_ptr是一种不控制对象生命周期的智能指针，它指向一个 shared_ptr 管理的对象。</p>
<ul>
<li>进行该对象的内存管理的是那个强引用的 shared_ptr. <strong>weak_ptr只是提供了对管理对象的一个访问手段</strong>。</li>
<li>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</li>
<li><strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。</strong>它是对对象的一种弱引用，不会增加对象的引用计数，<strong>可以和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</strong></li>
<li>不过不能通过weak_ptr直接访问对象，它只是针对shared_ptr相互引用的死锁问题而发明的一个弱引用方法。</li>
</ul>
<h4 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h4><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast。</p>
<p><strong>const_cast</strong></p>
<ul>
<li>用于将<strong>const变量转为非const</strong>（去除const的转换）</li>
</ul>
<p><strong>static_cast</strong></p>
<ul>
<li>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</li>
<li>static_cast基本上代替了一般的隐式转换，这个是最普遍的转换方式</li>
</ul>
<p><strong>dynamic_cast</strong>（运行期转换）</p>
<ul>
<li><p><strong>用于动态类型转换</strong>。只能用于含有虚函数的类，用于类层次间的向上和向下转化。<strong>只能转指针或引用</strong>。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p>
</li>
<li><p>向上转换：指的是子类向基类的转换</p>
</li>
<li><p>向下转换：指的是基类向子类的转换</p>
</li>
<li><p>它通过<strong>判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</strong></p>
</li>
</ul>
<p><strong>reinterpret_cast</strong></p>
<p>几乎什么都可以转，比如将int转指针。这个是将变量所在的内存重新解释，因此可能会出问题，尽量少用。</p>
<p><strong>为什么不使用C的强制转换？</strong></p>
<p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
<p>最后，遇到类型转换一定要养成用显示类型转换的好习惯。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li> 《C++ Primer》</li>
<li> 《Effective Modern C++》</li>
</ol>
<hr>
<p><em>此文档会一直增加新的知识点，如有错误，请不吝指出</em></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
        <tag>C++关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O多路复用</title>
    <url>/posts/7ce262fd/</url>
    <content><![CDATA[<blockquote>
<p>在网络编程中熟知的一个方法。nignx和redis中都实现了该方法，属于网络编程中的基本概念</p>
</blockquote>
<span id="more"></span>



<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>​    I/O多路复用是指程序在单个线程内通过记录每个I/O流的状态，来同时管理多个I/O流。这样使得程序能够在单线程内同时监听多个文件描述符。</p>
<p>   不过值得注意的是，I/O复用虽然能同时监听多个文件描述符，但是其本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外措施，程序就只能按顺序依次处理其中的每个文件描述符。</p>
<p>​    虽然是能够在单个线程同时监听多个文件描述符，但是文件描述符就绪依旧是串行处理，明白这一点就不会将I/O多路复用和并发混淆，因为串行处理事件并不是并发。</p>
<p>​    I/O多路复用有三种熟知的具体实现，分别是Select，Poll 和 Epoll，下面来依次介绍它们。</p>
<h3 id="SELECT系统调用"><a href="#SELECT系统调用" class="headerlink" title="SELECT系统调用"></a>SELECT系统调用</h3><p>​    用途：在指定时间内，<strong>监听用户感兴趣的文件描述符上的可读，可写和异常事件</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">( <span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    由上面的API可以看出，nfds是感兴趣的fd总数，后面三个参数分别是三种fd的集合，最后一个时间参数是指定时间，如果超过时间直接返回。</p>
<pre><code> 而`fd_set`结构体仅仅包含一个整形数组，**该数组的每个元素的每一位标记一个fd。**fd_set能容纳的文件描述符最大数量优先，应该是2^16。
</code></pre>
<p>​    这是select最大的缺点：</p>
<ul>
<li><p><strong>每次去查看文件描述符的状态都要按位去轮询整个数组，O（N），效率不高</strong></p>
</li>
<li><p><strong>而且存储的文件描述符有上限，只能存储几万个</strong>（这个很少，fd的上限能够达到上百万个）</p>
</li>
<li><p>非线程安全</p>
</li>
</ul>
<h3 id="POLL系统调用"><a href="#POLL系统调用" class="headerlink" title="POLL系统调用"></a>POLL系统调用</h3><p>​    poll和select类似，也是在<strong>指定时间轮询一定数量的文件描述符</strong>，以测试其中是否有就绪者。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">  	<span class="keyword">int</span> fd;				<span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;		<span class="comment">// 注册的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents;		<span class="comment">// 活跃的事件，由内核填充</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    看到这个API其实和select也是有点差别的。</p>
<ul>
<li>存放文件描述符的数据结构从数组位变成了</li>
<li>事件类型区分更为细致，select只有三种时间类型，而poll将其细化了。如可读事件分为了POLLIN,POLLRDNORM, POLLDRBAND, POLLPRI四种。</li>
</ul>
<p>不过nfds和timoeout参数都和select相似，这里不赘述。</p>
<p>其缺点也和select类似，</p>
<ul>
<li>遍历所有fd，不活跃fd也会去检查它的状态，O(N)</li>
<li>线程不安全</li>
</ul>
<p>不过因为不是通过数组位存储，因此无上限太低的缺点。</p>
<h3 id="EPOLL系统调用"><a href="#EPOLL系统调用" class="headerlink" title="EPOLL系统调用"></a>EPOLL系统调用</h3><p>接下来就迎来主角了，epoll是Linux特有的I/O复用函数，其实现和前两者有较大差异。</p>
<p>优点</p>
<ul>
<li>epoll使用一组函数实现多路复用，前两者都只有单个函数</li>
<li>epoll将用户关心的文件描述符上的事件放在内核里的一个事件表中，无需O(N)，只需要O(1)地查看关心的事件</li>
<li>检查文件描述符是否就绪的方法更好，epoll采用回调的机制，而前两者采用的轮询机制，随着fd增加，回调效率不怎么降低，而轮询会大大降低。</li>
<li>线程安全</li>
</ul>
<p>略有瑕疵的缺点</p>
<ul>
<li>内核事件表需要额外一个文件描述符表示，浪费了一个文件描述符</li>
<li>只能在Linux上用</li>
</ul>
<h4 id="epoll事件表"><a href="#epoll事件表" class="headerlink" title="epoll事件表"></a>epoll事件表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该API创建一个内核事件表，返回与该事件表绑定的文件描述符。</strong>size无多大含义，只是通知内核告诉它事件表多大。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">  	<span class="keyword">uint32_t</span> events; 	<span class="comment">// epoll 事件</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;	<span class="comment">// 用户数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该API用来操作已创建的内核事件表。</strong></p>
<p>参数分析：</p>
<ul>
<li><p>epfd是负责内核事件表的文件描述符</p>
</li>
<li><p>fd是要操作的文件描述符，op是操作类型：</p>
<ul>
<li>EPOLL_CTL_ADD：往事件表注册fd上的事件</li>
<li>EPOLL_CTL_MOD：修改fd上的注册事件</li>
<li>EPOLL_CTL_DEL：删除fd上的注册事件</li>
</ul>
</li>
<li><p>event参数指定事件。事件类型存储在event-&gt;events中。epoll的事件类型和poll类似，只不过在前面加了个E，不过epoll有两种额外的事件——EPOLLET和EPOLLONESHOT。这个后面再讲。</p>
</li>
<li><p>返回值：成功回0，失败回-1并设置errno。</p>
</li>
</ul>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>​    epoll的主要接口是epoll_wait函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该API在一段超时时间内等待一组文件描述符上的事件。</strong></p>
<p>参数：</p>
<ul>
<li>maxevents 指定最多能够监听多少个事件，必须大于0</li>
</ul>
<p><strong>如果检测到事件</strong>，就将所有就绪的事件从内核事件表（由epfd指定）中复制到它的第二个参数events指向的数组中。<strong>这个数组只用于输出epoll_wait检测到的就绪事件，而不像前两者的数组参数那样即用于传入用户注册的事件，又用于输出检测的内核事件。这样极大提高了应用程序索引就绪文件描述符的效率。</strong>（目前还是LT模式的效率提升，因为是检测到事件就返回）</p>
<h4 id="ET和LT模式"><a href="#ET和LT模式" class="headerlink" title="ET和LT模式"></a>ET和LT模式</h4><p>​    epoll对fd的操作用两种模式:ET和LT。其中LT是默认工作模式，这个模式下就是效率提升版的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET时间事，epoll工作模式变成了ET，ET是epoll的高效模式。</p>
<p>​    采用LT模式时，如果检测到有事件发生时，epoll_wait将此事通知给应用程序，应用程序可以不处理它，但是下次调用epoll_wait依旧会通知应用程序来处理它。</p>
<p>​    而ET模式不同，ET模式当通知了应用程序，应用程序必须立即处理该事件，因为后续的epoll_wait调用不再向应用程序通知这一事件。这样一来极大降低了同一事件被重复触发的次数（但是可能通知了没处理直接被漏掉了吗？思考一下）</p>
<p>​    形象的说就是<strong>LT模式是传统的调用epoll_wait有活跃事件就触发（可读事件缓冲区不为空，可写事件缓冲区不满），而ET是增量触发，只有新事件到来才会通知应用程序。</strong></p>
<p>​    （ET必须是非阻塞的！）</p>
<h4 id="EPOLLSHOT事件"><a href="#EPOLLSHOT事件" class="headerlink" title="EPOLLSHOT事件"></a>EPOLLSHOT事件</h4><p>​    即使我们使用ET模式，<strong>一个socket上的某个事件还是可能被触发多次</strong>。这在并发程序中会引起一个问题。比如一个线程在读取完某个socket上的数据后开始处理这些数据，在处理数据过程中又有新数据可读，这样新的线程唤醒去读新数据，那么就出现了<strong>两个线程同时操作一个socket的局面</strong>。但是我们期望的是<strong>一个socket连接在任一时刻都只被一个线程处理。（因为这会导致线程同步问题）</strong></p>
<p>​    这里就可以采用EPOLLSHOT事件，对于注册该事件的fd，<strong>操作系统最多出发其上注册的一个可读、可写或者一长时间，且只触发一次。</strong>这样当一个线程处理这socket，其他线程不能处理该socket。</p>
<p>​    但是反过来思考一下，只触发一次，那下次怎么办？因此触发这一次之后要重置EPOLLSHOT事件，进而让其他工作线程之后有机会处理该socket</p>
<h3 id="三种系统调用的对比"><a href="#三种系统调用的对比" class="headerlink" title="三种系统调用的对比"></a>三种系统调用的对比</h3><p>​    这三组系统调用都通过某种结构体变量来告诉内核监听那些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">SELECT</th>
<th align="center">POLL</th>
<th align="center">EPOLL</th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用数据结构</td>
<td align="center">三个数组构成的位图</td>
<td align="center">统一数据结构<code>epollfd</code></td>
<td align="center">同一数据结构，内核注册表</td>
</tr>
<tr>
<td align="center">事件类型</td>
<td align="center">最基本的三种：可读、可写、异常</td>
<td align="center">带有优先级的事件类型，区分更细致</td>
<td align="center">和poll类似，多了ET和SHOT</td>
</tr>
<tr>
<td align="center">事件监听机制</td>
<td align="center">轮询</td>
<td align="center">轮询</td>
<td align="center">回调</td>
</tr>
<tr>
<td align="center">时间复杂度</td>
<td align="center">O(N)</td>
<td align="center">O(N)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">优点</td>
<td align="center">多平台可用，简单</td>
<td align="center">多平台可用，简单，上限比select高</td>
<td align="center">高效，LT模式下就是O(1)，ET模式下更是减少同一事件的多次触发，线程安全</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">低效，处理的fd有上限，非线程安全</td>
<td align="center">低效，非线程安全</td>
<td align="center">仅LINUX可用</td>
</tr>
</tbody></table>
<p><strong>PS：虽然epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</strong></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>I/O多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/posts/735e5788/</url>
    <content><![CDATA[<blockquote>
<p> 各类排序算法是一个很基础的算法概念，在面试当中，手撕排序算法也只算得上一道简单题。</p>
</blockquote>
<span id="more"></span>

<p>排序算法一般可分为 快速排序， 归并排序，插入排序，冒泡排序，选择排序和堆排序。（其中快排，归并和堆排序比较难，但是要掌握）</p>
<h3 id="C-中的std-sort"><a href="#C-中的std-sort" class="headerlink" title="C++中的std::sort"></a>C++中的<code>std::sort</code></h3><p>​    sort算法主体是一个快速排序，快速排序的时间复杂度为<code>O(NlogN)</code>，但是其对效率有了优化。</p>
<p>首先，快速排序在小区间的效率不如插入排序，因此在小空间的话，就用<strong>插入排序</strong>。 而且快速排序是基于递归的，因此如果数据过大，递归层数过大，这就要转入<strong>堆排序</strong> 。</p>
<p>然后，快速排序的效率取决于pivot的取法，如果pivot取得适中，那么效率最高。因此标准库里面用的是<strong>九取一，</strong>这可以尽可能使得pivot的取值更合理。</p>
<h3 id="经典排序模板"><a href="#经典排序模板" class="headerlink" title="经典排序模板"></a>经典排序模板</h3><h4 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.     快速排序"></a>1.     快速排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// key is the pivot element </span></span><br><span class="line">	<span class="keyword">auto</span> first = l, last = r - <span class="number">1</span>, key = nums[first];</span><br><span class="line">	<span class="keyword">while</span>(first &lt; last) &#123;</span><br><span class="line">		<span class="comment">// deal with the element from the last</span></span><br><span class="line">		<span class="keyword">while</span> (first &lt; last &amp;&amp; nums[last] &gt;= key) &#123;</span><br><span class="line">			--last;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// swap and pivot become to the nums[last]</span></span><br><span class="line">		nums[first] = nums[last];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// deal wiht the element from the first</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(first &lt; last &amp;&amp; nums[first] &lt;= key) &#123;</span><br><span class="line">			++first;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// swap </span></span><br><span class="line">		nums[last] = nums[first];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// put the pivot on the correct position, sun first is the division line</span></span><br><span class="line">	nums[first] = key;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// recursion</span></span><br><span class="line">	<span class="built_in">quicksort</span>(nums, l, first);</span><br><span class="line">	<span class="built_in">quicksort</span>(nums, first + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于partition的排序</span></span><br><span class="line"><span class="comment">// algorithms 4th 所实现的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> first = l, last = r+<span class="number">1</span>, key = nums[first];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[++first] &lt; key) &#123;</span><br><span class="line">			<span class="keyword">if</span> (first == r)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (nums[--last] &gt; key) &#123;</span><br><span class="line">			<span class="keyword">if</span> (last == l)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		std::<span class="built_in">swap</span>(nums[first], nums[last]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::<span class="built_in">swap</span>(nums[l], nums[last]);</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (r &lt;= l)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> last = <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">	<span class="built_in">quicksort</span>(nums, l, last - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quicksort</span>(nums, last + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.     归并排序"></a>2.     归并排序</h4><p>方法：采用一个临时空间，将划分成两部分空间在这个临时空间中排好序，然后再放入原空间数组中。</p>
<p>步骤： 先divide，然后recursion， 再deal with。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, vector&lt;<span class="keyword">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l + <span class="number">1</span> &gt;= r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// divide, recursion first</span></span><br><span class="line">	<span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">mergesort</span>(nums, l, m, temp);</span><br><span class="line">	<span class="built_in">mergesort</span>(nums, m, r, temp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// conquer</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> p = l, q = m, i = l;</span><br><span class="line">	<span class="keyword">while</span>(p &lt; m || q &lt; r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q]))</span><br><span class="line">			temp[i++] = nums[p++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			temp[i++] = nums[q++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">		nums[i] = temp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.     插入排序"></a>3.     插入排序</h4><p>这个没什么讲的，反正记得<strong>插入排序是基于<code>swap</code>的</strong>就行</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">void <span class="keyword">insertsort(vector&lt;int&gt; </span>&amp;nums, int n) &#123;</span><br><span class="line">	for(int i=<span class="number">0</span><span class="comment">; i&lt;n; ++i) &#123;</span></span><br><span class="line">		for(int <span class="keyword">j=i; </span><span class="keyword">j&gt;0&amp;&amp; </span>nums[<span class="keyword">j] </span>&lt; nums[<span class="keyword">j-1]; </span>--<span class="keyword">j) </span>&#123;</span><br><span class="line">			<span class="keyword">swap(nums[j], </span>nums[<span class="keyword">j </span>- <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4.    冒泡排序"></a>4.    冒泡排序</h4><p><strong>冒泡排序同样也是基于swap的</strong>，而且为了节省时间，swap途中会有一个bool变量，来判断后续循环是否已经有序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> swapped;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">		swapped = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i; j &lt; n-i+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[j] &lt; nums[j<span class="number">-1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(nums[j], nums[j - <span class="number">1</span>]);</span><br><span class="line">				swapped = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!swapped)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5.     选择排序"></a>5.     选择排序</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">void selection_sort(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">mid</span>;</span><br><span class="line">	for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">n</span> - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="built_in">mid</span> = i;</span><br><span class="line">		for (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">n</span>; ++j) &#123;</span><br><span class="line">			<span class="built_in">if</span> (nums[j] &lt; nums[<span class="built_in">mid</span>]) &#123;</span><br><span class="line">				<span class="built_in">mid</span> = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(nums[<span class="built_in">mid</span>], nums[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.     堆排序"></a>6.     堆排序</h4><p>基本思路：大根堆为例</p>
<p>​    1：建立大根堆—- 将n个元素组成的无序序列构建一个大根堆</p>
<p>​    2：交换堆元素—- 交换堆尾和堆首元素，使堆尾元素成为最大元素</p>
<p>​    3：重建大根堆—- 将前n-1个元素组成的无序序列调整为大根堆（递归）</p>
<p>重复执行2和3 直到整个序列都有序</p>
<p>C++内部实现： 优先队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapadjust</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> right = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> maxIdx = index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left &lt; len &amp;&amp; nums[left] &gt; nums[maxIdx]) maxIdx = left;</span><br><span class="line">	<span class="keyword">if</span> (right&lt; len &amp;&amp; nums[right] &gt; nums[maxIdx]) maxIdx = right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(maxIdx != index) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(nums[maxIdx], nums[index]);</span><br><span class="line">		<span class="built_in">heapadjust</span>(nums, len, maxIdx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// build a heap</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = size / <span class="number">2</span> <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">heapadjust</span>(nums, size, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// adjust the heap</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=size<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">		<span class="built_in">heapadjust</span>(nums, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>总结：手撕排序算法是面试中最基本的技能，不仅要能口头描述出这些排序的用法和效率，还得在面试官需要的时候能够自己写出实现的代码并进行测试。</strong></p>
<p><strong>在这些排序中，最重要的就是堆排序和快速排序。一定要手撕和会用</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>RedisSDS</title>
    <url>/posts/ddef0534/</url>
    <content><![CDATA[<blockquote>
<p>Redis自己构建了一种名为简单动态字符串（SDS）的抽象类型，并将其设置为Redis默认字符串。</p>
</blockquote>
<span id="more"></span>

<h3 id="1-SDS的定义"><a href="#1-SDS的定义" class="headerlink" title="1 SDS的定义"></a>1 SDS的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sds.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存的字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>tag： 由于SDS遵循C字符串以空字符结尾的惯例， 保存空字符的1字节空间不计算在SDS的Len属性里面，并且为空字符自动生成一个字节空间</em></p>
<h3 id="2-SDS和C字符串的区别"><a href="#2-SDS和C字符串的区别" class="headerlink" title="2 SDS和C字符串的区别"></a>2 SDS和C字符串的区别</h3><p>​    由于Redis对字符串在安全性，效率以及功能上都有需求， 因此SDS比传统字符串有着不少优化。</p>
<ul>
<li><p><strong>常数复杂度获取字符串长度</strong></p>
<p>C字符串获取长度靠<code>strlen</code>(O(n)), Redis是靠着<code>sds.len</code>直接获得。</p>
</li>
<li><p><strong>杜绝缓冲区的溢出</strong></p>
<p>C字符串容易造成缓冲区的溢出，而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求。如果不满足，那么就会执行空间扩展工作。</p>
</li>
<li><p><strong>减少修改字符串时带来的内存重分配次数</strong></p>
<ul>
<li><p>C字符串被增长或者缩短时，程序都要对该字符串进行一次内存重分配操作。</p>
</li>
<li><p>针对未使用空间<code>sds.free</code>， SDS解除了字符串长度和底层数组长度之间的关联。从而实现了<strong>空间预分配和惰性空间释放</strong>两种优化策略。</p>
<ul>
<li><p>空间预分配： 当API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序<strong>不仅会为SDS分配修改所必须要的空间，还会分配额外的未使用空间</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配机制</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> <span class="title">sds</span>;</span></span><br><span class="line"><span class="keyword">int</span> needlen;			<span class="comment">// sds字符串需要存储的字符串长度</span></span><br><span class="line"><span class="keyword">if</span>(sds.len &lt; <span class="number">1024</span>*<span class="number">1024</span>)	<span class="comment">// 1024*1024 = 1MB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 分配空间至len</span></span><br><span class="line">    sds.len = needlen;</span><br><span class="line">    sds.<span class="built_in">free</span> = sds.len <span class="comment">// 保持一样</span></span><br><span class="line">    <span class="comment">//so strlen(sds.buf) = len + free + 1;</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    sds.len = needlen;</span><br><span class="line">    sds.<span class="built_in">free</span> = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>惰性空间释放： 用于优化SDS的字符串缩短操作。 API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量纪录起来，并等待将来使用。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>二进制安全</strong></p>
<ul>
<li><p>C字符串中的字符必须符合某种编码(如ASCII),并且<strong>除了字符串的末尾之外，字符串里面不能含有空字符</strong>（这个是因为程序读C字符串遇到空字符就默认这是字符串结尾）。 由于这些限制，<strong>C字符串只能保存文本数据，而不能保存像图片、音频、视频压缩文件这些二进制数据。</strong></p>
</li>
<li><p>SDS中的buf数组，既可以保存一系列字符，也可以保存一系列二进制数据。（其实可以理解为该数组可以保存空字符串，因为长度是已知的，程序不需要通过空字符串的位置判断这个字符串是否结束）</p>
</li>
</ul>
</li>
<li><p><strong>兼容部分C字符串函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">strcat</span>(s_string, sds-&gt;buf);</span><br><span class="line"><span class="comment">// 可以使用str相关的api</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>总结</strong></p>
<ul>
<li>C字符串：<ul>
<li>获取字符串长度的时间复杂度是O(N)</li>
<li>API不安全，可能会造成缓冲区溢出</li>
<li>修改字符串长度N次<strong>必然</strong>需要执行N次内存重分配</li>
<li>只能保存文本数据</li>
<li>可以使用<strong>所有</strong><code>&lt;string.h&gt;</code>的库函数</li>
</ul>
</li>
<li>SDS：<ul>
<li>获取字符串长度的时间复杂度是O(1)</li>
<li>AP安全，不会造成缓冲区溢出</li>
<li>修改字符串长度N次<strong>最多</strong>需要执行N次内存重分配</li>
<li>能保存文本数据和二进制数据</li>
<li>可以使用<strong>一部分</strong><code>&lt;string.h&gt;</code>的库函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-SDS-API"><a href="#3-SDS-API" class="headerlink" title="3 SDS API"></a>3 SDS API</h3><p>​    |       函数        |                                  作用                                     |                          时间复杂度</p>
<ul>
<li><p><code>sdsnew</code>           创建一个包含给定C字符串的SDS                          <code>O(N), N = strlen(str)</code></p>
</li>
<li><p><code>sdsempty</code>       创建一个不包含任何内容的空SDS                        <code>O(1)</code></p>
</li>
<li><p><code>sdsfree</code>         释放给定的SDS                                                       <code>O(N), N = strlen(str)</code></p>
</li>
<li><p><code>sdslen</code>           返回SDS已使用空间字节数                                    <code>O(1), get from sds-&gt;len</code></p>
</li>
<li><p><code>sdsavail </code>       返回SDS未使用空间字节数                                    <code>O(1), get from sds-&gt;free</code></p>
</li>
<li><p><code>sdsdup</code>           创建一个给定SDS的副本(copy)                             <code>O(N), N = strlen(str)</code></p>
</li>
<li><p><code>sdsclear</code>       清空SDS保存的字符串内容                                    <code>O(1), 惰性空间释放策略！</code>  -&gt; <strong>mark</strong></p>
</li>
<li><p><code>sdscat</code>           将给定C字符串拼接到SDS字符串的末尾               <code>O(N)，N = strlen(str) </code></p>
</li>
<li><p><code>sdscatsds</code>     将给定SDS字符串拼接到另一个SDS字符串末尾   <code>O(N)，N = strlen(str)</code></p>
</li>
<li><p><code>sdscpy</code>           <strong>将给定C字符串复制到SDS里面，</strong></p>
<p>​                            <strong>覆盖SDS原有字符串</strong>                                              <code>O(N)，N = strlen(str)</code></p>
</li>
<li><p><code>sdsgrowzero</code>  用空字符将SDS扩展至给定长度                            <code>O(N),N为扩展新增的字节数</code></p>
</li>
<li><p><code>sdsrange</code>       保留SDS给定区间内的数据，</p>
<p>​                        不在区间内的数据会被覆盖或清除                          <code>O(N),N为保留数据的字节数</code></p>
</li>
<li><p><code>sdstrim</code>         接收一个SDS和一个C字符串作为参数，                <code>O(N*M),M为SDS的长度，N为给定C字符串的长度</code></p>
<p>​                        从SDS左右两端分别移除所有在C字符串中出现过的字符   </p>
</li>
<li><p><code>sdscmp</code>           比较两个SDS字符串是否相同                                 <code>O(N), N为两个SDS中较短的那个SDS的长度</code>                </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
