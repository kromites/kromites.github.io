<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客介绍</title>
    <url>/posts/e627a59/</url>
    <content><![CDATA[<blockquote>
<p>欢迎您访问此博客！ 点开阅读全文可了解到博客的基本信息和自己在记录时的一些感悟。</p>
</blockquote>
<span id="more"></span>

<p>本博客创建于2021.7.1。作为一名22届毕业的学生，目前的主要精力放在找工作上，因此最近上传的大部分是自己的学习笔记。笔记内容涉及到以下几个主要方面：</p>
<ul>
<li>数据结构与算法</li>
<li>计算机网络</li>
<li>操作系统</li>
<li>网络编程</li>
<li>数据库</li>
<li>项目心得</li>
</ul>
<p>希望自己能够在这个夏天拿到心满意足的Offer！</p>
<p>TO BE CONTINUE~</p>
<hr>
<p>2021-7-30</p>
<p>在这个时间点，博客基本上将自己的学习笔记知识点都详细地罗列出来了，但是很多点深度不够，而且由于内容较多，非常啰嗦。</p>
<p>希望之后的笔记能够精细化，深度化。</p>
<ul>
<li><p>精细化：用自己的语言<strong>精炼的概括，突出重点</strong>，对于一些很常见（默认知道）的知识点略过。</p>
</li>
<li><p>深度化：在一些知识点面前多问自己几个问句：</p>
<ul>
<li><p>该技术特性、功能是什么？ （面对一项技术，最先了解的应该是它的功能）</p>
</li>
<li><p>往内部延伸，该技术如何实现？（可以简单阅读源码，了解其实现的原理）</p>
</li>
<li><p>向外部扩展，该技术的使用场景？（只了解内部是不够的，要将知识串联，这一步很难，因为受限于自己的视野）</p>
</li>
</ul>
</li>
</ul>
<p>当然，<strong>代码能力永远是程序员的基石</strong>，不要过分沉浸在记录中，优先确保自己的代码能力。</p>
<p>希望在提炼知识点时，能够慢慢对自己有个了解：哪方面掌握的不错，哪方面应该会但目前还不太会，哪方面不需要会。</p>
<p>最后，非常感谢昨晚指点我的面试官。    </p>
]]></content>
      <categories>
        <category>非技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/posts/c5176eb2/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章用来初步介绍下什么是RPC，算是网络编程的一个延伸。</p>
<p>（本篇文章算是转载自<a href="https://zhuanlan.zhihu.com/p/148139089%EF%BC%89">https://zhuanlan.zhihu.com/p/148139089）</a></p>
</blockquote>
<span id="more"></span>



<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><h4 id="语义介绍"><a href="#语义介绍" class="headerlink" title="语义介绍"></a>语义介绍</h4><p>​    RPC的语义就是<strong>远程过程调用</strong>：将一个服务调用封装在一个本地方法中，让调用者像使用本地方法一样调用服务，对其屏蔽实现细节。</p>
<p>​    这话的意思不难理解，但是具体的实现一般都是需要一份“协议”：</p>
<ul>
<li>如何封装方法</li>
<li>如何调用远程方法</li>
<li>如何传输方法</li>
</ul>
<p>​     最后，当然还要去相对底层和抽象的视角来理解RPC</p>
<h4 id="三个特点"><a href="#三个特点" class="headerlink" title="三个特点"></a>三个特点</h4><p>​    广义上来讲，<strong>所有本应用程序外的调用都可以归类为RPC</strong>，不管是分布式服务器，还是第三方服务，甚至是对Redis的请求。这些不在本地执行的请求，一般有三个特点：</p>
<ul>
<li><strong>需要事先约定调用的语义（接口语法）</strong></li>
<li><strong>需要网络传输</strong></li>
<li><strong>需要约定网络传输中的内容格式</strong></li>
</ul>
<p>举例：假如一次Redis调用为<code>redis.set(&quot;rpc&quot;, 1)</code>，其中：</p>
<ul>
<li><code>set</code>以及参数<code>(&quot;rpc&quot;, 1)</code>就是接口语法，接口语法由Redis的API给出</li>
<li>Redis Server会监听一个服务端口，通过TCP传输内容，使用事件驱动处理事件</li>
<li>底层库会约定数据如何进行编解码，如何标识命令和参数，如何表示结果，如何表示数据的结尾等等</li>
</ul>
<p>这三个特点都是因为<strong>调用不在本地</strong>而衍生的问题，这也决定了RPC的形态。所有的RPC解决方案都是在解决这三个问题，不断地在提出更加优良的解决方案，试图达到更好的性能，更低的使用成本。</p>
<img src="/posts/undefined/RPC%E7%8A%B6%E6%80%81%E5%9B%BE.jpg" class title="RPC状态图">



<h4 id="约定接口"><a href="#约定接口" class="headerlink" title="约定接口"></a>约定接口</h4><p>​    一般来说，在调用方和服务方都会有约定的接口。这些接口是由双方的Stub提供的。</p>
<p>​    Stub会负责封装命令和参数，并以特定的数据格式进行打包。<strong>其中命令、参数和返回值都是需要客户端和服务端的Stub实现进行协商，双方都需要维护一份完全一样的方法及参数列表。</strong>调用时必须进行严格的约定进行压缩和解压缩。</p>
<p>​    这是一个比较繁杂的过程，混合了<strong>调用语法</strong>和<strong>内容解压缩</strong>两部分内容，可以理解为<strong>如何组织内容</strong>问题。</p>
<h4 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h4><p>​    搞定了协议约定问题后，接下来就是要通过Runtime进行内容传输，一般是需要通过Socket编程来实现，使用TCP或UDP来传输，一般来说是使用TCP来进行可靠传输。同时当对调用性能有要求时，可能会使用<strong>Socket的异步编程模型</strong>，消除等待中的消耗，这会引入事件机制，通过状态机来解析处理或回复请求。当出现超时、丢包等情况时还进行做重试、重传、报错等等。</p>
<p>​    一般来说在网络传输方面有着比较成熟的框架，这些框架分为两类：</p>
<ul>
<li><strong>Restful HTTP JSON</strong></li>
<li><strong>GRPC HTTP2.0 Protobuf</strong></li>
</ul>
<h5 id="Restful-HTTP-JSON"><a href="#Restful-HTTP-JSON" class="headerlink" title="Restful HTTP JSON"></a>Restful HTTP JSON</h5><p>​    Restful是一种<strong>资源状态转换</strong>的架构峰哥，也可以用来实现RPC，由于互联网对HTTP超广泛的支持，这一般是首选。</p>
<p>​    该种方案有以下的特点：</p>
<ul>
<li>通过HTTP协议进行内容传输，Header用来约定编码，body大小等，使用\r\n间隔。</li>
<li><strong>通过URL和对应参数来标示要调用的方法和参数</strong>。<strong>在body中用JSON对内容进行编码，极易跨语言，不需要约定特定的复杂编码格式和Stub文件。</strong></li>
</ul>
<p>当然不仅仅只有优点，还有缺点：（主要性能方面）</p>
<ul>
<li><strong>HTTP的header和Json的数据冗余和低压缩率使得传输性能差</strong></li>
<li>JSON难以表达复杂的参数类型，如结构体等</li>
</ul>
<h5 id="GRPC-HTTP2-0-Protobuf"><a href="#GRPC-HTTP2-0-Protobuf" class="headerlink" title="GRPC HTTP2.0 Protobuf"></a>GRPC HTTP2.0 Protobuf</h5><p>​    GRPC是一款RPC框架，相对来说在性能上做了一些提升和让步：</p>
<ul>
<li><strong>Protobuf进行数据编码，提高数据压缩率</strong></li>
<li><strong>使用HTTP2.0弥补了HTTP1.1的不足</strong></li>
<li><strong>同样在调用方和服务方使用协议约定文件，提供参数可选，为版本兼容留下缓冲空间</strong></li>
</ul>
<p>之后，重点就是Protobuf和HTTP2.0。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​    RPC的远程调用语义，以及其三个特点，然后在这三个特点中可以归纳成约定接口和网络传输两方面。在网络传输中有两种重要的框架，一般我们是基于性能考虑使用GRPC的框架。</p>
<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>​    <a href="https://link.zhihu.com/?target=https://github.com/protocolbuffers/protobuf">protobuf</a>是一款用<strong>C++开发的跨语言、二进制编码的数据序列化协议</strong>，以超高的压缩率著称。</p>
<p>​    它也需要双方维护一个协议约束文件，以<code>.proto</code>结尾，使用<code>proto</code>命令能够对文件进行解析，生成对应的stub程序，<strong>客户端和服务端都需要保存这份Stub程序用来进行编解码</strong>。</p>
<p>​    </p>
<h4 id="WHY？"><a href="#WHY？" class="headerlink" title="WHY？"></a>WHY？</h4><p>​    使用Protobuf的原因自然是<strong>因为其性能好，空间优化强。</strong> 比如传输<code>123</code>，文本类的需要3个字节(ascii 31 32 33)来传输，而二进制类只需要一个字节(01111011)就可以表示。</p>
<p>​    同时因为Protobuf会维护<code>.proto</code>文件，这样在解析文件生成Stub程序时，可以对方法名进行编号，这样也能够省略大量字节，总而言之，其编码能力能够节约空间和处理时间。</p>
<p>​    与之进行对比的json和xml传统策略都太过冗余，性能不是很好。</p>
<h4 id="特点介绍"><a href="#特点介绍" class="headerlink" title="特点介绍"></a>特点介绍</h4><p>首先来看看一个<code>.proto</code>文件的格式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XXXX.proto</span></span><br><span class="line">service Test &#123;</span><br><span class="line">    <span class="function">rpc <span class="title">HowRpcDefine</span> <span class="params">(Request)</span> <span class="title">returns</span> <span class="params">(Response)</span> </span>; <span class="comment">// 定义一个RPC方法</span></span><br><span class="line">&#125;</span><br><span class="line">message Request &#123;</span><br><span class="line">    <span class="comment">//类型 | 字段名字|  标号</span></span><br><span class="line">    int64    user_id  = <span class="number">1</span>;</span><br><span class="line">    string   name     = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">message Response &#123;</span><br><span class="line">    repeated int64 ids = <span class="number">1</span>; <span class="comment">// repeated 表示数组</span></span><br><span class="line">    Value info = <span class="number">2</span>;         <span class="comment">// 可嵌套对象</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, Value&gt; values = <span class="number">3</span>;    <span class="comment">// 可输出map映射</span></span><br><span class="line">&#125;</span><br><span class="line">message Value &#123;</span><br><span class="line">    <span class="keyword">bool</span> is_man = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是这个的特点：</p>
<ul>
<li>有明确的类型，支持的类型有多种</li>
<li>每个field会有名字</li>
<li>每个field有一个<strong>数字标号</strong>，一般按顺序排列(下文编解码会用到这个点)</li>
<li>能表达数组、map映射等类型</li>
<li>通过<strong>嵌套message可以表达复杂的对象</strong></li>
<li>方法、参数的定义落到一个.proto 文件中，<strong>依赖双方需要同时持有这个文件，并依此进行编解码</strong></li>
</ul>
<p>​    不过文件不是代码，不能执行，因此肯定不能直接跨语言，<strong>必须得通过该文件生成相应语言的中间代码</strong>，才能够实现跨语言这个特点。</p>
<p>​    中间代码要有以下的能力：</p>
<ul>
<li><strong>将message转成对象</strong>，例如golang里是struct，Ruby里是class，需要各自表达后，才能被理解</li>
<li><strong>需要有进行编解码的代码，能解码内容为自己语言的对象、能将对象编码为对应的数据</strong></li>
</ul>
<p>​    一般来说，Protobuf提供的是一套统一的protoc工具：<strong>protobuf通过自动化编译器的方式统一提供了这种能力，避免人肉写</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//       依赖目录      生成golang中间代码   对应proto文件地址</span></span><br><span class="line">protoc -I=$SRC_DIR --go_out=$DST_DIR  $SRC_DIR/XXX.proto</span><br><span class="line">protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/XXX.proto <span class="comment">// 生成java中间代码</span></span><br></pre></td></tr></table></figure>



<h4 id="二进制数据流"><a href="#二进制数据流" class="headerlink" title="二进制数据流"></a>二进制数据流</h4><p>​    现在我们只知道一个Protobuf是一个二进制流，那么以下的问题可以思考一下：</p>
<ul>
<li>它该怎么<code>分隔字段</code>、<code>表达层次结构</code>呢？</li>
<li>字段value一般分为两种，一种是定长的，例如一个int，它最多4个字节；第二种是变长的，如字符串，你不知道它在哪儿结束。该如何表示？</li>
<li>对于定长的int，如果对应值是1，那用4个字节表达是不是有些浪费，该如何节省？</li>
</ul>
<p>​    为此，protobuf将数据类型做了<strong>分类</strong>，并且提供了了不同的编码方式</p>
<p>​    值得关注的有两种：</p>
<ul>
<li>Varint，解决定长类型的空间浪费，例如值为1的int32只用1字节，避免用四字节，达到压缩的效果。 T - V</li>
<li>Length-delimi，用来表达长度不定的内容，如string、嵌套数据、数组。 T - L - V</li>
</ul>
<p>（T-V 是定长， T-L-V是表达变长的内容）</p>
<p>嵌套的话，value就是一个T-V或者T-L-V的内容。</p>
<p>​    至于再往文件中的内容就不扩展了。</p>
<h4 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h4><p>上面说了Protobuf如何编解码，以及为什么压缩率会比json高，可以看出其有点有：</p>
<ul>
<li><strong>没有打包无用的数据，排列紧凑，体积小，利于传输</strong></li>
<li><strong>解析策略简单，序列化/反序列化 速度快</strong></li>
<li><strong>能较好的兼容字段(不能解析到的会跳过)</strong></li>
</ul>
<p>但缺点也非常明显：</p>
<ul>
<li>肉眼看不出来value是什么，无法自描述， 难以debug</li>
<li><strong>需要proto文件才能知道如何解析</strong>，否则是天书，这在灵活性上不如json</li>
</ul>
<p>其实在本质上其差别在于：<strong>json的设计是给人看的，protobuf则是利于机器</strong>。</p>
<p>适用场景不同，各有利弊。作为工具，讨论其快、好、差没有意义，在合适的地方，用合适的工具即可。</p>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><p>​    HTTP1.1是网络传输的最广泛的手段，那为什么要使用HTTP2.0呢？</p>
<p>首先看1.1的缺点：</p>
<ul>
<li>HTTP1.1冗余文本过多，导致传输体积更大，即没个报文都有个header，这个header结构会消耗很多空间</li>
<li>并发能力差，HTTP1.1是基于文本的协议，最多也是使用管线化，必须是一个个处理请求，因此还是并发能力差。</li>
</ul>
<p>HTTP2的优点：</p>
<ul>
<li><strong>HTTP2 未改变HTTP的语义(如GET/POST等)，只是在传输上做了优化</strong></li>
<li><strong>引入帧、流的概念，在TCP连接中，可以区分出多个request/response</strong></li>
<li>一个域名只会有一个TCP连接，借助帧、流可以实现<strong>多路复用</strong>，降低资源消耗</li>
<li><strong>引入二进制编码，降低header带来的空间占用</strong></li>
</ul>
<p>由此看来，HTTP2能够在网络传输上做到<strong>更快的传输、更低的资源消耗</strong>这两个目标，与上文呼应。</p>
<p>这两个目标是依靠下面的头部压缩和多路复用两种方法去实现的。</p>
<h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p>​    对于HTTP1.1的头部，会发送大量重复的文本内容，一次次发送占据了大量的带宽，因此选择了头部压缩。</p>
<p>头部压缩的实现： <strong>静态表和动态表的结合</strong></p>
<h5 id="静态表"><a href="#静态表" class="headerlink" title="静态表"></a>静态表</h5><p>​    <strong>将高频使用的Header编成一个静态表</strong>，每个header对应一个数组索引，每次只能用传这个索引，而不是冗长的文本。（这个表肯定是两方都有的）</p>
<p>​    服务端可以根据内容查表，就可以还原出header。</p>
<h5 id="动态表"><a href="#动态表" class="headerlink" title="动态表"></a>动态表</h5><p>​    支持在静态表中动态增加本次连接中的header，也给其整一个编号，在第一次发送时，通过协议将Header天骄到表中，后面的请求都只需要发送编号就行。</p>
<p>​    <strong>(请求方/服务方的表成员会保持同步一致)</strong></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>静态表是协议级别的约定，是不变的内容。动态表则是基于当前TCP连接进行协商的结果，发送请求前会互相设置好header，让请求方和服务方维护同一份动态表，后续的请求可复用。<strong>连接销毁时，动态表也会注销</strong>。</p>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>​    HTTP1.1处理连接必须得按照一定的顺序，不然它无法区分这个response是属于哪个请求，一旦多个请求返回的文本内容混在一起，那就会出现问题。这样的话会导致TCP资源的闲置。</p>
<p>​    HTTP2.0使用TCP连接复用的方式，从而提升响应的效率，那么如何实现连接复用呢？</p>
<p>​    HTTP2提出了<strong>流</strong>的概念，<strong>每一次请求对应一个流，有一个唯一ID，用来区分不同的请求</strong>。基于流的概念，进一步提出了<strong>帧</strong>，<strong>一个请求的数据会被分成多个帧，方便进行数据分割传输，每个帧都唯一属于某一个流ID，将帧按照流ID进行分组，即可分离出不同的请求。</strong></p>
<p>​    这样同一个TCP连接能够同时并发多个请求，不同请求的帧可以穿插在一起，根据流ID分组即可。</p>
<p>​     这也是多路复用思想的一种落地方式，在很多消息队列协议中也广泛存在，如AMQP[4]，其channel的概念和流如出一辙，大道相通。</p>
<p>​    在HTTP2中，<strong>流是一个逻辑上的概念，实际上就是一个int类型的ID，可顺序自增，只要不冲突即可</strong>，每条<code>帧</code>数据都会携带一个流ID，当一串串帧在TCP通道中传输时，通过其流ID，即可区分出不同的请求。</p>
<p>​    <strong>帧则有更多较为复杂的作用，HTTP2几乎所有数据交互，都是以帧为单位进行的</strong>，包括header、body、约定配置(除了Magic串)，这天然地就需要给帧进行分类，于是协议约定了以下帧类型：</p>
<ul>
<li><strong>HEADERS：帧仅包含 HTTP header信息。</strong></li>
<li><strong>DATA：帧包含消息的所有或部分请求数据。</strong></li>
<li>PRIORITY：指定分配给流的优先级。服务方可先处理高优先请求</li>
<li>RST_STREAM：错误通知：一个推送承诺遭到拒绝。终止某个流。</li>
<li>SETTINGS：指定连接配置。(用于配置，流ID为0) [会ACK确认收到]</li>
<li>PUSH_PROMISE：通知一个将资源推送到客户端的意图。</li>
<li><strong>PING：检测信号和往返时间</strong>。（流ID为0）[会ACK]</li>
<li>GOAWAY：停止为当前连接生成流的停止通知。</li>
<li>WINDOW_UPDATE：用于流控制，约定发送窗口大小。</li>
<li>CONTINUATION：用于继续传送header片段序列。</li>
</ul>
<p>一次HTTP2的请求有以下过程：</p>
<ul>
<li>通过一个或多个SETTINGS帧约定一些数据（会有ACK机制，确认约定内容）</li>
<li>请求方通过<strong>HEADERS帧</strong>将请求A的header打包发出</li>
<li><em>请求B可穿插···</em></li>
<li>请求方通过<strong>DATA帧</strong>将请求A的request数据打包发出</li>
<li>服务方通过<strong>HEADERS帧</strong>将请求A的response header打包发出</li>
<li><em>请求C可穿插···</em></li>
<li>服务方通过<strong>DATA帧</strong>将请求A的response数据打包发出</li>
</ul>
<h4 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h4><p>​    在知道了HTTP这两个特性的原理之后，来往内部看如何实现这两个特性。</p>
<p>​    <strong>任何一个应用层的传输协议，都需要解决一个问题，那就是如何表示数据结尾，如何分割数据。</strong>在H1.1中，我们知道，它粗暴地先发Header，再发body，每个header通过<code>\r\n</code>文本内容来分割，header和body通过<code>\r\n\r\n</code>来分割，通过content-length的值读取body，一个请求的内容就成功结束。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">// 一次请求的返回</span><br><span class="line">200 OK\r\nHeader1:Value1\r\nHeader2:Value2\r\nHeader3:Value3\r\n\r\nI am body</span><br><span class="line">// 网络中实际传输的是上面文本的ascii编码</span><br></pre></td></tr></table></figure>

<p>​    <strong>HTTP2 为了降低协议占用，不会使用文本分割，也不会使用文本来表示header。它是如何表示一帧开始、一帧结束、header传完了、body传完了呢？</strong></p>
<p>下面是帧格式，所有帧都是一个固定的 <strong>9 字节头部</strong> (payload 之前) 跟一个指定长度的数据(payload):</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="code">+-----------------------------------------------+</span></span><br><span class="line"><span class="section">|                 Length (24)                   |</span></span><br><span class="line"><span class="section">+---------------+---------------+---------------+</span></span><br><span class="line"><span class="section">|   Type (8)    |   Flags (8)   |</span></span><br><span class="line"><span class="section">+-+-------------+---------------+-------------------------------+</span></span><br><span class="line"><span class="section">|R|                 Stream Identifier (31)                      |</span></span><br><span class="line"><span class="section">+=+=============================================================+</span></span><br><span class="line"><span class="section">|                   Frame Payload (0...)                      ...</span></span><br><span class="line"><span class="section">+---------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Length代表整个帧的长度，24位无符号整数，字节为单位，只记录Frame PayLoad</p>
</li>
<li><p>Type定义为帧的类型，用8bits表示。帧类型决定了帧的格式和语义，不同类型有差异</p>
</li>
<li><p><strong>Flags 是为帧类型相关而预留的布尔标识</strong>。标识对于不同的帧类型赋予了不同的语义，例如下面会提到的Padding</p>
</li>
<li><p><strong>R 是一个保留的比特位。这个比特的语义没有定义，发送时它必须被设置为 (0x0), 接收时需要忽略。</strong></p>
</li>
<li><p><strong>Stream Identifier 唯一标示一个流，用 31 位无符号整数表示</strong>。客户端建立的 sid 必须为奇数，服务端建立的 sid 必须为偶数，值 (0x0) 保留给与整个连接相关联的帧 (连接控制消息)，而不是单个流</p>
</li>
<li><p><strong>Frame Payload 是主体内容，由帧类型决定</strong>（上面的<strong>9个字节都是协议本身的消耗，payload才是请求本身的主要内容</strong>）</p>
</li>
</ul>
<p>不同的帧类型，有不同的Payload格式，我们分别介绍DATA帧和HEADDERS帧：</p>
<p>DATA帧的Payload:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+</span><br><span class="line"> |Pad Length? (8)|</span><br><span class="line"> +---------------+-----------------------------------------------+</span><br><span class="line"> |                            Data (*)                         ...</span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line"> |                           Padding (*)                       ...</span><br><span class="line"> +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>Pad Length: ? 表示此字段的出现时有条件的，当帧的Flags(8)的第三位为1时，才有效，否则会被忽略</li>
<li>Data: 传递的数据，其长度上限等于帧的 payload 长度减去其他出现的字段长度(如果有pad的话)。在gRPC中，Data这部分内容就是用Protobuf将数据编码的结果</li>
<li>Padding: 填充字节，没有具体语义，发送时必须设为 0，作用是混淆报文长度，为安全目的服务</li>
</ul>
<p>Data帧的Flags(8)目前有两个位有意义：</p>
<ul>
<li>END_STREAM: bit 0 设为 1 代表当前流的最后一帧，告诉接收方<strong>请求数据发送完毕</strong>，否则还要继续等下一帧(接收方)</li>
<li>PADDED: bit 3 设为 1 代表存在 Padding</li>
</ul>
<p>HEADER帧Payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+</span><br><span class="line"> |Pad Length? (8)|</span><br><span class="line"> +-+-------------+-----------------------------------------------+</span><br><span class="line"> |E|                 Stream Dependency? (31)                     |</span><br><span class="line"> +-+-------------+-----------------------------------------------+</span><br><span class="line"> |  Weight? (8)  |</span><br><span class="line"> +-+-------------+-----------------------------------------------+</span><br><span class="line"> |                   Header Block Fragment (*)                 ...</span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line"> |                           Padding (*)                       ...</span><br><span class="line"> +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>Pad Length: 同DATA帧</li>
<li>E: 一个比特位声明流的依赖性是否是排他的，存在则代表 PRIORITY flag 被设置</li>
<li>Stream Dependency: 指定一个 stream identifier，代表当前流所依赖的流的 id，存在则代表 PRIORITY flag 被设置</li>
<li>Weight: 一个无符号 8 为整数，代表当前流的优先级权重值 (1~256)，存在则代表 PRIORITY flag 被设置</li>
<li>Header Block Fragment: header 块片段，header依次打包排列在里面</li>
<li>Padding: 同DATA帧</li>
</ul>
<p>于上面头部压缩的内容，我们知道header可以存在于静态表、动态表中。此时只需要传一个index即可表达对应的header，减少传输内容。 请求传递的header情况有以下几种：</p>
<ul>
<li>header 的key、value 在静态表/动态表中，<strong>此时只需要传递一个index即可</strong></li>
<li>header 的key 在静态、动态表中，而value由于多种多样，不在表中(如Host)，此时key可以由index表示，但value需要传递原内容</li>
<li>header 的**key、value完全不在静态、动态表中，key、value都需要传递原内容(**字符串)</li>
<li>希望将本次传递的header写入动态表中，下次只需要传index 即可</li>
<li>不希望本次传递的header写入动态表中</li>
</ul>
<p>如果想进一步提升，那就使用HTTP3，拥抱QUIC。</p>
<h3 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h3><p>//todo</p>
]]></content>
      <categories>
        <category>技术入门</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>Protobuf</tag>
        <tag>HTTP2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>图的算法</title>
    <url>/posts/5b871085/</url>
    <content><![CDATA[<blockquote>
<p>图的算法在笔试面试中也越来越常见了，但是这些算法使用场景都很固定，算法模板化也很强，很适合作为笔记学习一下。</p>
<p>图算法大致分为并查集，DFS，BFS，最小生成树，单源最短路径和拓扑排序这几种</p>
</blockquote>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>如果给你一些顶点，并且告诉你每个顶点的连接关系，你如何才能快速的找出两个顶点是否具有连通性呢？</p>
<p>关键词： <strong>节点的连通性</strong></p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	QuickFind : find -&gt; O(1) but Union -&gt; O(N) r</span></span><br><span class="line"><span class="comment"> *				root[x] is the root node of x</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickFind</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">QuickFind</span>(<span class="keyword">int</span> size):<span class="built_in">size_</span>(size), <span class="built_in">root</span>(vector&lt;<span class="keyword">int</span>&gt;(size)) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">			root[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> root[x];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> rootX = root[x];</span><br><span class="line">		<span class="keyword">auto</span> rootY = root[y];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rootX == rootY)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; size_; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (root[i] == rootY) &#123;</span><br><span class="line">				root[i] = rootX;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">size_t</span>      size_;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  QuickUnion : find -&gt; not O(1), </span></span><br><span class="line"><span class="comment"> *				 root[x] is the father node of x.</span></span><br><span class="line"><span class="comment"> *				 rank[x] is the length of tree </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickUnion</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">QuickUnion</span>(<span class="keyword">int</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">root</span>(vector&lt;<span class="keyword">int</span>&gt;(size)), <span class="built_in">rank</span>(vector&lt;<span class="keyword">int</span>&gt;(size, <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i&lt;size; ++i) &#123;</span><br><span class="line">			root[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// todo: understand  这个find两种方式都可，很关键</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// if (x == root[x])</span></span><br><span class="line">		<span class="comment">// 	return x;</span></span><br><span class="line">		<span class="comment">// return root[x] = find(root[x]);</span></span><br><span class="line">		<span class="keyword">while</span>(x != root[x]) &#123;</span><br><span class="line">			root[x] = root[root[x]];</span><br><span class="line">			x = root[x];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">		<span class="keyword">auto</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(rootX != rootY) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (rank[rootX] &gt; rank[rootY]) &#123;</span><br><span class="line">				root[rootY] = rootX;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">				root[rootX] = rootY;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				root[rootY] = rootX;</span><br><span class="line">				rank[rootX] += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">size_t</span> size_;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; root;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; rank;	<span class="comment">// 秩 这个很关键</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>



<p>总结：并查集是一种没写过会觉得很惶恐的题目，但是如果写过就知道主要函数是<code>find</code>和 <code>Union</code>上，这两个函数find是关键，一般要使用路径压缩，然后Union的话就是直接查找根节点是否相同，不相同低秩的树作为高秩的子树。</p>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>如果给你一个「图」，你该如何找出它所有的顶点呢？以及你又如何找出它两个顶点之间的所有路径呢</p>
<p>关键词：两个顶点间的<strong>所有路径</strong></p>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><p><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></p>
<p>和树的DFS很相似。使用传统的回溯算法即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="comment">// 起始状态：从0开始</span></span><br><span class="line">    temp.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(graph, <span class="number">0</span>,  temp, n);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> node, vector&lt;<span class="keyword">int</span>&gt;&amp; temp, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 终止状态：n-1结束</span></span><br><span class="line">    <span class="keyword">if</span>(node == n<span class="number">-1</span>)&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it : graph[node])&#123;</span><br><span class="line">        <span class="comment">// 进行回溯</span></span><br><span class="line">        temp.<span class="built_in">push_back</span>(it);</span><br><span class="line">        <span class="built_in">dfs</span>(graph, it, temp, n);</span><br><span class="line">        temp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：DFS一般是去找到<strong>两个顶点间的全部路径</strong>，针对已知固定顶点出发要求路径的话都可以使用回溯，即使终点不明确也可以。</p>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><h4 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a></h4><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>一般是求已知节点之间的最短距离，但是图的BFS有一个大前提：当在 <strong>权重相等且均为正数的「图」</strong> 中，它可以快速的找到两点之间的最短路径。</p>
<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><p>和树一样，正常的使用队列和visited数组</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>// todo</p>
<h3 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h3><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>​    一般是在加正值权图中，给定一个起点，求出它分别到其他顶点的「最短路径」</p>
<p>​    根据图的记录方式有两种不同的算法：</p>
<ul>
<li>邻接矩阵：一般用于稠密图，边比较多，使用Dijkstra算法</li>
<li>邻接链表：一般用于稀疏图，点比较多，使用BFS + 最小堆 （使用C++的话可以直接使用优先队列）</li>
</ul>
<h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><p>针对邻接矩阵：</p>
<ol>
<li>建立一个邻接矩阵<code>graph</code></li>
<li>建立最短距离表和访问节点标记数组</li>
<li>循环所有节点，检查其它节点有没有相距路径，有的话修改dist</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = INT_MAX/<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="comment">// start 为源节点， graph 为 邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span> n = graph;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(n, inf)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;n; ++y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[y] == <span class="number">0</span> &amp;&amp; (x == <span class="number">-1</span> || dist[y] &lt; dist[x]))&#123;</span><br><span class="line">                x = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;n; ++y)&#123;</span><br><span class="line">            dist[y] = <span class="built_in">min</span>(dist[y], dist[x] + graph[x][y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = *<span class="built_in">max_element</span>(dist.<span class="built_in">begin</span>(), dist.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans == inf ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>针对邻接链表：</p>
<ol>
<li>先建立一个邻接表</li>
<li>初始化建立一个与源节点最短距离的数组，并且将源节点入优先队列</li>
<li>从源节点开始挨个检查该节点到源节点是否已经是目前的最小值，如果是，则跳过该节点</li>
<li>如果不是的话，那么肯定有更小距离的路径，将该节点的所有边都检查一遍，修改与该节点相连接的点的最小距离。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">	<span class="comment">// times-&gt; 边的次数； n -&gt; 节点总数; k -&gt; 源节点</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf = INT_MAX/<span class="number">2</span>;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line">    <span class="comment">// 步骤1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t: times)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = t[<span class="number">0</span>]<span class="number">-1</span>, y = t[<span class="number">1</span>]<span class="number">-1</span>, dist = t[<span class="number">2</span>]<span class="number">-1</span>;</span><br><span class="line">        g[x].<span class="built_in">emplace_back</span>(y, t[<span class="number">2</span>]);      <span class="comment">//  &lt;node, dist&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 步骤2</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dist</span><span class="params">(n, inf)</span></span>;</span><br><span class="line">    dist[start<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">0</span>, start<span class="number">-1</span>);	<span class="comment">// &lt;dist, node&gt;</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> p=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> time = p.first, x = p.second;</span><br><span class="line">        <span class="comment">// 步骤3：如果这个节点已经是最小的，那就不需要洪泛所有边</span></span><br><span class="line">        <span class="keyword">if</span>(dist[x] &lt; time)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 步骤4：find next node 根据节点查找相关边，与节点相关的边进行洪泛</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : g[x])&#123;</span><br><span class="line">            <span class="keyword">int</span> y = e.first, d = dist[x] + e.second;</span><br><span class="line">            <span class="keyword">if</span>(d &lt; dist[y])&#123;</span><br><span class="line">                dist[y] = d;</span><br><span class="line">                q.<span class="built_in">emplace</span>(d, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = *<span class="built_in">max_element</span>(dist.<span class="built_in">begin</span>(), dist.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans == inf ? <span class="number">-1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>针对<strong>有向无环图</strong> 的一种算法。它是对「图」中所有顶点按照先后顺序的一种线性排序。</p>
<h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><p>根据入度+BFS来实现，即Kahn算法</p>
<ol>
<li>通过边来记录各个节点的入度，并且再建立一个记录后继节点的链表</li>
<li>找到入度为0的一个节点，将其入队</li>
<li>入队之后，遍历其后继节点，将其入度-1</li>
<li>然后再对入度数组进行遍历，寻找入度为0的一个节点，将其入队，进行2~3循环，节点全部被访问或者没有入度为0的点。(<strong>如果有环的图，那么就拓扑排序失败了</strong>)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(c)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++)</span><br><span class="line">        cin &gt;&gt; temp[j];</span><br><span class="line">    <span class="comment">// 步骤 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; c; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        num_in[temp[j] - <span class="number">1</span>]++;</span><br><span class="line">        outedge[temp[j - <span class="number">1</span>] - <span class="number">1</span>].<span class="built_in">push_back</span>(temp[j] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 步骤 2</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_in.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num_in[i] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 步骤 3</span></span><br><span class="line">        <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(x + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 步骤 4</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : outedge[x])</span><br><span class="line">        &#123;</span><br><span class="line">            num_in[y]--;</span><br><span class="line">            <span class="comment">// 步骤 2</span></span><br><span class="line">            <span class="keyword">if</span> (!num_in[y])</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/posts/8a15ea5f/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章记录下自己所理解的缓存</p>
</blockquote>
<span id="more"></span>





<p><strong>缓存是一种利用数据冗余，牺牲部分数据容量来提高该部分数据容量读取速度的一种方式。</strong></p>
<ul>
<li>利用数据冗余：缓存一般是重复数据。</li>
<li>提高读取速度：缓存一般用于<strong>两端（缓存读入端和缓存输出端）速度有差异的情况下，或者两端速度都很慢的情况下，使用缓存能够提高速度</strong>。</li>
</ul>
<p>典型实现</p>
<h4 id="内存——缓存——磁盘"><a href="#内存——缓存——磁盘" class="headerlink" title="内存——缓存——磁盘"></a>内存——缓存——磁盘</h4><p>在该模型下内存处理速度很快，磁盘的处理速度很慢。在此之间加入一个缓存，<strong>缓存的处理速度远高于磁盘，稍低于内存</strong>。在此情况下，将（频繁读取）数据存储在缓存中，内存就可以直接从缓存中拿东西了，而不需要去忍受磁盘的速度。</p>
<h4 id="服务器——Redis——MySQL"><a href="#服务器——Redis——MySQL" class="headerlink" title="服务器——Redis——MySQL"></a>服务器——Redis——MySQL</h4><p>在该模型下一般来说也是将Redis这种键值数据库当做缓存，这也是因为服务器直接读取MySQL的速度和读取Redis上的数据差距很大，这样将服务器需要频繁拉取的信息存放在Redis中，也能够加快速度。</p>
<p>比如聊天系统中，在用户登录之后，服务器需要从MySQL中拉取该用户的信息，以及好友信息，黑名单等。这时可以让Redis去拉取，然后将这些信息放到Redis中，服务器要想要的话，直接从Redis中拉取就行了。</p>
<h4 id="缓存相关概念"><a href="#缓存相关概念" class="headerlink" title="缓存相关概念"></a>缓存相关概念</h4><p>一般在数据库方面，缓存所应用的就是Redis服务器</p>
<p>有关Redis缓存概念（如缓存雪崩、缓存击穿、缓存穿透）和解决方案可参考该博客<a href="https://zhuanlan.zhihu.com/p/346651831">https://zhuanlan.zhihu.com/p/346651831</a></p>
<p><strong>一般缓存的问题都是在高并发下才能体现出来</strong></p>
<ul>
<li><p>缓存穿透：假如有黑客<strong>传进大量数据库中的不存在的key</strong>，这样会使大量无效请求作用在MySQL数据库上，使其压力很大，直接宕机。</p>
<ul>
<li><p>解决方案： </p>
<ul>
<li><p>使用布隆过滤器，如果不存在，那么数据库里没有，直接返回</p>
</li>
<li><p>Redis缓存中直接返回空值</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存击穿：假如Redis中有个热点Key无效（过期）了，这时如果有大量的请求来访问该key值，Redis上找不到，那么都会去数据库上找，这样也会使大量请求作用在MySQL数据库上，使其压力很大，直接宕机。</p>
<ul>
<li>解决方案：<ul>
<li>对于热点key不设置过期时间（但是浪费内存）</li>
<li>提供分布式锁（如mutex)，如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了并发量。（但是会降低性能）</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存雪崩：假如Redis宕机了，或者大量的key值在同一时间段过期，这时如果有大量请求来访问，Redis也没用，那么也会去数据库上找，这样也会使大量请求作用在MySQL数据库上，使其压力很大，直接宕机。</p>
<ul>
<li>解决方案：<ul>
<li>针对宕机问题：搭建Redis集群，提高Redis容灾性。</li>
<li>针对大量key值同时过期： 在过期时间增加一个随机值，避免同时过期。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这些缓存问题都是想让主数据库直接宕机，因此不仅要在缓存上做提升，还可以增加MySQL的容灾机制，如：</p>
<ul>
<li><p><strong>使用熔断机制</strong>。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。（这让我想到了教务管理系统。。。）</p>
</li>
<li><p>提高数据库的容灾能力，可以使用<strong>分库分表</strong>，读写分离的策略。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>剖析智能指针</title>
    <url>/posts/af38cf01/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章记录一下Cpp11新特性：智能指针。主要聚焦于WHY, WHAT, HOW。</p>
</blockquote>
<span id="more"></span>

<h3 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h3><p>智能指针是C++11的新特性，在之前的C++语法中，没有垃圾回收机制，要想对动态内存管理，只靠用户的new和delete。</p>
<p><strong>直接使用这组函数很容易造成内存泄漏和使用非法内存的指针</strong>，为了更好更规范的应用动态内存，C++11使用了智能指针。</p>
<h3 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h3><ul>
<li><p>智能指针：一种能够负责<strong>自动释放所指向的对象</strong>的指针。</p>
</li>
<li><p>类型：根据管理底层指针的方式，分为三类</p>
<ul>
<li><p><code>shared_ptr</code>：允许多个指针指向同一个对象</p>
</li>
<li><p><code>unique_ptr</code>:  一个指针独占该对象</p>
</li>
<li><p><code>weak_ptr</code>: 弱引用，指向<code>shared_ptr</code>所指的对象，主要解决<strong>循环引用</strong>的问题</p>
</li>
</ul>
</li>
<li><p>基本原理：</p>
<ul>
<li>在构造函数或者调用<code>make_shared</code>，<code>make_unique</code>时调用<code>new operator</code>（关于new操作对内存的处理可参考其它文章）。</li>
<li>在析构函数时调用<code>delete operator</code></li>
</ul>
</li>
</ul>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharePtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SharePtr</span>();</span><br><span class="line">	~<span class="built_in">SharePtr</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T* ptr_;</span><br><span class="line">	<span class="keyword">size_t</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上图是一个简单的shared_ptr模型，在此之间可以看到有两个变量，一个是指针变量，一个是引用计数变量。</p>
<ul>
<li>指针变量：该指针变量指向目标对象。</li>
<li>引用计数变量： 该引用计数记录着指向相同对象的<code>share_ptr</code>的个数。（在赋值或者拷贝构造的时候会+1）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span>	<span class="comment">// call copy ctor, and the count = 2;</span></span></span><br></pre></td></tr></table></figure>

<p>在shared_ptr的析构函数中，会进行两步操作：</p>
<ul>
<li><p><strong>释放该指针</strong>，并且引用计数-1。（只是销毁指针而已）</p>
</li>
<li><p><strong>判断引用计数是否为0，若为0，那么释放对象（销毁对象并释放空间）</strong>。</p>
</li>
</ul>
<p><strong>引用计数保证了，只有在最后一个指向该对象的智能指针销毁之后，才能释放对象内存。</strong></p>
<p>但是引用计数也会有缺点，查看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	shared_ptr&lt;B&gt; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	shared_ptr&lt;A&gt; ptr; <span class="comment">// fix --&gt; weak_ptr&lt;A&gt; ptr; </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	shared_ptr&lt;A&gt; pa = make_shared&lt;A&gt;();</span><br><span class="line">	shared_ptr&lt;B&gt; pb = make_shared&lt;B&gt;();</span><br><span class="line">	pa-&gt;ptr = pb;</span><br><span class="line">	pb-&gt;ptr = pa;</span><br><span class="line">    cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// ans : 2  2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return 之后， 引用计数为 1, 1. 这样就没有调用delete释放对象，造成内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中的产生的问题叫<strong>循环引用</strong></p>
<p>如何解决？——weak_ptr。</p>
<p>weak_ptr是一种弱引用，并不会对引用计数造成增加，如果是循环引用的问题，将其中一个 shared_ptr改成weak_ptr即可。</p>
<p>（owner持有指向child的shared_ptr，child持有owner的weak_ptr)</p>
<p><strong>线程安全问题</strong></p>
<p>​    这种问题就是看源码，源码面前无秘密。</p>
<p>​    <strong>shared_ptr只是引用计数是线程安全的，指针本身是和内置类型一样级别的线程安全（和标准库容器一样）。</strong></p>
<ul>
<li><p>引用计数的线程安全：<strong>windows上是一个syscall，由windows运行时提供的原子自增接口，gnu是内联汇编，lock之后inc</strong></p>
</li>
<li><p>指针的线程安全：对于读操作是安全的，对于写操作是必须得加锁才安全。（<strong>毕竟是有两个变量，不能原子化</strong>）</p>
</li>
</ul>
<p>在多线程中拷贝或者赋值一个shared_ptr，通常是要加锁的，因为相当于对引用计数进行了修改。</p>
<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>​    这个指针比shared_ptr更易懂，因为<strong>该指针是独享被管理对象指针所有权的智能指针</strong>。（注意独享的是被管理对象<strong>指针</strong>所有权）。</p>
<p>因此unique_ptr有一些特点</p>
<ul>
<li><p><strong>无引用计数，永远是独享的</strong></p>
</li>
<li><p>无拷贝，赋值运算符操作</p>
</li>
<li><p>可转移所有权（使用move)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title>项目多线程日志</title>
    <url>/posts/7acd93ae/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章剖析一下WebServer项目中所做的日志库。主要集中点在为什么，做了什么，效果如何这三个问题上。</p>
</blockquote>
<span id="more"></span>

<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><h4 id="为什么做日志库"><a href="#为什么做日志库" class="headerlink" title="为什么做日志库"></a>为什么做日志库</h4><p>​    做日志库的原因如下：</p>
<ul>
<li><strong>故障诊断和追踪</strong>：如果一个项目中有一个完善的日志库，那么在开发和运维中都能够准确高效的找到问题所在。本人写该项目时基本上将日志库代替了断点功能，能够清晰的定位到项目在哪个文件的具体行数出现问题，导致Bug的产生。</li>
<li><strong>性能原因</strong>：如果仅仅是故障诊断和追踪的话，那么使用<code>iostream</code>就可以了，但是处于性能的考虑，还是自己实现并优化。</li>
</ul>
<h4 id="为什么要线程安全"><a href="#为什么要线程安全" class="headerlink" title="为什么要线程安全"></a>为什么要线程安全</h4><ul>
<li>该项目是多线程的，如果线程不安全的话，那么只能<strong>每个线程的单独写一个文件</strong>，这样不仅性能差，而且会造成线程阻塞在写磁盘操作上。</li>
</ul>
<p>综上可知道为什么要做多线程日志库，下面来讲述下其功能需要什么。</p>
<h3 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h3><h4 id="多线程日志库需要什么功能"><a href="#多线程日志库需要什么功能" class="headerlink" title="多线程日志库需要什么功能"></a>多线程日志库需要什么功能</h4><ul>
<li><p>输出日志基本信息：日志级别 + 时间戳 + 线程号 + 文件名 + 日志语句所在行数等。</p>
</li>
<li><p>设置日志级别，运行时可过滤日志，输出日志级别高于语句日志级别时，<strong>既不输出，也要无开销</strong></p>
</li>
<li><p>在多线程中不阻塞，且不造成争用，线程安全。</p>
</li>
<li><p>磁盘写入的性能得高效</p>
</li>
</ul>
<p>综上可知道多线程日志库需要的功能，下面讲述下这些功能如何实现</p>
<h3 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h3><h4 id="日志基本信息"><a href="#日志基本信息" class="headerlink" title="日志基本信息"></a>日志基本信息</h4><p>时间戳：</p>
<ul>
<li><p>通过<code>gettimeofday()</code>来获取当前时间，因为<strong>该函数不是系统调用</strong>，提高获取时间的性能，且能够精确到微秒。</p>
</li>
<li><p>缓存时间戳字符串，在一秒之内的多条日志只需重新格式化微秒部分，提高<strong>格式化的性能</strong>。</p>
</li>
</ul>
<p>其他日志信息</p>
<ul>
<li>利用内置函数提前格式化缓存好。</li>
</ul>
<h4 id="日志级别与过滤"><a href="#日志级别与过滤" class="headerlink" title="日志级别与过滤"></a>日志级别与过滤</h4><p>日志级别</p>
<ul>
<li><p>设置不同级别，打印时日志信息不同。</p>
</li>
<li><p>针对特殊级别，需要有不同的行为（如FATAL中会打印并abort）。</p>
</li>
<li><p>写项目中<strong>规范级别的使用</strong>！</p>
</li>
</ul>
<p>过滤</p>
<ul>
<li>直接使用if语句，来过滤低级别日志信息。<strong>性能消耗仅仅是一次判断，而无磁盘消耗。</strong></li>
</ul>
<h4 id="多线程不阻塞，且线程安全"><a href="#多线程不阻塞，且线程安全" class="headerlink" title="多线程不阻塞，且线程安全"></a>多线程不阻塞，且线程安全</h4><p>采用<strong>异步日志（非阻塞日志）</strong>：<strong>用一个日志线程负责收集日志信息，并写入日志文件。 其它工作线程只管往该日志线程发送日志消息。</strong></p>
<p>具体实现：</p>
<ol>
<li>其它线程跨线程写入日志线程的缓冲区</li>
<li>工作线程将缓冲区的内容flush到指定文件中</li>
</ol>
<p>这样就实现了<strong>线程安全且输出至单个文件的多线程日志</strong>，<strong>只需要保证步骤1的线程安全即可</strong>。</p>
<ul>
<li><p>输入方：其他工作线程</p>
</li>
<li><p>输出方：日志线程</p>
</li>
</ul>
<h4 id="磁盘写入的性能"><a href="#磁盘写入的性能" class="headerlink" title="磁盘写入的性能"></a>磁盘写入的性能</h4><p>上面的方法已经能够保证该日志是线程安全的，但是依旧可以思考一下，步骤一写入日志线程的缓冲区之后该怎么办？缓冲区又该如何设置呢？</p>
<ul>
<li>最常见的，缓冲区有数据就flush，那么该缓冲区就反复在被其他线程输入和磁盘输出之间。众所周知，<strong>前者是内存操作，速度是快于磁盘操作的</strong>（两个操作都需要加锁）。</li>
</ul>
<p>上面的方法性能很低，低在两方面，一是<strong>磁盘操作过于频繁，而是加锁的频繁度</strong>。</p>
<p>这里就展现出了一种方法，<strong>双缓存技术</strong></p>
<ul>
<li>缓冲区不止一块，多块进行轮流操作</li>
<li>缓冲区分前后端，前端是将日志信息输入到bufferA中，后端是将bufferB信息写入磁盘中。由于缓冲区有多块，带来了以下的优点：<ul>
<li>前后端都涉及到锁，但不是对同一缓冲区进行加锁，这样提高了性能。</li>
<li>前端是内存操作，速度快，缓冲区容量大，这样能够使得日志库的吞吐量高；</li>
<li>后端是磁盘操作，不过其相当于<strong>批处理</strong>一整块数据，不用频繁调用磁盘操作，也减少了线程唤醒的频度，降低开销。这样使得日志库写入文件速度加快。</li>
</ul>
</li>
</ul>
<p>综上，这就是该日志库的功能实现的描述，主要聚焦于<strong>如何日志库线程安全和吞吐量，写入文件速度都快</strong>！</p>
<p>最后针对功能的实现，能够做到日志连续输出的间隔时间只在10微秒左右。</p>
<h3 id="PROBLEM"><a href="#PROBLEM" class="headerlink" title="PROBLEM"></a>PROBLEM</h3><p>在经历过WHY、WHAT、HOW之后，对整个日志库已经有了完整的了解。但是这里依然有一些问题。</p>
<ul>
<li><p>双缓冲技术如何调整flush的频率？</p>
<p>使用两种方法调整</p>
<ul>
<li>基于定时器的时间调整（如每3sflush一次）</li>
<li>基于write次数的调整（如每写入1000条flush一次）</li>
</ul>
<p>自己的项目中，对于时间事件描绘不多，使用的是基于写入次数的调整。</p>
</li>
<li><p>如果后端写入速度太快，缓冲区满了怎么办？</p>
<ul>
<li>有备用的缓冲区，双缓冲技术只是分割了前后端，前后端可以分别有多个缓冲区。</li>
</ul>
</li>
<li><p>如果陷入死锁的话，缓冲区堆积怎么办？</p>
<ul>
<li>死锁，缓冲区数量到达一定数量，那么直接丢弃缓冲区数据。</li>
</ul>
</li>
<li><p>如果服务器宕机或者abort了怎么办，最后的日志数据可能会丢失，这该怎么办？</p>
<ul>
<li>针对abort的情况下，在此之前先flush文件，然后再abort。</li>
<li>针对服务器突然宕机，那么只能在core dump文件中查找cookie了（但是，这个基本没用到过）</li>
</ul>
</li>
</ul>
<h3 id="THINK"><a href="#THINK" class="headerlink" title="THINK"></a>THINK</h3><ul>
<li><p>针对一个日志相类似的东西，要想保证其线程安全性，可以学习该思路，分前后端，使得其他线程都输出到日志专用线程，然后日志专用线程专心去写入文件中。这里的好处是：</p>
<ul>
<li><p>工作职能清晰化，有专门的日志线程。</p>
</li>
<li><p>工作效率高，资源不浪费，如果每个线程都对直接对文件操作，会引起线程争用。</p>
</li>
<li><p>加锁明确，临界区小。加锁区域只是在工作线程输入到日志线程中的缓冲区中。</p>
</li>
</ul>
</li>
<li><p>如何利用好双缓冲技术？它的使用场景有什么？</p>
<p>首先要明白双缓冲技术的场景：输入端内存操作，输出端磁盘操作，两端速度不匹配。</p>
<ul>
<li>如果是按照1：1来处理，那么性能会被磁盘操作所拖累。</li>
<li>因此这里借助了一个概念：<strong>批处理</strong>。输入端快速，那么先用缓冲区存储快速的结果，一批批地将数据进行磁盘操作，这样可以达到n:1，提升效率。</li>
<li>而且前后端分离，也会让缓冲区的只能更清晰，对加锁也更方便，不然输入和输出都对一个缓冲区进行加锁可能会出问题。</li>
</ul>
<p>这样的我们可以思考，只要是输入输出速度不匹配都可以用此方法，在该项目中就有一种相似的思想:</p>
<ul>
<li>如果用户在当前IO线程调用<code>EventLoop::runInLoop(callback_)</code>，回调会同步进行；</li>
<li>如果用户在其他线程调用该函数，<code>callback_</code>会被加入到队列中，该IO线程唤醒之后来调用这个回调函数。</li>
</ul>
<p>这样也是一种缓冲机制，通过队列的思想，来减少该IO线程的唤醒次数。如果是每次都唤醒的话，那样就太不高效了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
      <tags>
        <tag>多线程日志</tag>
        <tag>WebServer</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL高级特性</title>
    <url>/posts/c13ffb72/</url>
    <content><![CDATA[<blockquote>
<p>针对高性能MySQL，前三篇的Schema设计，索引设计和查询优化是基础，这一章算是提升项，高级特性在三大基础上能够更好的优化应用性能。</p>
<p>由于自己缺乏足够的项目经验，因此本章知识可能理解得不够， 希望之后有了相关项目，深入理解了MySQL的相关知识，回头再看这篇文章会有新的领悟和补充。</p>
</blockquote>
<span id="more"></span>

<p>MySQL从5.0和5.1版本之后开始引入了很多高级特性，例如分区、触发器等，本章就来简单介绍下。</p>
<h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>​    对于用户来说，<strong>分区表是一个独立的逻辑表，但是底层有多个物理子表组成。实现分区的代码实际上是对一组底层表的句柄对象的封装。对分区表的请求，都会通过句柄对象转化成对存储引擎的接口调用。</strong></p>
<p>​    因此分区对于SQL层来说就是一个装有底层实现的黑盒子，对应用层来说是透明的。</p>
<p>​    MySQL是通过对底层表的封装实现的分区表，这意味着<strong>索引也是按照分区的子表定义的，而没有全局索引。</strong></p>
<p>​    MySQL在创建表是使用<code>PARTITION BY</code>子句定义每个分区存放的数据。在执行查询的时候，优化器会根据分区定义过滤那些没有我们需要数据的分区，这样查询就无须扫描所有分区，而只需要查找包含需要数据的分区即可。</p>
<p>​    <strong>分区的一个主要目的是将数据按照一个较粗的粒度分在不同的表，这样做可以将相关的数据存放在一起，另外，如果想一次批量删除真个enquiry的数据也会变得很方便。</strong></p>
<p>​    分区一般应用于以下场景：</p>
<ul>
<li>表非常大以至于无法全部都放在内存中，或者之在表的最后部分有热点数据，其他均是历史数据。</li>
<li>分区表的数据更容易维护。想批量删除大量数据可以使用清除整个分区的方式。另外还可以对一个独立分区进行优化、检查、修复等操作。</li>
<li>分区表的数据可以分布在不同的物理设备上，从而能够高效利用多个设备。</li>
<li>如果需要的话，独立分区可以备份和恢复，这在非常大的数据集的场景下效果非常好。</li>
</ul>
<p>​    分区表本身的限制</p>
<ul>
<li>一个表最多只能有1024个分区。</li>
<li><strong>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引都必须包含进来。</strong></li>
<li>分区表中无法使用外键约束。</li>
</ul>
<h4 id="分区表的原理"><a href="#分区表的原理" class="headerlink" title="分区表的原理"></a>分区表的原理</h4><p>​    如前所述，分区表由多个底层表实现，这些底层表也是由句柄表表示，所以我们也可以直接访问各个分区。存储引擎管理分区的各个底层表和管理普通表一样（所有底层表都必须使用相同的存储引擎），<strong>分区表的索引只是在各个底层表上各自加上一个完全相同的索引</strong>。从存储引擎的角度来看，普通表和底层表并无差别，存储引擎也无须中断这是一个底层表还是普通表。</p>
<p>​    分区表操作逻辑如下：</p>
<ul>
<li>select操作：<strong>查询一个分区表时，分区层先打开并锁住所有底层表，优化器先判断是否可以过滤部分分区</strong>，然后再调用对应的存储引擎接口访问各个分区的数据。</li>
<li>insert操作：当写入一条记录时，分区层先打开并锁住所有底层表，确定哪个分区接收这条记录，再将记录写入对应底层表。</li>
<li>delete操作：当删除一条记录时，分区层先打开并锁住所有底层表，确定数据对应的分区，最后对相应底层进行删除操作。</li>
<li>update操作：当更新一条记录时，分区层先打开并锁住所有底层表，MySQL先确定需要更新的记录在哪个分区，然后取出数据并更新，在判断更新后的数据应该存放哪个分区，最后对底层表进行写入操作，并对原数据所在的底层进行写入操作，并对原数据所在的底层表进行删除操作。</li>
</ul>
<p>总结一下上面的操作逻辑，<strong>这些操作都是能够过滤的，如果定位到了指定分区，其他分区的信息可以不查，这样也提高了查询效率。</strong></p>
<p><strong>每个操作都会先打开并锁住所有底层表，但这并不是说分区过程中会锁定全表。如果存储引擎能够自己实现行级锁，例如InnoDB，则会在分区层释放表锁。这个加锁过程和普通InnoDB上的查询一样。</strong></p>
<h4 id="分区表的类型"><a href="#分区表的类型" class="headerlink" title="分区表的类型"></a>分区表的类型</h4><p>​    MySQL支持多种分区表。我们看到的是根据范围进行分区，每个分区存储落在某个范围的记录，分区表达式可以使列，也可以是包含列的表达式。一般这种分区叫做<strong>RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区。</strong></p>
<p><strong>RANGE分区也叫水平分区</strong>：这种形式分区是对表的行进行分区，通过这样的方式不同分组里面的物理列分割的数据集得以组合，从而进行个体分割（单分区）或集体分割（1个或多个分区）。所有在表中定义的列在每个数据集中都能找到，</p>
<p><strong>所以表的特性依然得以保持。</strong></p>
<p>例如，下表就可以将每一年的销售额存放在不同的分区里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE sales(</span><br><span class="line">	order_date DATETIME NOT NULL, </span><br><span class="line">	-- Other columns omitted</span><br><span class="line">)ENGINE = INNODB PARTITION BY RANGE(YEAR(order, date))(</span><br><span class="line">	PARTITION p_2010 VALUES LESS THAN (2010),</span><br><span class="line">    PARTITION p_2011 VALUES LESS THAN (2011),</span><br><span class="line">	PARTITION p_2012 VALUES LESS THAN (2012),</span><br><span class="line">    PARTITION p_catchall VALUES LESS THAN MAXVALUE,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>​    其他分区手段一般是支持列表，键值或者哈希分区。</p>
<p><strong>LIST分区</strong>是基于列值匹配一个离散值集合中的某个值来进行选择。<code>PARTITION BY LIST(expr)</code>，这是按照列分区，这种分区方式一般来说是通过对表的垂直划分来减少目标表的宽度，使某些特定的列被划分到特定的分区，每个分区都包含了其中的列所对应的行。</p>
<p>举个简单例子：<strong>一个包含了大text和BLOB列的表，这些text和BLOB列又不经常被访问，这时候就要把这些不经常使用的text和BLOB了划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。</strong></p>
<h4 id="如何使用分区表"><a href="#如何使用分区表" class="headerlink" title="如何使用分区表"></a>如何使用分区表</h4><p>​    一般来说分区表是在非常大的数据表中使用的（如果数据很少，直接全表扫描；如果数据相对多，那么建立索引是一个好方法，数据非常大，索引的维护和空间消耗也是很大的，这是因为B+树对于大数据无法起作用，会产生大量随机I/O）。</p>
<p>​    <strong>分区就是一个更粗粒度的但消耗更少的方式去检索数据，例如在大量数据上之以非常小代价就定位到正确的小区域。</strong>而分区因为精确性不高，因此也无须像索引一样使用数据结构，因为无需精确定位每条数据的位置。</p>
<p>​    一般来说使用分区表的方法有下面两种。</p>
<ul>
<li><p><strong>全量扫描数据，不要任何索引</strong>：可以使用简单的分区方式存放表，不要任何索引，根据分区的规则大致定位需要的数据位置。只要能够使用where条件，将需要的数据限制在少数分区中，效率很高。但是使用该策略没有缓存效应，<strong>只适用于以正常的方式访问大量数据的时候</strong>。而且分区数量不能太大，因为没有索引，分区数量大的话效率会降低。</p>
</li>
<li><p><strong>索引数据，并分离热点</strong>：如果数据有明显的“热点”，而且除了这部分数据，其他数据很少被访问到，<strong>那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据能够有机会都缓存在内存中。在热点分区还能够使用索引来加快速度。</strong></p>
</li>
</ul>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>​    引入分区给查询优化带来了一些新的思路。<strong>分区最大的优点就是优化器可以根据分区函数来过滤一些分区，根据粗粒度索引的优势，通过分区过滤通常可以让查询扫描更少的数据。</strong></p>
<p>​    <strong>因此在访问分区表时，很重要一点是要在WHERE条件中带入分区列，有时候即使看似多余的也要带上，这样就可以让优化器能够过滤掉无需访问的分区。</strong></p>
<p>最后分区表的子表都是被MySQL隐藏的，不能单独去访问，只能通过分区来访问。</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>​    （视图基本没用过，现在只是写下简单的书本知识）</p>
<p>​    <strong>视图本身是一个虚拟表，不存放任何数据。它返回的数据是MySQL从其他表中生成的。视图和表是在同一个命名空间，大部分情况下都能同等看待，但是视图不能使用触发器，也不能使用DROP TABLE命令删除视图。</strong></p>
<p>视图创建方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view Oceania AS</span><br><span class="line">	select * from Country WHERE Continet = &#x27;Oceania&#x27;</span><br><span class="line">	with check option;</span><br></pre></td></tr></table></figure>

<p>​    <strong>视图有一种叫做可更新视图，这种视图是指可以通过更新这个视图来更新视图设计的相关表。</strong></p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>​    InnoDB是MySQL中唯一支持外键的内置存储引擎。<strong>使用外键是有成本的。比如外键通常都要求每次在修改数据时都在另外一张表中多执行一次查找操作。</strong></p>
<p>而且外键约束需要访问额外的表，这意味着需要额外的锁。这种在我们意料之外的锁可能会造成死锁，因此一般来说都是尽可能用其他手段代替外键。比如触发器等。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    本章主要是讲了讲分区表，附带介绍了下视图和外键约束的基本概念。如果之后对于MySQL更熟悉的话，可能会新记录一些有用的特性。</p>
<ul>
<li><p>分区表</p>
<p><strong>分区表是一个粗粒度的，简易的索引策略，适用于大数据量的过滤场景</strong>。</p>
</li>
<li><p>视图</p>
<p>针对好几个表的复杂查询，使用视图有时候会大大简化问题。<strong>当视图使用临时表时，无法将WHERE条件下推导各个具体的表，也不能使用任何索引，需要特别注意这类的查询性能。当然如果只是为了便利，使用视图很合适</strong>。</p>
</li>
<li><p>外键</p>
<p>外键限制会将约束放到MySQL中，使用外键会带来额外的复杂性和额外的索引消耗，如果设计一个高性能系统，外键一般不被提倡使用</p>
</li>
<li><p>查询缓存</p>
<p>完全相同的查询在重复执行时，查询缓存可以立即返回结果，而无须在数据库中重新执行一次。</p>
<p>在高并发环境中查询缓存会导致系统性能的下降，甚至僵死。一般来说，只有明确收益的情况下才能开查询缓存，而且要注意到缓存命中率。</p>
<p>查询缓存是个非常方便的缓存，对应用程序完全透明，无须任何额外的编码。但是如果希望有更高的缓存效率，我们建议使用Redis当做缓存服务器。</p>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《高性能MySQL》</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>高级特性</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL查询性能优化</title>
    <url>/posts/42812f47/</url>
    <content><![CDATA[<blockquote>
<p>上篇文章讲了讲MySQL中的索引。索引的发明本质上是优化查询的一种手段。本篇文章就来直接来讲讲MySQL是如何对查询进行性能优化。</p>
</blockquote>
<span id="more"></span>

<p>​    针对设计一个高性能MySQL来说，<strong>查询优化、索引优化、库表结构</strong>优化三者都得有。本章的目标是帮助大家更深刻地理解MySQL如何真正地执行查询，并明白高效和低效的原因所在。发挥MySQL的优势、</p>
<h3 id="查询速度为何会慢"><a href="#查询速度为何会慢" class="headerlink" title="查询速度为何会慢"></a>查询速度为何会慢</h3><p>​    编写一个快速的查询的重点是响应时间。如果把查询看做是一个任务，这个任务中会有很多子任务，查询优化就是要将这些子任务进行优化。</p>
<p>​    要想了解查询为何会这么慢，首先得了解查询的生命周期：</p>
<ul>
<li>客户端发送命令    （查询起始点）</li>
<li>服务器接收命令    （<strong>网络因素</strong>）</li>
<li>服务器解析命令    （<strong>CPU 计算能力因素</strong>）</li>
<li>生成执行计划</li>
<li><strong>执行</strong>                         <strong>（对存储引擎的API的调用）</strong></li>
<li>将结果返回客户端   （查询终止点）</li>
</ul>
<p>​    <strong>执行是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序分组等。</strong>尤其是向存储引擎检索数据的调用操作，<strong>这些调用需要在内存操作、CPU操作和内存不足时导致的I/O操作上消耗时间。根据存储引擎的不同，可能还会产生大量的上下文切换以及系统调用。</strong></p>
<p>​    总结来说，存储引擎的API调用是最值得去优化的，但是其他因素也需要考虑，我们需要的是去减少和消除一些不必要操作的花费时间，来提高查询速度。</p>
<h3 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h3><p>​    <strong>查询性能低下最基本的原因是访问的数据太多。</strong>大部分性能低下的查询都可以通过减少访问的数据量的方式进入优化。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效。</p>
<ul>
<li>确定应用程序是否在检索大量超过需要的数据。</li>
<li>确定MySQL<strong>服务器层是否在分析大量超过需要的数据行</strong>。</li>
</ul>
<h4 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h4><p>​    客户端向服务器的查询是否是需要实际的需求数据，因为有些查询会请求超过实际需求的数据，然后这些多余数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU和内存资源。</p>
<p>​    这里有些典型案例：</p>
<ul>
<li>查询不需要的记录：只要10条却查询100条，虽然页面也只是显示10条，其实如果用LIMIT就可以解决。</li>
<li>多表关联时返回全部列：这个尽量明确只SELECT取出的列。</li>
<li>总是取出全部列：<strong>别用SELECT*，代价很大</strong></li>
<li>重复查询相同的数据： 这个的话可以使用缓存，这样二次查询相同数据就会很快。</li>
</ul>
<h4 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h4><p>对于MySQL，最简单的衡量查询开销的三个指标如下：</p>
<ul>
<li>响应时间</li>
<li>扫描的行数</li>
<li>返回的行数</li>
</ul>
<p>这三个指标都会记录到MySQL的慢日志中，所以<strong>检查慢日志记录是找出扫描行数过多的查询的好办法。</strong></p>
<ul>
<li><p>响应时间分为排队时间和服务时间，这个由于实际情况复杂很难判断，只能用一个参考值。</p>
</li>
<li><p>扫描行数和返回行数：<strong>理想情况下二者应该相同，但是一般不可能。我们希望能控制在1:1到10:1之间。</strong></p>
</li>
<li><p>扫描行数和访问类型：直接从表中找到某一行数据的成本比较大，MySQL有几种访问方式能够查找并返回一行结果。</p>
<p>访问类型一般有全表扫描，索引扫描，范围扫描等。一般没有合适的访问类型，那么解决的最好办法是加个合适的索引。</p>
<p>一般来说MySQL能够用三种方法来应用WHERE条件，从好到坏依次为：</p>
<ol>
<li><strong>在索引中使用WHERE条件来过滤不匹配的记录。 这是在存储引擎层完成的</strong>。</li>
<li><strong>使用索引覆盖扫描（在EXTRA列中出现了Using Index）来返回记录</strong>，直接从索引中过滤不需要的记录并返回命中的结果。这是MySQL服务器完成的，不需要回表查询。</li>
<li>从数据表中返回数据，过滤不满足条件的记录（在EXTRA列中出现了Using Where）。服务器层完成，而且要回表查询。</li>
</ol>
<p>如何优化？</p>
<ol>
<li>使用索引覆盖扫描，把<strong>所有需要的列放入索引中</strong>，这样就不需要回表。</li>
<li>改变库表结构。</li>
<li>重写复杂的查询，让MySQL优化器更优化执行该查询。</li>
</ol>
</li>
</ul>
<h3 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h3><p>​    在优化有问题的查询时，目标应该是找到一个更优的方法获得实际需要的结果。有时候，可以将查询转换一种写法让其返回一样的结果，但其性能更好。</p>
<p>​    这一节我们将介绍如何通过这种方式来重构查询，并展示何时需要使用这样的技巧。</p>
<h4 id="一个复杂查询还是多个简单查询"><a href="#一个复杂查询还是多个简单查询" class="headerlink" title="一个复杂查询还是多个简单查询"></a>一个复杂查询还是多个简单查询</h4><p>​    一般来说，在传统的网络通信服务器中，使用多个查询会浪费服务器的连接资源，但是由于MySQL设计让连接的建立和销毁都很轻量级，网络带宽也很大，因此在网络上多个小查询和单个查询差别不是那么大。</p>
<p>​    因此针对是单个复杂查询还是多个简单查询，主要还是看查询语句在服务器层和引擎层的花销，如果多个简单查询这些花销更小的话，那就可以使用多个简单查询。</p>
<p>​    当然，在其他条件差不多的时候，单个查询肯定是优于多个查询的。</p>
<h4 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h4><p>​    <strong>有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次也只返回一部分数据。</strong></p>
<p>​    举个例子，一次删除100万条数据服务器压力会很大，但是一次删除一万条数据，分十次删除，这样能够减少服务器压力。 </p>
<h4 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h4><p>​    SQL最强大的功能之一就是在数据检索查询的执行中关联（join）表。不过，关联表是一个非常耗费资源的操作，而且关联的表越多，那查询性能下降得越厉害。</p>
<p>​    很多高性能应用都会对关联查询进行分解。简单地，可以对每个表进行一次单表查询，然后将结果在应用程序中进行关联。</p>
<p>​    下面我们举个例子</p>
<p>关联查询是由JOIN组成的查询。举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; 	SELECT * FROM tag</span><br><span class="line">		JOIN tag_post ON tag_post.tag_id = tag.id</span><br><span class="line">		JOIN post ON tag_post.tag_id = post.id</span><br><span class="line">	WHERE tag.tag = &#x27;mysql&#x27;;</span><br><span class="line"></span><br><span class="line"># 分解查询</span><br><span class="line"></span><br><span class="line">&gt;	SELECT * FROM tag where tag=&#x27;mysql&#x27;;</span><br><span class="line">&gt; 	SELECT * FROM tag_post where tag_id = 1234;</span><br><span class="line">&gt;	SELECT * FROM post where post.id in (123, 456, 567, 9098,8904);</span><br></pre></td></tr></table></figure>

<p>分解查询的优势：</p>
<ul>
<li><strong>让缓存效率更高</strong>。许多应用程序都可以方便缓存单表查询对应的结果对象。例如，上面查询中的tag被缓存了，那么应用就可以跳过第一个查询。</li>
<li>将查询分解后，执行单个查询时能够减少锁的竞争。</li>
<li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。</li>
<li><strong>查询本身效率也可能会有所提升。</strong>该例子中第三个查询使用了IN代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联要更高效。之后会详细介绍。</li>
<li><strong>可以减少冗余记录的查询</strong>。</li>
</ul>
<h3 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h3><p>​    当希望MySQL能够以更高的性能运行查询时，最好的办法就是弄清楚MySQL是如何优化和执行查询的。</p>
<p>下图就是查询执行路径</p>
<img src="/posts/42812f47/%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%B7%AF%E5%BE%84.jpg" class title="查询执行路径">

<ol>
<li>客户端发送一条查询给服务器。</li>
<li><strong>服务器先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的记过。否则进入下一阶段。</strong></li>
<li><strong>服务器进行SQL解析，预处理，再由优化器生成对应的执行计划。</strong></li>
<li>MySQL根据优化器生成的<strong>执行计划</strong>，<strong>调用存储引擎的API来执行查询</strong>。</li>
<li>将结果返回给客户端。</li>
</ol>
<h4 id="MySQL网络通信协议"><a href="#MySQL网络通信协议" class="headerlink" title="MySQL网络通信协议"></a>MySQL网络通信协议</h4><p>​    MySQL网络通信协议是<strong>半双工通信协议</strong>。这意味着只能由一端发送数据给另外一端，不能够同时发送数据。这就要控制发送数据的量。这个是查询执行的第一步</p>
<p>​    服务器返回给客户端的数据客户端必须全部接收，而且在查询完成后才能释放资源。</p>
<p>一般来说在查询时候有着以下的状态</p>
<ul>
<li><p>sleep：线程正在等待客户端发送新的请求</p>
</li>
<li><p>query：线程正在执行查询或者正在将结果发送给客户端</p>
</li>
<li><p>locked：在MySQL服务器层，该线程正在等待表锁</p>
<p>…</p>
</li>
</ul>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>​    查询缓存是查询执行的第一步。如果查询缓存打开，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。如果命中查询缓存。那么直接从缓存中获得结果，不需要去解析SQL语句。（这个和所有的缓存都一样，但是这个查询缓存里面存放的是语句，<strong>因为这个时候完全没有解析SQL，所以存的也是sql语句</strong>）</p>
<p>​    <strong>不过查询缓存的检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使有一个字节不同，也不会匹配结果。</strong></p>
<p>​    在查询缓存中命中的数据，那么检查完用户权限合格后直接跳过之后所有操作返回结果。</p>
<h4 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h4><p>​    第三个阶段就是最重要的查询优化阶段了。该阶段将一个SQL转换成一个执行计划。这包括多个子阶段： 解析SQL，预处理，优化SQL执行计划。</p>
<ul>
<li><p>语法解析器和预处理：</p>
<p>MySQL通过关键字将SQL语句进行解析，并生成一个对应的“<strong>解析树”</strong>。MySQL解析器将使用MySQL语法规则验证和解析查询。<strong>预处理器会进一步检查是否合法，并且验证用户权限</strong>。（其实就是验证这个解析树的合法性）</p>
</li>
<li><p>查询优化器：</p>
<p><strong>当该语句是合法的，那么查询优化器的作用就是找到其中最好的执行计划。（优化器是基于成本的，会选取预测成本最低的一种方法。）</strong></p>
<p>查询优化器很复杂，一般用了两种优化策略：<strong>静态优化和动态优化</strong>。</p>
<p>静态优化是对解析树直接进行分析，并完成优化。（编译时优化）</p>
<p>动态优化和查询上下文等因素有关，每次查询都要重新评估。（运行时优化）</p>
</li>
<li><p>关联查询的优化</p>
<p><strong>迭代使用嵌套循环</strong>，<strong>选择代价最小的关联顺序</strong>。</p>
<p>因为mysql的关联查询不是平衡二叉树，而是左侧深度优先树。这样的话如果先查询代价较大的表会让整个效率都变低。因此首先查询代价较小的表，这样会生成一颗成本最小的关联树。</p>
</li>
<li><p>排序优化</p>
<p><strong>排序是一个成本很高的操作，我们要避免使用。</strong>（如果要有排序操作尽量使用索引）</p>
<p>如果使用的话，这里也有个排序优化，即<strong>先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。</strong></p>
</li>
</ul>
<h4 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h4><p>​    在查询优化阶段，MySQL生成查询对应的执行计划，MySQL的查询执行引擎则根据这个执行计划来完成整个查询。</p>
<p>​    查询执行阶段并不复杂，只是据执行计划给出的指令逐步执行。执行过程中会使用到很多针对存储引擎接口实现的调用。</p>
<h4 id="返回结果客户端"><a href="#返回结果客户端" class="headerlink" title="返回结果客户端"></a>返回结果客户端</h4><p>​    <strong>先将查询结果返回到查询缓存中。</strong></p>
<p>​    <strong>MySQL将结果集增量、逐步返回给客户端，即生成第一条结果就开始返回结果。</strong></p>
<ul>
<li><p><strong>服务器不需要存储太多结果，这样减少内存消耗。</strong></p>
</li>
<li><p><strong>客户端也在第一时间得到返回的结果数据。</strong></p>
</li>
</ul>
<p>​    （这里要注意的是结果是增量且逐步的返回给客户端）</p>
<p>其实这一节的内容信息量很大，相当于是经历了一个命令发送到接收结果的整个流程。在这过程中最重要的肯定是<strong>如何进行查询优化处理</strong>。</p>
<h4 id="查询优化器的局限性"><a href="#查询优化器的局限性" class="headerlink" title="查询优化器的局限性"></a>查询优化器的局限性</h4><p>​    MySQL的万能“嵌套循环”并不是对每种查询都是最优的。但是对大部分查询都能最优解，只对少部分查询不适用。下面就是一些查询优化未能解决的一些场景。</p>
<ul>
<li><p>关联子查询</p>
<p><strong>当这个子查询内部的查询和外部表相关联的时候，MySQL会将相关的外层表压到子查询中，它认为这样可以更加高效。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt;	select * from sakila.film</span><br><span class="line">	-&gt;  where film_id IN (</span><br><span class="line">	-&gt;		select film_id from sakila.film_actor where actor_id = 1);</span><br><span class="line">	</span><br><span class="line"># 会“优化”成下面代码</span><br><span class="line">mysql&gt;	select * from sakila.film</span><br><span class="line">	-&gt;	where exists ( </span><br><span class="line">    -&gt;    select * from sakila.film_actor where actor_id = 1</span><br><span class="line">    -&gt;	  AND file_actor.film_id = film.film_id );</span><br></pre></td></tr></table></figure>

<p>上面的代码将<strong>外表film也放到了子查询中，这样不好，因为如果外层表是个非常大的表，那么效率会非常糟糕。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; 	select film.* from sakila.film</span><br><span class="line">	-&gt; 		inner join sakila.film_actor using(film_id)</span><br><span class="line">	-&gt; 		where actor_id = 1;</span><br></pre></td></tr></table></figure>

<p>但是不是所有的关联子查询效率都会差，这个要自己测试，然后判断。</p>
</li>
<li><p>UNION的限制</p>
<p><strong>UNION是将两个表的记录联合起来放入一个临时表中，如果没有对两个表分别加上limit的限制的话，那么导入的是全表</strong>，如果是将两个表排序选出前20，那么最好先分别在两个表中选出前20，再union，再从这40条中选出前20,这样会极大的减少构建临时表的负担。</p>
</li>
<li><p>索引合并优化</p>
<p>前面讨论过了，<strong>MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。</strong></p>
</li>
<li><p>等值传递</p>
<p>等值传递会带来一些意料之外的额外消耗。</p>
</li>
<li><p>并行执行</p>
<p>MySQL做不到。</p>
<p>….</p>
</li>
</ul>
<h3 id="优化特定的查询"><a href="#优化特定的查询" class="headerlink" title="优化特定的查询"></a>优化特定的查询</h3><p>​    本节所介绍的多数优化技巧都和特定的版本有关。</p>
<h4 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT()查询"></a>优化COUNT()查询</h4><p>这个函数是一个特殊的函数。他有两个作用</p>
<ul>
<li><p>可以统计某个列值的数量，这个作用下列值不能为空。如果括号内的表达式指定了列，那么就是这个功能。</p>
</li>
<li><p>可以统计结果集的行数。 当count的括号内的表达式值不可能为空时，实际上就是在统计行数。</p>
<p>所以，对于<strong>count(*)，不会扩展所有的列，而是忽略所有列直接返回总行数。</strong></p>
</li>
</ul>
<p>总之，count是一个统计行数或者列值的函数，一般要扫描大量数据，这种情况下必须对其进行优化，如索引覆盖。但是针对count（*）是个特例。</p>
<h4 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h4><p>关联查询这个问题整本书都在讨论。以下有一些优化规则</p>
<ul>
<li><strong>确保ON或者USING子句中的列上有索引。</strong></li>
<li><strong>确保<code>group by</code> 和 <code>order by</code>中表达式只涉及到一列。这样容易使用索引优化</strong>。</li>
</ul>
<h4 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h4><p><strong>尽可能使用关联查询代替子查询。</strong></p>
<h4 id="优化GROUP-BY和DISTINCT"><a href="#优化GROUP-BY和DISTINCT" class="headerlink" title="优化GROUP BY和DISTINCT"></a>优化GROUP BY和DISTINCT</h4><p>​    一般来说MySQL都使用同样的方法优化这两种这两种方法都是有索引的话，就用索引优化，<strong>索引是最有效的优化办法。</strong></p>
<p>​    当无法使用索引的时候，那么一般都会产生一个临时表来执行这两个操作。不过这样的话明显不是很高效。</p>
<h4 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h4><p>如果是<code>limit 10000,10</code>那么会先返回10010条数据，然后取最后10条，这样的话效率也很低。</p>
<p>这里最简单的办法是尽可能使用<strong>索引覆盖扫描</strong>，而不是查询所有的列。然后根据需要做<strong>一次关联操作再返回所需的列。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt;	select film_id, description from sakila.film order by title limit 50, 5;</span><br></pre></td></tr></table></figure>

<p>利用上面的方式优化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用film_id索引，先进行一次关联操作，在关联操作中返回所需要的55行数据，然后再返回所需要的列。</span><br><span class="line">mysql&gt;	select film.film_id, film_description</span><br><span class="line">			from sakila.film</span><br><span class="line">				inner join(</span><br><span class="line">                	select film_id from sakila.film</span><br><span class="line">                	order by title limit 50, 5</span><br><span class="line">                ) AS lim using(film_id)</span><br></pre></td></tr></table></figure>



<ul>
<li>其他优化：这些优化在使用中都是很有用的，以后可以当字典看。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本篇文章的内容很多，因为对实际操作数据库经验不足，只能流于表面的讲讲。在我看来，首先要掌握查询执行的过程（在此过程中能够意识到执行时间都消耗在哪），然后要意识到索引优化对查询的重要性。之后呢，就该了解查询优化器的工作原理。最后了解一下常见关键字的优化。</p>
<p>​    最后，schema设计，索引设计和查询语句设计之外，查询优化是设计高性能MySQL的最后一步。<strong>优化通常要三管齐下：不做、少做、快速地做。</strong></p>
<p>​    之后的文章可能就是一些MySQL的高级特性了，比如分区分表之类的，留给下一篇文章讲。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《高性能MySQL》</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>查询优化</tag>
        <tag>慢查询</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/posts/43a71ae4/</url>
    <content><![CDATA[<blockquote>
<p>索引（在MySQL中也叫作键（key））是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能，除此之外，索引其他一些方面有用的属性也会在本篇文章中讲到。</p>
</blockquote>
<span id="more"></span>

<p>​    索引是良好的的性能非常关键，尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。一个合适的索引设计一般对于大量数据查询时，会有极大的性能提升。</p>
<p>​    索引优化应该是对查询性能优化最有效的手段。索引能够轻易将查询性能提高几个数量级，创建一个好的索引一般也要重写查询语句。因此本章和下一章的查询优化关系非常紧密。</p>
<p>​    <strong>索引的本质是一种数据结构</strong></p>
<h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><p>​    索引的工作方式和书的目录有点像，都是先在索引部分找到对应值，然后根据匹配的索引记录找到对应的数据行。</p>
<p>​    换句话说，<strong>MySQL先在索引上按值进行查找，然后返回所有包含该值的数据行</strong>。</p>
<p>​    索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要。</p>
<p>​    索引有多种类型，可以为不同的场景提供更好的性能。在MySQL中，索引是在引擎层而不是服务器层实现的，因此索引和存储引擎有关，不同存储引擎的索引工作方式不同。</p>
<p>下面就来介绍一下MySQL支持的索引类型，以及它们的优缺点。</p>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>​    这个是索引的主要类型。底层为B+树数据结构。</p>
<h5 id="B-树结构"><a href="#B-树结构" class="headerlink" title="B+树结构"></a><strong>B+树结构</strong></h5><p>​    首先我们来简单介绍下B+树</p>
<img src="/posts/43a71ae4/B%E6%A0%91%E4%BB%8B%E7%BB%8D.png" class title="B+树介绍">

<p>​    不过B+树的插入和删除操作会导致其结构发生变化，但是永远会保持平衡，而且根节点到叶子节点的距离永远相同。<strong>这样为了保持平衡对于新插入的键值可能需要做大量的拆分页操作</strong>。因为B+树结构主要用于磁盘，页的拆分意味着磁盘的操作，所以应该在可能的情况下减少页的拆分，因此B+树也有类似于AVL树的旋转操作，以减少页拆分的次数。</p>
<p><strong>从上可以看出B+树存储的所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。</strong></p>
<p>B+树索引的本质就是B+树在数据库中的实现。一般数据库中的实现的B树都是2<del>4层，这样一来具有<strong>高扇出性</strong>，查找某一键值的行记录最多只需要2</del>4次。对于一般机械键盘也只需0.02~0.04s。</p>
<h5 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a><strong>聚簇索引和非聚簇索引</strong></h5><p>​    B+树索引可以分为<strong>聚簇索引和非聚簇索引</strong>，不管是聚集索引还是辅助索引，内部都是B+树，即高度平衡的，叶子节点存放所有的数据。但是二者有着以下的差别</p>
<p>​    B+树是左小右大的顺序存储结构，节点只包含id索引列，而叶子节点包含索引列和数据，<strong>这种数据和索引在一起存储的索引方式叫做聚簇索引</strong>，<strong>一张表只能有一个聚簇索引。假设没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有的话则会隐式定义一个主键作为聚簇索引</strong>。</p>
<p>​    <img src="/posts/43a71ae4/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" class title="聚簇索引"></p>
<p>​    上图主键聚簇索引存储的结构，那么非聚簇索引的结构是什么样子呢？<strong>非聚簇索引(二级索引)叶子节点保存的不是数据，而是主键id值</strong>，这一点和myisam保存的是数据地址是不同的。 <strong>非聚簇索引通过先查询到该数据的主键id值后，再通过主键id值去查找该表中唯一的聚簇索引，通过聚簇索引得到真正的数据</strong>，这个也是被称作二级索引的原因， 因为它查完还得查聚簇。</p>
<p>​    <img src="/posts/43a71ae4/%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" class title="非聚簇索引"></p>
<p>​    最终，我们一张图可以看看InnoDB和Myisam聚簇和非聚簇索引的区别</p>
<p>​    <img src="/posts/43a71ae4/%E5%8C%BA%E5%88%AB.png" class title="区别"></p>
<p>​    <strong>上图可以看出InnoDB的叶子扇区存放的整行数据，而MyISAM存放的是指向行数据的指针。</strong></p>
<h5 id="二者的优缺点"><a href="#二者的优缺点" class="headerlink" title="二者的优缺点"></a><strong>二者的优缺点</strong></h5><p>​    <strong>聚簇索引的优点在于对于使用主键的排序查找和范围查找速度非常快，因为叶子节点的数据就是用户徐亚查询所要的数据。</strong></p>
<p>​    范围查找是因为可以通过叶子节点的上层中间节点得到页的范围，之后直接读取数据页即可。</p>
<p>​    非聚簇索引的优点是可以有多个，并不影响数据在聚集索引上中的组织，只是一个辅助手段。</p>
<h5 id="B-树索引的特点"><a href="#B-树索引的特点" class="headerlink" title="B+树索引的特点"></a>B+树索引的特点</h5><p>​    B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取数据，而是从<strong>索引的根节点开始搜索</strong>。由于索引列是按顺序存储的，所以很适合<strong>查找范围数据</strong>。</p>
<p>​    因此B-Tree索引适用于<strong>全键值，键值范围或键前缀查找</strong>。键前缀查找只适用于根据最左前缀的查找。</p>
<ul>
<li><p><strong>全键值指的是一整行数据。B树索引能够查找一整行存储的数据。</strong></p>
</li>
<li><p><strong>其键值范围或键前缀查找都是因为B树是从索引的第一列开始查询</strong>（假设索引有ABC三列，只能这样使用索引：部分A当做索引，或者全部A，全部A部分B，全部A全部B，全部A全部B部分C，全部A全部B全部C）</p>
<p>这种模式的索引是典型的最左值前缀查找</p>
</li>
</ul>
<p>总而言之B+树索引的优点</p>
<ul>
<li>顺序存储</li>
<li>访问的次数是从根节点到叶节点，而B+树一般只有2~4层，因此查询的时间短且固定。</li>
<li>支持全键值，剑指范围或键前缀查找</li>
</ul>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>​    哈希索引是基于<strong>哈希表</strong>来实现的（这个和hashmap类似，索引就是hashmap的key），<strong>只有精确匹配索引所有列的查询才有效。</strong>对于每一行数据，存储引擎都会对所有的索引列计算出一个哈希码(hash code)，哈希码是一个较小的值，并且不同剑指的行计算出来的哈希码都不一样。</p>
<p>​    <strong>哈希索引将所有的哈希码存储在索引中，同时哈希表中保存指向每个数据行的指针。</strong></p>
<p>​    哈希索引只有Memory引擎显式支持。这也是该引擎的默认索引类型。</p>
<p>哈希索引优点：</p>
<ul>
<li>索引自身只需要存储对应的哈希值，所以索引结构非常紧凑</li>
<li>通过hash查找，哈希索引的速度非常快</li>
</ul>
<p>哈希索引缺点：</p>
<ul>
<li><p>索引内只包含哈希值和行指针，不存储字段，不能通过索引中的值来避免读取行。</p>
</li>
<li><p>哈希索引数据并不是按照索引值顺序存储的，所以也就<strong>无法用于排序</strong>。</p>
</li>
<li><p>哈希索引不支持部分<strong>范围索引</strong>，这是因为一个完整的哈希索引才对应一个哈希码。</p>
</li>
<li><p>只支持等值查询，因为哈希是命中的（true or false），<strong>不支持范围查询</strong>。</p>
</li>
<li><p>由于本质是哈希算法，所以会造成哈希冲突，如果造成哈希冲突会使查询效率降低。</p>
</li>
<li><p>如果哈希冲突很多，那么索引的维护操作也很高。</p>
</li>
</ul>
<p>哈希索引的优点和缺点都是因为其基于哈希算法而实现的。因此其适用性场景可能会不够多，但是在它使用的领域效率还是非常可观的。</p>
<h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul>
<li><strong>索引能够让服务器快速定位到表的指定位置（基本优点）</strong></li>
</ul>
<p>总结下就是三大优点</p>
<ul>
<li><strong>索引大大减少了服务器需要扫描的数据量</strong></li>
<li><strong>索引可以帮助服务器避免排序和临时表</strong></li>
<li><strong>索引可以将随机I/O变为顺序I/O</strong></li>
</ul>
<p>后两条其实是B+树索引的优点。</p>
<p>不过值得注意的是，索引的本质也是为了优化查询效率，只有该索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。</p>
<ul>
<li>表如果是很小的话，那么全表扫描应该会更好</li>
<li>表如果是中到大型的话，那么索引会非常</li>
<li>表如果非常大的话，那么索引的代价就很大了，这个时候可以考虑分表。</li>
</ul>
<h3 id="高性能索引的策略"><a href="#高性能索引的策略" class="headerlink" title="高性能索引的策略"></a>高性能索引的策略</h3><p>​    正确创建和使用索引是实现高性能查询的基础。前面已经讲了各种类型的索引及其对应的优缺点。现在我们来看看如何真正发挥这些索引的优势。</p>
<h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>​    如果列不是独立的话，那么MySQL就不会使用索引。<strong>独立的列指的是索引列不能是表达式的一部分，也不能是函数的参数。</strong></p>
<p>​    举个例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select actor_id from sakila.actor where actor_id + 1 = 5;</span><br></pre></td></tr></table></figure>

<p>​    这里由于where后面的表达式有索引列，虽然这个表达式很简单，但是在语法解析树中是无法优化的，因此这个式子无法运用索引。</p>
<p>​    这里我们需要做的是养<strong>成简化WHERE条件的习惯，始终将索引单独放在比较符号的一侧</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select actor_id from sakila.actor where actor_id = 4;</span><br></pre></td></tr></table></figure>

<h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>​    如果一个索引的字符串太长，让索引列变得大且慢怎么办？一个策略是前面的模拟哈希索引。但是哈希索引也有其缺点，这里的话可以用到<strong>前缀索引：将索引开始的部分字符</strong>。</p>
<ul>
<li>优点： 大大节约索引空间，从而提高索引效率</li>
<li>缺点： 降低了索引选择性</li>
</ul>
<p>索引选择性指的是<strong>不重复的索引值（基数）和数据表记录总数的比值</strong>，选择性高的索引可以让MySQL在查找是过滤掉更多的行。<strong>唯一索引的选择性是1，性能最好。</strong></p>
<p>​    因此本节的内容就清晰了，如果在索引字符串太大的时候，一般使用前缀索引来节约索引空间，从而提高索引效率，但是这样势必会降低索引选择性，导致索引的性能降低。这样的话，如何平衡前缀索引的提升效率和索引选择性降低导致的索引性能降低？ ——<strong>答案是选择合适的前缀索引长度</strong>。</p>
<p>​    其诀窍在于要选择足够长的前缀以保证较高的选择性，但同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。换句话说<strong>前缀列的基数最好要接近于完整列的基数。</strong>    </p>
<p>​    另一个办法是直接计算前缀索引的选择性，如果再增加的话，选择性提高幅度很小，那么就使用该前缀长度。</p>
<h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>​    首先，在多个列建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。</p>
<p>​    多列索引指的是该索引里面有多个列。一般来说当服务器对多个索引做相交操作时（通常有多个AND条件），通常要使用多列索引。</p>
<p>​    既然是多列，如何用合适的顺序创建多列索引？<strong>将选择性最高的列放到索引最前列。</strong></p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>​    这个在之前B+树索引中已经介绍过了，当表有聚簇索引时，<strong>它的数据行实际上存放在索引的叶子页中</strong>，<strong>一个表只有一个聚簇索引。这个索引称之为聚簇主键。</strong></p>
<p>这里主要用来完善说明下该索引的优缺点。</p>
<p>聚集数据的优缺点：</p>
<p>优点：</p>
<ul>
<li>可以将相关数据保存在一起，对于磁盘I/O效率有提升。</li>
<li>数据访问更快。这是因为聚簇索引将<strong>索引和数据都保存在同一个B-Tree中</strong>。</li>
<li>使用覆盖索引扫描的查询可以直接用<strong>叶节点中的主键值</strong>。</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>虽然提高了磁盘I/O效率，但是如果数据全部放在内存中的话，那这就没有什么优势了。</p>
</li>
<li><p>插入顺序严重依赖于插入顺序。</p>
</li>
<li><p>更新聚簇索引列的代价很高</p>
</li>
<li><p>聚簇索引可能会导致全表扫描变慢。</p>
</li>
<li><p>…</p>
</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>​    <strong>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们称之为“覆盖索引”</strong>。如果索引叶子节点包括需要差点值，那么就不需要回表查询，这样会大大提高查询效率。</p>
<p>​    这个覆盖索引是指索引必须覆盖这些查询的全部列，不然还是得回表查询。</p>
<p>​    <strong>而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。</strong></p>
<p>​    其实就是如果需要回表查询，效率会低很多。如果索引中的叶子结点就有数据的话是很高效的。</p>
<p>​    覆盖索引带来的好处</p>
<ul>
<li>索引条目通常远小于数据行大小，<strong>这样会极大地减少数据访问量</strong>（因为查索引就能看到）。</li>
<li>因为索引是按值顺序存储的，那么对于I/O密集型的范围查询会比随机从磁盘中读取每行数据的I/O小的多。<strong>减少I/O操作。</strong></li>
</ul>
<h4 id="压缩索引"><a href="#压缩索引" class="headerlink" title="压缩索引"></a>压缩索引</h4><p>​    MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这样也能极大地提高性能。<strong>压缩块同样也是一个节约空间而会将操作变慢的一种方法。</strong></p>
<h4 id="重复和冗余索引"><a href="#重复和冗余索引" class="headerlink" title="重复和冗余索引"></a>重复和冗余索引</h4><p>​    索引也是一个数据结构，如果有重复或者冗余的索引，一般情况下都直接丢弃。记得定期清理那些不用的索引。</p>
<h4 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h4><p>​    索引可以让查询锁定更少的行。因为这类查询从不访问那些不需要的行，这样就会锁定更少的行。<strong>因此多使用索引反而还能减少锁的开销。</strong></p>
<p>​    InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。</p>
<p>一个小tips：</p>
<p>​    <strong>InnoDB在二级索引上使用共享锁，但访问主键索引需要排它锁。这消除了覆盖索引的可能性。</strong></p>
<p>（这里不好理解啊）？？？？</p>
<p>这里先贴个连接</p>
<p><a href="https://zhuanlan.zhihu.com/p/40396971">https://zhuanlan.zhihu.com/p/40396971</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本章是MySQL中的超级重点章节。上面的描述应该算是比较清楚 。<strong>只需要知道索引是查询优化的一种手段，是一种数据结构，这种数据结构默认为B+树，有时可以为哈希表。</strong></p>
<p>​    然后分别分析B+索引和哈希索引的特点</p>
<p>​    分析完之后再来根据具体情况分析该用什么索引。</p>
<p>​    最后的话题是索引和锁，这个算是难点，希望自己能够掌握。</p>
<p>参考资料</p>
<ul>
<li>《高性能MySQL》</li>
<li><a href="https://zhuanlan.zhihu.com/p/40396971">https://zhuanlan.zhihu.com/p/40396971</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O模型</title>
    <url>/posts/49316947/</url>
    <content><![CDATA[<blockquote>
<p>在LINUX/UNIX下，有五种I/O操作方式：阻塞式I/O，非阻塞I/O，I/O多路复用，信号驱动式I/O，异步I/O。本文现在就开始对这五种模式进行简单的介绍。</p>
</blockquote>
<span id="more"></span>

<h3 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h3><p>​    阻塞式I/O模型是最普遍使用的I/O 模式。大部分程序使用的都是阻塞模式的I/O 。<strong>在默认情况下，所有套接字都是阻塞的。</strong></p>
<p>​    以UDP套接字为例，如果使用<code>recvfrom</code>系统调用去接收对方的数据报，会发生如图以下的情况。</p>
<img src="/posts/49316947/%E9%98%BB%E5%A1%9E%E5%BC%8F%E6%A8%A1%E5%9E%8B.jpg" class title="阻塞I&#x2F;O模型">

<ul>
<li>在调用<code>recvfrom</code>函数的时候，该进程（线程）会阻塞。</li>
<li>当对方发送数据报到主机中时，内核会接收数据报。</li>
<li>数据报内容会从内核缓冲区复制到用户缓冲区</li>
<li>复制完成，用户缓冲区成功接收到数据报后解除阻塞。</li>
</ul>
<p>因此可以知道，<strong>阻塞I/O模型下，<code>recvfrom</code>系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。</strong>换句话说，该进程在调用<code>recvfrom</code>开始到它返回的整个时间内都是被阻塞的。</p>
<h3 id="非阻塞是I-O"><a href="#非阻塞是I-O" class="headerlink" title="非阻塞是I/O"></a>非阻塞是I/O</h3><p>​    进程把一个套接字设置成非阻塞是在通知内核：<strong>当所请求的I/O操作非得把本进程置于休眠（阻塞）状态才能完成时，进程不会进入休眠状态，而会直接返回一个错误。</strong>     </p>
<p>​    <img src="/posts/49316947/%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B.jpg" class title="非阻塞式I&#x2F;O"></p>
<p>​    前三次调用<code>recvfrom</code>时没有数据可返回，因此内核转而立即返回一个<code>EWOULDBLOCK（期望阻塞）</code>或者是<code>EAGAIN（再来一次）</code>错误。第四次调用<code>recvfrom</code>时已有一个数据报准备好，它被复制到应用进程缓冲区，于是<code>recvfrom</code>成功返回。</p>
<p>​    当一个应用进程像这样对一个非阻塞描述符循环调用<code>recvfrom</code>时，我们称之为轮询。应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间。</p>
<p><strong>一个I/O操作是否是非阻塞的，取决于该I/O操作处理的套接字是否设置为非阻塞的。</strong></p>
<h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>​    <strong>I/O多路复用是使用select，poll或者是epoll等I/O复用函数来进行通知I/O操作是否到来</strong>。I/O复用是最常使用I/O通知机制。它指的是，应用进程通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的时间通知给应用进程。</p>
<p>​    值得注意的是，I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。</p>
<p>​    如下图所示</p>
<img src="/posts/49316947/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.jpg" class title="I&#x2F;O多路复用模型">

<p>​    有了I/O复用技术，进程就不再是阻塞在真正的I/O系统调用（如<code>recvfrom</code>）上，而是阻塞在I/O复用函数上（如select, poll, epoll_wait)。进程阻塞这三个调用上，等待数据报套接字变为可读。当select返回套接字可读这一条件，我们调用<code>recvfrom</code>把所读数据报复制到应用进程缓冲区中。</p>
<p>​    </p>
<p>​    <strong>I/O多路复用的优势在于多路，</strong>如果是单线程中的<code>recvfrom</code>和<code>select</code>，那确实没有优势，毕竟使用了两个系统调用，效率更低。但是如果是在多线程的条件下，那I/O多路复用的优势就体现出来了——可以在一个线程中使用select，然后再其他线程中都能够自由的调用<code>recvfrom</code>之类的阻塞式I/O。</p>
<h3 id="信号驱动式I-O"><a href="#信号驱动式I-O" class="headerlink" title="信号驱动式I/O"></a>信号驱动式I/O</h3><p>​    我们也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们。使用信号通知的方式叫做信号驱动式I/O。一般来说这种方法需要在用户进程中通过sigaction调用安装信号处理函数。<strong>当数据报准备好读取时，内核就为该进程产生一个SIGIO信号</strong>。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。</p>
<p>​    如下图所示</p>
<img src="/posts/49316947/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B.jpg" class title="信号驱动I&#x2F;O模型">

<p>​    无论如何处理SIGIO信号，这种模型的优势在于<strong>等待数据报到达期间进程不被阻塞</strong>。主循环可以继续执行，只要等待来自信号处理函数的通知。</p>
<p>​    最后，理论上来讲，以上四种I/O模型都是同步I/O。<strong>同步I/O指的是读写操作，都是在I/O事件发生之后，由应用进程来完成。</strong>因此<strong>同步I/O要求应用进程自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，后者将数据从用户缓冲区写入内核缓冲区），这样的话内核向应用程序通知的是I/O就绪事件（内核缓冲区中有数据）</strong></p>
<h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>​    异步I/O是由POSIX规范所定义的，它和上面的同步I/O不同。</p>
<p>​    对于异步I/O而言，<strong>用户可以直接对I/O执行读写操作，这些操作告诉内核 用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。</strong></p>
<p>​    异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为真正的读写操作已经有内核接管。</p>
<p>​    <strong>（异步I/O的读写操作很像是一种注册行为，根本不需要等，只需要向内核注册了读写操作，内核接管该操作等待事件到来之后，直接进行读写操作）</strong></p>
<p>​    综上异步I/O向应用进程通知的是I/O完成事件。</p>
<p>​    下图为例</p>
<img src="/posts/49316947/%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B.jpg" class title="异步I&#x2F;O模型">

<p>​    我们调用<code>aio_read</code>函数，给内核传递描述符、缓冲区指针、缓冲区大小（与read相同的三个参数）和<strong>文件偏移（与lseek类似），并告诉内核整个操作完成时如何通知我们。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>I/O模型</th>
<th>读写操作和阻塞阶段</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞I/O</td>
<td>程序阻塞于读写函数</td>
</tr>
<tr>
<td>非阻塞I/O</td>
<td>程序不阻塞，但是系统调用如果无事件发生会返回错误</td>
</tr>
<tr>
<td>I/O复用</td>
<td>程序阻塞于I/O多路复用的系统调用，但可同时监听多个I/O事件。对I/O本身的读写操作是非阻塞的。</td>
</tr>
<tr>
<td>SIGIO信号</td>
<td>信号触发读写就绪事件，用户程序执行读写操作。程序没有阻塞阶段</td>
</tr>
<tr>
<td>异步I/O</td>
<td>内核执行读写操作并触发读写完成事件。程序没有阻塞阶段</td>
</tr>
</tbody></table>
<p>了解清楚同步I/O的差别之后，下一篇文章我们接着去了解reactor和proactor事件处理模式</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《APUE》</li>
<li>《Linux高性能服务器编程》</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>I/O模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor和Proactor模式</title>
    <url>/posts/a093a7a8/</url>
    <content><![CDATA[<blockquote>
<p>服务器程序一般需要处理三类事件：I/O事件，信号及定时事件。这些事件可以有两种高效的事件处理模式：Reactor和Proactor模式。一般来说同步I/O模型通常用于Reactor模式，异步I/O模型则用于实现Proactor模式。如果不懂什么是同步I/O，什么是异步I/O，可以先去看看之前的I/O模型文章。</p>
</blockquote>
<span id="more"></span>

<h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>​    Reactor是这样一种模式，它要<strong>求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话立即将该事件通知工作线程（逻辑单元）。</strong>除此之外，主线程不作任何其它实质性的工作。读写数据，接收新的连接，以及处理客户请求都在工作线程中完成。</p>
<p>​    不过值得注意的是，在自己的项目中为了简化线程数，功能有点不同</p>
<p>​    主线程的作用有：</p>
<ul>
<li><p>接收新的连接（将连接派发给其他工作线程）</p>
</li>
<li><p>进行I/O多路复用，监听事件</p>
</li>
<li><p>注册回调函数</p>
</li>
</ul>
<p>​    工作线程的作用有</p>
<ul>
<li>处理事件<ul>
<li>对于可读事件，进行读操作</li>
<li>对于可写事件，进行写操作</li>
<li>对于时间事件，进行定时操作</li>
</ul>
</li>
</ul>
<p>​    使用同步I/O模型（以<code>epoll_wait</code>为例）实现的Reactor模式的工作流程是：</p>
<ol>
<li>主线程往epoll内核事件表中注册一个socket上的就绪读事件。</li>
<li>主线程调用<code>epoll_wait</code>等待socket上有数据可读。</li>
<li>当socket上有数据可读时，<code>epoll_wait</code>通知主线程。主线程则将socket可读事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</li>
<li>主线程调用<code>epoll_wait</code>等待socket可写。</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求结果。</li>
</ol>
<p>下图为Reactor模式的工作流程：</p>


<p>该模式的核心还是基于事件驱动，而监视事件一般是通过主线程I/O多路复用来实现的。</p>
<h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p>​    Proactor模式与reactor模式不同，<strong>Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅只负责业务逻辑部分。</strong></p>
<p>​    一般来说Proactor模式是使用异步I/O模型（以<code>aio_read</code>和<code>aio_write</code>为例）实现的Proactor模式的工作流程：</p>
<ol>
<li><strong>主线程调用<code>aio_read</code>函数向内核注册socket读完成事件，并告诉内核用户读缓冲区的位置，以及读操作如何通知应用程序（比如使用信号）。</strong></li>
<li>主线程继续处理其他逻辑。</li>
<li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，通知应用程序数据可用。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用<code>aio_read</code>函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当域用户缓冲区被写入socket之后，内核奖项应用程序发送一个信号，已通知应用程序数据已经发送完毕。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。</li>
</ol>
<p>下图总结了Proactor模式的工作流程。</p>
<img src="/posts/a093a7a8/Proactor%E6%A8%A1%E5%9E%8B.jpg" class title="Proactor模型">

<p>总结一下就是Proactor模式是内核用来去处理I/O操作，用户注册操作完成通知机制，然后主线程直接执行数据读写操作，执行完之后，主线程向工作线程通知这一“完成事件”，工作线程直接获得数据读写结果，接下来做的只是对结果的逻辑处理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这两个模式的对比完美的展现出了同步I/O和异步I/O的区别：</p>
<ul>
<li><strong>同步I/O：内核向进程通知就绪事件，然后应用程序来执行I/O操作</strong></li>
<li><strong>异步I/O：内核向进程通知完成事件，在此之前内核已经执行完了I/O操作</strong></li>
</ul>
<p>不过这是I/O层次上的同步异步。</p>
<p>如果是在并发模式下，同步异步又有新的差别</p>
<ul>
<li>同步：程序完全按照代码序列的顺序执行</li>
<li>异步：程序的事件需要有系统事件来驱动。常见的系统事件包括中断、信号等。</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>Reactor</tag>
        <tag>Proactor</tag>
      </tags>
  </entry>
  <entry>
    <title>Schema与数据类型优化</title>
    <url>/posts/26ac1f1c/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章主要关注的是MySQL数据库的设计，主要介绍的是MySQL数据库的逻辑设计，用来为之后的索引设计和查询优化做铺垫</p>
</blockquote>
<span id="more"></span>

<p>​    良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计schema。</p>
<p>​    本章关注的是MySQL数据库的设计，主要介绍的是MySQL数据库设计与其他关系型数据库管理系统的区别。</p>
<p>​    </p>
<h3 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h3><p>​    MySQL支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。</p>
<p>​    以下是选择数据类型的原则：</p>
<ul>
<li><p>尽量使用可以存储正确数据的最小数据类型。</p>
</li>
<li><p>简单数据类型更好，因为这些操作通常需要更少的CPU周期。</p>
</li>
<li><p>尽量避免NULL，因为NULL的列会使用更多的存储空间，而且会使得索引相关比较难处理。</p>
</li>
<li><p>选择了合适的数据类型之后，下一步就得选择具体类型，具体的类型也是要依照具体使用情况来选择，如果都可以的话，那就选择更小，更简单的那个。</p>
<p>比如TIMESTAMP和DATETIME，如果都能用就选择TIMESTAMP，因为其只使用DATETIME一般的存储空间。</p>
</li>
</ul>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>​    整数有这些类型: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT(分别对应8,16,24,32,64位)，也可以使用UNSIGNED属性表示正整数。也可以用INT(10)限制显示个数，但是在后台没有意义。对存储计算来说，INT(1)和INT(20)是相同的。</p>
<h4 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h4><p>​    实数是带有小数部分的数字。然而，它们不只是为了存储小数部分；也可以使用<strong>DECIMAL</strong>，这个是比BIGINT还大的整数，用于扩大上限。</p>
<p>​    不过CPU不支持对他的直接计算，因此服务器自身实现了对他的高精度计算。因此DECIMAL需要额外的空间和开销，因此如果不是必须存储小数尽量不用。</p>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>定长字符串：<code>CHAR（size）</code> 一般存储比较小的字符串。</p>
<p>非定长字符串： <code>VARCHAR(SIZE)</code> 需要的空间是比size稍大，由于是不定长存储，因此可以节省存储空间。<strong>一般都是使用这个存储字符串。</strong></p>
<p><strong>BLOB和TEXT</strong>：存储大量字符串的方法，前者使用二进制存储，后者使用字符方式存储。尽量不用。</p>
<h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>一般的时间类型是YEAR和DATE。在MySQL中又提供了两种相似的日期类型：DATETIME和TIMESTAMP。</p>
<ul>
<li><p>DATETIME</p>
<p><strong>固定8字节存储。</strong>是一种可排序的、无歧义的格式显示DATETIME值，例如”2008-01-16 22:37:08”。这是ANSI标准定义的日期和时间表示方法</p>
</li>
<li><p>TIMESTAMP</p>
<p>保存自1970年1月1日午夜以来的秒数，<strong>它和UNIX时间戳一样。</strong></p>
<p><strong>固定4字节存储</strong>，依赖于时区。而且TIMESTAMP列默认为NOT NULL，这也和其他的数据类型不一样。</p>
</li>
</ul>
<p>一般无特殊情况尽量使用TIMESTAMP，因为其空间更小。</p>
<h4 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h4><p>BIT是用8个字节存储二进制位的类型，SET是一系列BIT 的组成。</p>
<h3 id="Shema设计中的陷阱"><a href="#Shema设计中的陷阱" class="headerlink" title="Shema设计中的陷阱"></a>Shema设计中的陷阱</h3><p>​    虽然有一些普遍的好或坏的设计原则，但也有一些问题是由MySQL的实现机制导致的，这意味着有可能犯一些只在MySQL下发生的错误。以下举一些错误的例子，我们要好好地处理它们。</p>
<ul>
<li><p><strong>太多的列</strong>：</p>
<p><strong>MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列</strong>。这样一来，如果列的数量过大，那么转换的代价会很高。因此我们要避免太多的列。</p>
</li>
<li><p><strong>太多的关联：</strong></p>
<p>关联太多的话，会影响解析和优化查询的代价，这样的话会使得查询执行速度变慢。如果希望查询执行得快速且并发性好，单个查询最好在12个表以内做关联。</p>
</li>
<li><p><strong>枚举：</strong></p>
<p>防止过度使用枚举，这样会使得schema的设计非常凌乱。因为在MySQL中在枚举中添加东西要做一次Alter Table 操作。</p>
</li>
</ul>
<h3 id="范式和反范式"><a href="#范式和反范式" class="headerlink" title="范式和反范式"></a>范式和反范式</h3><p>​    任何给定的数据通常都有多种表示方法，从完全的范式化到完全的反范式化，以及各种折中。</p>
<ul>
<li>范式的数据库中，每个事实数据只会出现一次。</li>
<li>反范式化的数据库中，信息是冗余的，可能存储在多个地方。</li>
</ul>
<h4 id="范式的优缺点"><a href="#范式的优缺点" class="headerlink" title="范式的优缺点"></a>范式的优缺点</h4><p>​    当为性能问题而寻求帮助时，经常会被建议对schema进行范式化设计，尤其是写密集的场景。这是个好建议，以下是范式化的优点</p>
<ul>
<li>范式化<strong>更新操作</strong>通常比反范式化要快。</li>
<li>当数据较好的范式化时，就只有很少或者没有重复数据，所以，<strong>只需要修改更少的数据</strong>。</li>
<li><strong>范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快</strong>。</li>
<li><strong>很少有多余的数据意味着检索列表数据更少需要distinct或者group by 语句</strong>。</li>
</ul>
<p>但是范式化的缺点也很明显，一般范式都需要关联。查<strong>询关联数据的语句代价很昂贵</strong>。</p>
<h4 id="反范式的优缺点"><a href="#反范式的优缺点" class="headerlink" title="反范式的优缺点"></a>反范式的优缺点</h4><p>​    反范式化的schema因为所有数据都在一张表上，其优缺点和范式恰好相反</p>
<p>以下是反范式化的优点</p>
<ul>
<li>可以很好地避免关联。</li>
<li>如果不需要关联表，对大部分查询最差情况，即没有使用索引，全表扫描。当数据币内存大时这可能比关联要快很多， 这样避免了随机I/O。</li>
</ul>
<p>缺点就是冗余数据太多</p>
<h4 id="部分范式化"><a href="#部分范式化" class="headerlink" title="部分范式化"></a>部分范式化</h4><p>​    一般来说，范式化和反范式化可以混用，称之为部分范式化。</p>
<p>​    在真实环境中很少会极端地使用范式化或者反范式化的schema。而是<strong>可能使用部分范式化的schema、缓存表、以及其它技巧</strong>。最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定的列。</p>
<h3 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h3><p>​    有时提升性能最好的方式是在同一张表中保存衍生的冗余数据。然而，有时候需要一张完全独立的汇总表或者缓存表，如果能容许少量的脏数据，这是非常好的方法。</p>
<ul>
<li><p><strong>缓存表</strong>：表示存储那些可以比较简单地从schema其他表获取（但是每次获取速度比较慢）数据的表。</p>
</li>
<li><p><strong>汇总表</strong>：保存的是使用<code>GROUP BY</code>语句聚合数据的表。</p>
</li>
</ul>
<p>​      建立这两个表能够减少对数据表的操作，从而提高效率。但是这两张表一般都是需要更新的，如果更新的快的话，也会浪费太多的性能。因此，使用这两张表的时候，必须决定是<strong>实时维护数据还是定期重建</strong>。</p>
<h4 id="计数器表"><a href="#计数器表" class="headerlink" title="计数器表"></a>计数器表</h4><p>​    如果在表中维护一个计数器的话，那么在更新计数器时可能碰到并发问题。因此为了让事情变得更加简单，我们可以独立创建一个表来存储计数器。这样可以使得计数器表小且快。使用独立的表可以帮助避免查询缓存失效。</p>
<p>​    以下我们来看看使用情况</p>
<p>假设有一个计数器表，只有一行数据，记录网站的点击次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table hit_counter(</span><br><span class="line">	cnt int unsigned not null</span><br><span class="line">)ENGINE = InnoDB;</span><br></pre></td></tr></table></figure>

<p>网站的每次更新都会导致对计数器进行更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update hit_counter</span><br><span class="line">set cnt = cnt + 1;</span><br></pre></td></tr></table></figure>

<p>问题在于，对于任何想要更新这一行的事务来说，<strong>这条记录上都有一个全局的互斥锁。这会使得这些事务只能串行执行。</strong>要获得更高的并发更新性能，可以将计数器保存在多行中，每次随机选择一行更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table hit_counter(</span><br><span class="line">	slot tinyint unsigned not null primary key,</span><br><span class="line">    cnt int unsigned not null</span><br><span class="line">)ENGINE = InnoDB;</span><br></pre></td></tr></table></figure>

<p>然后预先在这张表增加100行数据。现在选择一个随机的槽进行更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update hit_counter set cnt = cnt + 1 where slot = rand() * 100;</span><br></pre></td></tr></table></figure>

<p>要想获得结果，就得用聚合查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sum(cnt) from hit_counter</span><br></pre></td></tr></table></figure>

<p>这就相当于是一个计数器表来维护更新次数。</p>
<p><strong>更快地读，更慢地写</strong></p>
<p>​    为了提升读查询的速度，经常会需要建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法会增加写查询的负担，也需要额外的维护任务，但在设计高性能数据库是，这些都是常见的技巧：<strong>牺牲写操作的速度来更显著地提高读操作的性能。</strong></p>
<p>​    但是注意的是，这样不仅仅是牺牲写操作的速度，还可能同时增加了读操作和写操作的开发难度。</p>
<h3 id="加快ALTER-TABLE的速度"><a href="#加快ALTER-TABLE的速度" class="headerlink" title="加快ALTER TABLE的速度"></a>加快<code>ALTER TABLE</code>的速度</h3><p><code>ALTER TABLE</code>操作的性能对于大表来说是个大问题。MySQL之前是通过创立一个新的空白表，再将旧表中所有数据插入新表，然后删除旧表来实现<code>ALTER TABLE</code>。这样效率很低，还可能造成MySQL服务中断。</p>
<p>这里有几种方法来提高速度：</p>
<ul>
<li><p><strong>只修改<code>.frm</code>文件</strong>: 修改表中的这个文件很快，而且只需要在旧表中直接修改，这样可以提高效率。但是直接修改原表文件会造成风险，现在MySQL还没有默认引用该技术。 </p>
<p>不过有个折中的计数，创建一个空表，在这个空表上修改<code>.frm</code>文件，然后与旧表的<code>.frm</code>文件进行交换。这样的话安全性和效率都能得到保障。</p>
</li>
<li><p><strong>快速创建MyISAM索引</strong>： 先禁用索引，载入数据，然后重新启用索引。数据载入完全后后，这个时候可以通过排序来构造索引，这样一来索引的构造速度会加快很多。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    良好的schema设计原则是普遍适用的，但MySQL有它自己的实现细节要注意。概括来说，尽可能保持任何东西小而简单总是好的。MySQL喜欢简单，需要使用数据库的人应该同样会喜欢简单的原则：</p>
<ul>
<li><p>尽量避免过度设计，例如会导致及其复杂查询的schema设计，或者列很多的表项进行设计。</p>
</li>
<li><p><strong>使用小而简单的合适数据类型</strong>，除非真实目标有确切需要，否则尽可能避免使用NULL值。</p>
</li>
<li><p><strong>尽量使用相同的数据类型存储相似或相关的值</strong>，尤其是要在关联条件中的列。</p>
</li>
<li><p>注意可变长字符串(varchar)，其在临时表和排序时可能导致<strong>悲观的按最大长度分配内存</strong>。</p>
</li>
<li><p>尽量使用整型定义标识列。</p>
</li>
<li><p>避免使用MySQL已经一起的特性，比如指定浮点数的精度，或者整数的显示宽度。</p>
</li>
<li><p>小心使用ENUM和set，虽然他们使用起来很方便，但是可能有陷阱。而且最好避免使用BIT。</p>
</li>
</ul>
<p>​    范式是好的，但是反范式（大部分情况下意味着重复数据）有时也是必须的，并且能够带来好处。</p>
<p>​    最后，<strong>ALTER TABLE是让人痛苦的操作，因为在大部分情况下，它都会锁表并且重建整张表。</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《高性能MySQL》</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Schema</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL架构</title>
    <url>/posts/f91535f/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章来简单的介绍一下MySQL的架构，了解一下一些基本概念，比如MySQL逻辑架构，并发控制，事务，MVCC和存储引擎等。</p>
</blockquote>
<span id="more"></span>

<h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><h4 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h4><p>​    MySQL的逻辑架构可如下所示。</p>
<img src="/posts/f91535f/%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.jpg" class title="逻辑架构">

<p>该架构分为三层：</p>
<ul>
<li><p>最上层的服务并不是MySQL所独有的，大多数基于网络的客户端/服务器都会有类似的架构。比如连接处理、授权认证、安全等等。</p>
</li>
<li><p>第二层架构是MySQL的<strong>核心功能层</strong>。包括<strong>查询解析、分析、优化、缓存以及所有的内置函数</strong>（例如日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</p>
</li>
<li><p>第三层包含了<strong>存储引擎</strong>。<strong>存储引擎负责MySQL中数据的存储和提取。不同存储引擎的优缺点不同。</strong>服务器通过API与存储引擎进行通信。这些API接口屏蔽了存储引擎之间的差异，使得这些差异对上层的查询过程透明。<strong>存储引擎之间不会互相通信，只是会简单地响应上层服务器的请求。</strong>使用最多的存储引擎有InnoDB和MyISAM。</p>
</li>
</ul>
<h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><p>​    每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在该线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。<strong>这些线程是通过服务器的线程池存储的</strong>。</p>
<p>​    （这个和服务器中的线程池概念完全一样）</p>
<h4 id="连接安全性"><a href="#连接安全性" class="headerlink" title="连接安全性"></a>连接安全性</h4><p>​    当客户端连接到MySQL服务器时，服务器对其进行<strong>认证</strong>。认证基于用户名，原始主机信息和密码。如果使用了安全套接字(SSL)的方式连接，还可以使用证书进行认证。连接成功之后，服务器会对连接的操作权限进行验证，不让其进行超越自身权限的操作。</p>
<h4 id="优化与执行"><a href="#优化与执行" class="headerlink" title="优化与执行"></a>优化与执行</h4><p>​    <strong>MySQL会解析查询，并创建内部的数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。</strong></p>
<p>​    优化器不关心表使用的是什么存储引擎（优化器是在第二层，而存储引擎在第三层），但是存储引擎也会对优化查询产生影响。之后的章节会详细介绍查询优化。</p>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>​    只要有多个查询需要在同一时刻修改数据，那么其必然会产生并发控制的问题。本章的内容只讨论两个层面的并发控制：服务器层和存储引擎层。</p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>​    在数据库表中只是读取数据的时候，并不会有这种麻烦。但是如果在有用户读取数据的时候，另外的用户将该数据删除，那么会产生什么结果？答案是不确定，读的用户可能会报错退出，也可能读到不一致的数据。</p>
<p>​    因此在这种情况下，就需要<strong>并发控制</strong>。</p>
<p>​    MySQL服务器在处理并发读或写时，通过实现一个有两种类型的锁组成的锁系统来解决问题。这两种锁一般被称为<strong>共享锁（S）和排他锁（X），也称读锁和写锁。</strong></p>
<p>​    <strong>读锁是共享的</strong>，多个客户在同一时刻可以同时读取同一资源，而互不干扰。</p>
<p>​    <strong>写锁是排他的</strong>，只能有一个客户对该资源进行修改，其他客户会被阻塞。</p>
<h4 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h4><p>​    一种提高共享资源并发性的方式就是让锁定对象更有选择性。即只需要修改部分数据，而非所有资源。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高。</p>
<p>​    问题是加锁也需要消耗资源，<strong>锁的各种操作都会增加系统的开销</strong>，如获得锁，检查锁是否已经解除，释放锁等。如果系统花费太多时间来管理锁，而不是存储数据，这样也会对系统的性能产生影响。因此要选择恰当的锁策略。</p>
<p>​    所谓的锁策略，就是在<strong>锁的开销和数据的安全性之间寻求平衡</strong>，这种平衡当然也会影响到性能。大多数商业数据库系统没有提供更多的选择，一般都是<strong>在表上施加行级锁，并以各种复杂方式来实现</strong>。以下是两种最重要的锁策略</p>
<ul>
<li><p><strong>表锁：</strong></p>
<p>表锁是MySQL中最基本的锁的策略，并且是<strong>开销最小</strong>的策略。表锁顾名思义，是直接对整张表进行锁定。<strong>开销小，并发低，粒度大。</strong></p>
</li>
<li><p><strong>行级锁：</strong></p>
<p>行级锁可以最大程度上支持并发处理（同时带来了最大的锁开销），<strong>行级锁只在存储引擎层实现（InnoDB就可以实现），服务器层没有实现</strong>。在后续内容中，所有的存储引擎都以自己的方式显现了锁机制。</p>
<p><strong>粒度小，并发高，开销大。</strong></p>
</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>​    事务是一组<strong>原子性的SQL查询</strong>，或者说是一个独立的工作单元。原子性代表着事务内的语句，要么全部执行成功，要么全部执行失败。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>首先</p>
<p>​    使用<code>START TRANSACTION</code>语句开始一个事务</p>
<p>然后</p>
<p>​    使用<code>COMMIT</code>提交事务将修改的数据持久保留</p>
<p>OR</p>
<p>​    使用<code>ROLLBACK</code>撤销所有的修改</p>
<h4 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a><strong>ACID特性</strong></h4><ul>
<li>原子性（atomic）：一个事物被视为不可分割的最小工作单元，整个事务的操作要么全部都做提交成功，要么全部失败回滚。</li>
<li>一致性（consistency）：数据库总是从一个一致性的状态转换到另外一个一致性状态。</li>
<li>隔离性（isolation）：事务的所做的修改在未最终提交之前，对其他事务是不可见的。</li>
<li>持久性（durability）：一旦事务提交，则其做的修改会永久保存到数据库中。</li>
</ul>
<h4 id="与Redis事务的对比"><a href="#与Redis事务的对比" class="headerlink" title="与Redis事务的对比"></a>与Redis事务的对比</h4><p>​    <strong>Redis事务是一个很简单的事务</strong></p>
<h5 id="使用方法区别"><a href="#使用方法区别" class="headerlink" title="使用方法区别"></a>使用方法区别</h5><p>​    Redis没有回滚机制，只是简单的将命令入队，然后一个个出队执行，如果命令执行失败，则略过执行下一个。</p>
<ul>
<li><p>WATCH命令的执行监视着数据库内的键，如果在执行前被修改了的话，那就出错。</p>
</li>
<li><p>MULTI命令的执行标志着事务的开始（命令入队）</p>
</li>
<li><p>EXEC命令的执行标志着事务的执行（命令出队执行）</p>
</li>
</ul>
<h5 id="特性区别"><a href="#特性区别" class="headerlink" title="特性区别"></a>特性区别</h5><p>​    Redis事务甚至不能称之为事务。</p>
<ul>
<li>他不保证原子性</li>
<li>只在AOF同步写模式下才支持持久性</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>​    针对<strong>隔离性</strong>，在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所作的修改，哪些在事务间和事务内是可见的，哪些是不可见的。<strong>较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</strong></p>
<ul>
<li><p><strong>READ UNCOMMITTED (未提交读)：</strong></p>
<p>在该级别，事务中的修改，即使没有提交，对其他事务也都是可见的。<strong>事务可以读取未提交的数据，这也被称为脏读</strong>。</p>
<p>这个级别从性能上也没比其它级别好太多，但是导致的问题很多，因此一般不用。</p>
</li>
<li><p><strong>READ COMMITED(提交读)：</strong></p>
<p>大多数数据库系统的默认隔离级别都是这一个（MySQL不是）。 该级别符合隔离性的简单定义：一个事务开始是，只能“看见”已经提交的事务所作的修改。 换句话说<strong>，该事务从开始直到提交之前，所做的任何修改对其他事务都不可见。</strong> 这个级别有时候也叫作<strong>不可重复读</strong>。因为两次执行同样的查询，结果可能不一样。</p>
</li>
<li><p><strong>REPEATABLE READ(可重复读)：</strong></p>
<p>该级别是<strong>MySQL的默认事务隔离级别。</strong> 该级别解决了脏读问题。保证了在<strong>同一事务中多次读取同样记录的结果是一致的</strong>。但是并未解决<strong>幻读。</strong></p>
<p><strong>幻读是指当某个事务读取某个范围内的记录时，另外一个事务又在该范围插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。</strong></p>
<p><strong>MySQL数据库的存储引擎（InnoDB和XtraDB）靠MVCC解决幻读问题。</strong></p>
<p>MySQL的默认事务隔离级别。</p>
</li>
<li><p><strong>SERIALIZABLE(可串行化)：</strong></p>
<p>该级别是最高的隔离级别，它通过强制事务串行执行，避免了幻读问题。简单来说，<strong>该级别会在读取的每一行数据上都加上锁，所以可能导致大量的超时和锁争用问题</strong>，因此实际应用中也很少用到。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读可能性</th>
<th>不可重复读可能性</th>
<th>幻读可能性</th>
<th>加锁读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>提交读</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>可重复读</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>可串行化</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>在提交读和可重复读这两个层次，一定要非常的明白。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><strong>死锁</strong></h4><p>​    <strong>死锁是指两个或多个事务在同一资源上的相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</strong>当多个事务以不同的顺序锁定资源，或者多个事务同时锁定同一资源，都会产生死锁。 不过<strong>锁的行为和顺序和存储引擎相关</strong>，以同样的顺序执行语句，有些存储引擎会死锁，有些不会。</p>
<p>​    因此死锁的原因有两种：真正的数据冲突和存储引擎的实现。</p>
<h4 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a><strong>MySQL中的事务</strong></h4><p>​    MySQL提供两种事务型的存储引擎：InnoDB和NDB cluster。一般我们说的存储引擎都是InnoDB。</p>
<p>InnoDB采用的是<strong>两阶段锁定协议</strong>。在事务的执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，而且所有锁都是同一时刻释放。</p>
<h3 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h3><p>​    MVCC可以看做是<strong>行级锁</strong>的一种，但是<strong>它在很多情况下避免了加锁操作，因此开销更低</strong>。实现了<strong>非阻塞的读操作和锁定必要行的写操作。</strong></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h4><p>​    通过保存数据在某个时间点的<strong>快照</strong>来实现的。这样一来，每个事务看到的数据都是一致的。不过根据事务开始的时间不同，每个事务对同一张表，同一时刻看的数据可能是不一样的。</p>
<p>​    MVCC有着乐观和悲观两种实现模式。在这里我们只讲InnoDB下的MVCC。</p>
<h4 id="InnoDB的MVCC"><a href="#InnoDB的MVCC" class="headerlink" title="InnoDB的MVCC"></a>InnoDB的MVCC</h4><p>​    通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间。当然并不是直接保存实际的时间值，而是<strong>系统版本号</strong>。每开始一个新的事务，系统版本号都会自动递增。事务开始的系统版本号会作为事务的版本号，用来查询到的每行记录的版本号进行比较。</p>
<p>​    这样的话，如果在<strong>可重复读隔离级别下，就能够通过记录的系统版本号作比对来解决幻读。而且因为只需要进行比对版本号而不需要加锁，</strong>这种情况下的<strong>MVCC是乐观的</strong>，且操作简单，性能好。缺点就是占据了多的两列空间。</p>
<p>这种乐观的MVCC只在中间两个隔离级别下工作，因为没有加锁。</p>
<h4 id="彻底解决幻读"><a href="#彻底解决幻读" class="headerlink" title="彻底解决幻读"></a>彻底解决幻读</h4><p>​    如果是想要彻底解决幻读的话，那必须得将隔离级别提升到可串行化这一级别。可串行化的特点就是加行级锁。</p>
<p>​    在解决幻读的方法中是加间隙锁（next-key locking），间隙锁是一个在<strong>索引记录之间</strong>的间隙上的锁。<strong>间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，防止其他事务在该事务的访问间隙中修改数据，这样可以防止幻影行的插入。</strong></p>
<p>​    间隙锁其实是一种悲观的解决幻读的方式，在此模式下默认幻读很容易发生，因此提前加锁。</p>
<p>​    </p>
<h3 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a><strong>InnoDB</strong></h4><p>​    InnoDB是MySQL的<strong>默认事务引擎</strong>，也是最重要，使用最广泛的存储引擎。它被设计用来<strong>处理大量的短期事务</strong>。</p>
<ul>
<li><p>InnoDB的数据存储在<strong>表空间</strong>，表空间有一系列数据文件组成。</p>
</li>
<li><p>InnoDB用<strong>MVCC来支持高并发</strong>，并且实现了四个隔离级别，默认是可重复读级别，并且通过<strong>间隙锁策略</strong>防止幻读的出现。</p>
</li>
<li><p>InnoDB表是基于<strong>聚簇索引</strong>建立的，这个以后讨论。聚簇索引对主键查询有很高的性能。</p>
</li>
</ul>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a><strong>MyISAM</strong></h4><p>​    MyISAM在MySQL5.1及之前版本，是默认存储引擎。MyISAM提供了大量的特性，包括全文索引，压缩，空间函数等，但是<strong>它不支持事务和行级锁！</strong>一般来说不用了解太多。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    本章介绍的内容是层层递进的，首先介绍的是MySQL的逻辑架构。然后首先介绍服务器层的一些知识。之后迎来了重点</p>
<ul>
<li>并发控制</li>
<li>事务</li>
<li>隔离级别</li>
<li>死锁</li>
<li>MVCC</li>
<li>存储引擎简要介绍</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《高性能MySQL》</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>MySQL</tag>
        <tag>并发控制</tag>
        <tag>MVCC</tag>
        <tag>存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事务</title>
    <url>/posts/4d5e325c/</url>
    <content><![CDATA[<blockquote>
<p>本文简单介绍一下Redis事务，这一章节主要是过渡，学习Redis的事务之后就直接可以去看MySQL相关知识。</p>
</blockquote>
<span id="more"></span>

<h4 id="事务的介绍"><a href="#事务的介绍" class="headerlink" title="事务的介绍"></a>事务的介绍</h4><p>​    <strong>Redis通过MULTI、EXEC、WATCH等命令来实现事务功能。</strong></p>
<p>​    <strong>事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制。并且事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中所有命令都执行完毕，然后才去处理其他客户端的命令请求</strong></p>
<p>​    Redis的事务依旧有着ACID四大特性：原子性，一致性，隔离性，耐久性。</p>
<p>​    总结来说，Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p>
<h4 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h4><p>​    一个事务从开始到结束通常经历三个阶段</p>
<ul>
<li>事务开始</li>
<li>命令入队</li>
<li>事务执行</li>
</ul>
<h5 id="事务开始"><a href="#事务开始" class="headerlink" title="事务开始"></a>事务开始</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> MULTI</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>​    MULTI命令可以将该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的flags属性中打开<code>REDIS_MULTI</code>标识来完成的，MULTI命令的实现可以用以下伪代码来表示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def MULTI():</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 打开事务标识</span></span><br><span class="line">	client.flags |= REDIS_MULTI</span><br><span class="line"><span class="meta">	#</span><span class="bash"> 返回OK回复</span></span><br><span class="line">	replyOK()</span><br></pre></td></tr></table></figure>



<h5 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h5><p>​    当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行。</p>
<p>与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：</p>
<ul>
<li>客户端EXEC，DISCARD，WATCH，MULTI四个命令的其中一个，那个服务器立即执行这个命令。</li>
<li>除上面的命令，服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回QUEUED回复。</li>
</ul>
<h5 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h5><p>​    每个Redis客户端都有自己的事务状态，这个事务状态，这个事务状态保存在客户端状态的<code>mstate</code>属性里面：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">	multiState mstate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    事务状态包含一个事务队列，以及一个已入队命令的计数器（事务队列的长度）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">multiState</span>&#123;</span></span><br><span class="line">    multiCmd *commands;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    事务队列以先进先出的方式保存入队的命令，较先入队的命令会被放到数组的前面，而较后入队的命令则被放到数组的后面。</p>
<h5 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h5><p>​    当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回客户端。</p>
<h4 id="WATCH命令的实现"><a href="#WATCH命令的实现" class="headerlink" title="WATCH命令的实现"></a>WATCH命令的实现</h4><p>​    watch命令是一个<strong>乐观锁</strong>，<strong>它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是，那就拒绝执行该事务，并向客户端返回代表事务执行失败的空回复。</strong></p>
<p>​    以下来介绍WATCH命令的实现原理，说明事务系统是如何监视某个键，并在键被修改的情况下，确保事务的安全性的。</p>
<p>​    WATCH命令生成一个字典<code>watch_keys</code>，服务器能够清楚的知道哪些数据键正在被监视，以及哪些客户端正在监视这些数据库键。</p>
<p>​    <strong>在执行修改键命令（如set，sadd，del等）之后，都会调用一个<code>touchWatchKey</code>函数对<code>watched_keys</code>字典进行检查，查看是否有客户端正在监视刚刚被命令修改过得数据库键，如果有的话，那么该函数会讲监视被修改键的客户端的<code>REDIS_DIRTY_CAS</code>标识打开，表示事务安全性被破坏</strong></p>
<h4 id="事务的ACID性质"><a href="#事务的ACID性质" class="headerlink" title="事务的ACID性质"></a>事务的ACID性质</h4><p>​    在传统的关系式数据库中，常常用ACID性质来检验事务功能的可靠性和安全性。</p>
<p>​    在Redis中，事务总是具有原子性、一致性和隔离性，并且当运行在某些特殊的模式下时，事务也具有耐久性。</p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>​    事务具有原子性指的是，事务是由一系列操作执行，如果执行的话，要么不做，要么全部执行。</p>
<p>​    但值得注意的是，Redis没有事务回滚功能，就算事务出错的话，也会一直执行下去。</p>
<p>​    <img src="/posts/4d5e325c/%E5%8E%9F%E5%AD%90%E6%80%A7.png" class title="原子性"></p>
<p>​    <strong>总结来说：Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</strong></p>
<p>​    这是因为Redis作者觉得如果命令出错应该是编程出错，在生产环境中一般不会出错，因此不设置回滚的话，能够让Redis更简单高效。</p>
<h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><p>​    事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么不管事务是否执行成功，数据库也应该仍然是一致的。</p>
<p>​    <strong>Redis通过谨慎的错误检测和简单的设计来保证事务的一致性。</strong></p>
<ul>
<li><p>入队错误</p>
<p>入队命令出错，那么Redis拒绝执行该命令</p>
</li>
<li><p>执行错误</p>
<p>在事务执行的过程中，出错的命令会被服务器识别出来，并进行响应的错误处理，所以这些出错命令不会对数据库做任何修改，也不会对事务的一致性产生任何影响。</p>
</li>
<li><p>服务器停机</p>
<p>由于有持久化，服务器停机也不会影响到事务的一致性。</p>
</li>
</ul>
<h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><p>​    <strong>事务具有隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果相同。</strong></p>
<p>​    <strong>Redis使用单线程来执行事务和命令，并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。</strong></p>
<h5 id="耐久性"><a href="#耐久性" class="headerlink" title="耐久性"></a>耐久性</h5><p>​    <strong>事务的耐久性指的是，当一个事务执行完毕，该事务的结果已经被保存到永久性存储介质里面，即使服务器事务执行完毕之后停机，执行事务所得的结果也不回丢失。</strong></p>
<p>​    Redis的事务不过是简单地用队列包裹起了一组Redis命令，Redis的持久性依旧需要靠其持久化模式</p>
<ul>
<li>如果无持久化，那么关机，该服务器所有数据都丢失</li>
<li><strong>如果是RDB的话，那么BGSAVE生成的RDB文件不能保证数据第一时间能存储到硬盘中，所以RDB持久化下Redis是没有耐久性的。</strong></li>
<li><strong>如果是AOF的话，当同步选项为always时，程序在执行命令之后调用同步函数，将命令数据保存在硬盘里，这种配置下的事务是具有耐久性的。</strong></li>
<li>其它选项的AOF下（如no，everysec），都不具备耐久性。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis多机</title>
    <url>/posts/25cc3a82/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章介绍一下Redis多机数据库的实现，主要内容有主从复制，哨兵机制和cluster集群，这些多机特性能够让Redis很好的实现分布式数据库。由于是多机，目前没有接触过，所以记录的都是书本上的知识。</p>
</blockquote>
<span id="more"></span>

<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><h4 id="复制介绍"><a href="#复制介绍" class="headerlink" title="复制介绍"></a>复制介绍</h4><p>​    在Redis中，用户可以通过执行<code>SLAVEOF</code>命令或者设置<code>slaveof</code>选项，让一个服务器去复制另一个服务器。</p>
<ul>
<li>主服务器：被复制的服务器</li>
<li>从服务器：复制的服务器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> now there are two redis servers : 127.0.0.1:6379, 127.0.0.1:12345</span></span><br><span class="line">127.0.0.1:12345&gt; SLAVEOF 127.0.0.1:6379</span><br><span class="line"><span class="meta">#</span><span class="bash"> main server: 6379</span> </span><br></pre></td></tr></table></figure>

<p>进行复制中的主从服务器双方的数据库将保存相同的数据，概念上称作数据库状态一致。</p>
<p><strong>通过<code>slaveof</code>命令连接的服务器，修改主服务器数据，会将从服务器数据也修改。</strong></p>
<h4 id="旧版复制"><a href="#旧版复制" class="headerlink" title="旧版复制"></a>旧版复制</h4><p>Redis的复制功能分为同步和命令传播两个操作：</p>
<ul>
<li>同步操作：用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态</li>
<li>命令传播：主服务器状态被修改，导致主从服务器不处于一致状态，让主从服务器的数据库重新回到一致状态。</li>
</ul>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>​    同步操作是需要从服务器对主服务器发送<code>SYNC</code>命令来完成。以下是该命令的执行步骤</p>
<ul>
<li><p>从服务器给主服务器发送SYNC命令</p>
</li>
<li><p><strong>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使一个缓冲区记录从现在开始执行的所有写命令。</strong></p>
</li>
<li><p>当主服务器的BGSAVE命令执行完毕时，主服务器将BGSAVE命令生成的RDB文件发送给从服务器，从服务器加载该文件，使得从服务器的状态和执行BGSAVE命令的主服务器状态一致</p>
</li>
<li><p>主服务器将缓冲区的所有写命令发送给从服务器，从服务器执行这些命令将状态恢复到一致。</p>
</li>
</ul>
<p>总结： 主服务器执行BGSAVE生成RDB文件，然后将执行命令中的写命令也发过去，相当于RDB+写补丁。</p>
<h5 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h5><p>​    主服务器将要执行的写命令发送给从命令。</p>
<h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ul>
<li><p>初次复制：从服务器没有复制过该主服务器，那么这样做可以。</p>
</li>
<li><p>断线后重复制： 因网络原因中断了复制，重新连接之后继续复制，这样的话<strong>同步效率很低</strong>。</p>
</li>
<li><p><strong>SYNC命令很耗费资源</strong>，因为会执行BGSAVE和发送RDB文件。因此Redis有必要保证真正有需要时才执行SYNC命令。</p>
</li>
</ul>
<h4 id="新版复制"><a href="#新版复制" class="headerlink" title="新版复制"></a>新版复制</h4><p>​    为了解决旧版复制的低效问题，Redis将PSYNC代替SYNC执行同步操作。</p>
<p>​    PSYNC拥有两个模式：</p>
<ul>
<li><strong>完整重同步</strong>：和上文同步一样，用于<strong>处理初次复制</strong>。</li>
<li><strong>部分重同步</strong>：<strong>处理断线后重复制</strong></li>
</ul>
<h4 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h4><p>​    该功能由以下三部分组成：</p>
<ul>
<li>主服务器的复制偏移量和从服务器复制偏移量</li>
<li>主服务器的复制积压缓冲区</li>
<li>服务器的运行ID</li>
</ul>
<p><strong>复制偏移量</strong>：主服务器每次向从和服务器传播N个字节，主服务器偏移量+N，从服务器收到N字节，从服务器偏移量+N。</p>
<p>根据偏移量，那么程序很容易知道<strong>主从服务器是否处于一致——偏移量相同就一致</strong></p>
<p><strong>复制积压缓冲区</strong>： 一个固定长度的队列，写命令不仅发给从服务器，还会入队，保存写命令缓冲。如果断线重连之后，会查看偏移量是否在缓冲区中，在的话就执行部分重同步。</p>
<p><strong>服务器运行ID</strong>: </p>
<ul>
<li>每个服务器运行ID都不同，从服务器会在第一次复制的时候保留主服务器的运行ID，这样才能正确找到主服务器。</li>
<li>通过主服务器ID从服务器可以明确知道这次同步是不是第一次同步，如果是，那就执行完全同步，如果不是，那就执行部分重同步。</li>
</ul>
<h4 id="复制流程"><a href="#复制流程" class="headerlink" title="复制流程"></a>复制流程</h4><ul>
<li>设置主服务器的地址和端口</li>
<li>建立套接字连接</li>
<li>发送PING命令，确认连接已经建立并能够收到从服务器请求。</li>
<li>身份验证，如果有安全选项的话</li>
<li>发送端口信息</li>
<li><strong>同步</strong></li>
<li><strong>命令传播</strong></li>
<li>心跳检测</li>
</ul>
<h4 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h4><p>​    本章主要讲了讲Redis服务器主从复制，其实主从复制核心是一个命令<code>PSYNC</code>，两个步骤——同步和命令传播。在同步中又有部分同步和完全同步。把握住这些基本上就没问题了。</p>
<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><h4 id="哨兵介绍"><a href="#哨兵介绍" class="headerlink" title="哨兵介绍"></a>哨兵介绍</h4><p>​    哨兵是Redis高可用性的解决方案：由一个或多个哨兵实例组成的哨兵系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p>​    <strong>主服务器进入下线状态时，哨兵系统会选举领头哨兵，然后执行故障转移操作。</strong></p>
<p>​    哨兵也是一个Redis服务器，只不过其运行在特殊模式下，该模式下的服务器没有数据库，因此在启动的时候并不会载入RDB或者AOF文件。</p>
<h4 id="哨兵功能"><a href="#哨兵功能" class="headerlink" title="哨兵功能"></a>哨兵功能</h4><p>​    哨兵是有着专门的代码，在使用了哨兵专用代码后，服务器会初始化一个<code>sentinel.c/sentinelState</code>结构（简称Sentinel状态），该结构保存了服务器中所有和Sentinel功能相关的状态。以下就来说一下相关的功能</p>
<ul>
<li><p>masters属性</p>
<p><strong>masters字典记录这所有被该Sentinel监视的主服务器的相关消息。</strong></p>
<ul>
<li>字典的键是被监视的主服务器的名字</li>
<li>字典的值则是被监视主服务器的<code>sentinel.c/sentinelRedisInstance</code>结构。该结构代表着一个被监视的服务器实例，这个实例可以是主、从服务器，或另外一个Sentinel。</li>
</ul>
</li>
<li><p>两个连接：Sentinel会对监视的主服务器创建两个连接</p>
<ul>
<li>命令连接：专门向主服务器发送命令，并接收命令回复。</li>
<li>订阅连接：专门订阅主服务器的<code>__sentinel__:hello</code>频道。</li>
</ul>
<p>为什么用两个连接？ 因为被发送的订阅消息都不会保存在Redis服务器里面，如果信息发送时，想要接收该信息的客户端不在线或者断线，那么这个客户端就会丢失该信息。因此为了不丢失信息，将订阅信息来放到哨兵中去接收。</p>
<ul>
<li>连接都是异步连接</li>
</ul>
</li>
<li><p>获取主服务器信息</p>
<p>每十秒一次，通过发送INFO命令，来获取主服务器的当前信息。</p>
<ul>
<li>首先是获得主服务器本身的信息。</li>
<li>其次是获得主服务器属下所有从服务器的信息。</li>
</ul>
</li>
<li><p>获取从服务器信息</p>
<p>当哨兵发现主服务器有新的从服务器出现时，哨兵除了会为这个新的从服务器创建相应的实例结构之外，还会创建连接到从服务器（命令和订阅连接）</p>
</li>
<li><p>向主从服务器发送命令和接收频道信息</p>
</li>
<li><p>更新sentinels字典：该字典中保存除Sentinel本身之外，所有同样监视这个主服务器的其他哨兵的资料</p>
</li>
<li><p>创建连向其他Sentinel的命令连接</p>
</li>
</ul>
<p>总结一下，哨兵的功能和两个字典有关。</p>
<ul>
<li>一个是masters字典，记录着主服务器的信息，然后通过主服务器的信息来与所有连接的主从服务器进行命令连接和订阅连接。</li>
<li>一个是sentinels字典，记录这其他监视相同主服务器的哨兵的信息，然后通过这些信息来与其他哨兵进行命令连接。</li>
</ul>
<h4 id="服务器下线"><a href="#服务器下线" class="headerlink" title="服务器下线"></a>服务器下线</h4><p>​    在默认情况下，哨兵会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回PING命令回复来判断实例是否在线。</p>
<p>​    Ping命令回复</p>
<ul>
<li>有效回复：实例返回+PONG、 -LOADING、-MASTERDOWN</li>
<li>无效回复：实例返回这三个之外的其他回复，或者指定时限内没有返回任何回复</li>
</ul>
<h5 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h5><p>​    如果某个哨兵向实例连续发送多个ping命令，收到的都是无效回复，那么Sentinel会修改这个实例所对应的实例结构，在结构的flags属性中打开<code>SRI_S_DOWN</code>标识，以此表明该实例进行主观下线。</p>
<p>（一般该时间是10s）</p>
<h5 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h5><p>​    <strong>当一个哨兵将一个主服务器判断为主观下线之后</strong>，为了确认这个服务器是否真的下线了，<strong>它会向同样监视这个主服务器的其它哨兵进行询问</strong>，看它们是否也认为主服务器已经进入下线状态。当哨兵从其他哨兵那里接收到<strong>足够数量的已下线判断</strong>之后，哨兵就会将该服务器判定为<strong>客观下线</strong>，并对<strong>主服务器</strong>进行<strong>故障转移</strong>操作。</p>
<p>（一般该数量是5）</p>
<h4 id="选举领头哨兵"><a href="#选举领头哨兵" class="headerlink" title="选举领头哨兵"></a>选举领头哨兵</h4><p>​    当一个主服务器被判断为客观下线时，见识这个下线主服务器的各个哨兵会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。</p>
<p>​    Redis选举领头哨兵是使用raft算法（raft算法就是选举算法，广泛运用于分布式一致性中）</p>
<h5 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h5><ul>
<li><p><strong>所有在线的哨兵都有资格被选举为领头哨兵</strong></p>
</li>
<li><p>每次进行领头哨兵选举之后，无论选举是否成功，哨兵的配置纪元都会增加1。（配置纪元就是一个计数器）</p>
</li>
<li><p>在一个配置纪元里，所有的哨兵都有一次将某个哨兵设置为局部领头哨兵的机会，设置完在这次配置纪元中就不能修改</p>
</li>
<li><p><strong>每个发现主服务器下线的哨兵都会被设置为局部领头哨兵</strong></p>
</li>
<li><p>哨兵设置局部领头哨兵的规则是<strong>先到先得</strong>，最先向目标哨兵发送设置要求的源哨兵会成为目标哨兵的领头哨兵，之后的请求会被该目标哨兵拒绝</p>
</li>
<li><p><strong>如果某个哨兵被半数以上的哨兵设置为局部领头哨兵，那么该哨兵就成为领头哨兵</strong></p>
</li>
<li><p>如果在给定的时间内，没有一个哨兵被选举成领头哨兵，那么各个哨兵将在一段时间之后再次进行选举，直到选出领头哨兵为止</p>
</li>
</ul>
<h5 id="选举算法优点"><a href="#选举算法优点" class="headerlink" title="选举算法优点"></a>选举算法优点</h5><ul>
<li>简单</li>
<li>高一致性</li>
<li>成熟的Raft算法</li>
</ul>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>​    当选举出领头的哨兵之后，领头哨兵对已下线的主服务器执行故障转移操作。该操作包括以下三个步骤</p>
<ul>
<li>在已下线主服务器属下的所有从服务器里面，挑出一个从服务器，并将其转换为主服务器</li>
<li>让已下线主服务器属下所有的从服务器改为复制新的主服务器</li>
<li>下线的服务器重新上线后会成为新的主服务器的从服务器</li>
</ul>
<h5 id="挑选新主服务器"><a href="#挑选新主服务器" class="headerlink" title="挑选新主服务器"></a>挑选新主服务器</h5><p>​    主服务器的从服务器那么多，如何挑选从服务器作为主服务器？这个的话肯定是要最适合的，适合的意思就是状态良好，数据完整。以下是规则：</p>
<ul>
<li>优先级最高的从服务器（从服务器都有优先级，领头哨兵会根据从服务器的优先级来挑选主服务器）</li>
<li>对于相同优先级，选择复制偏移量最大的从服务器（复制偏移量越大代表服务器越完整）</li>
<li>如果优先级和复制偏移量都差不多的话，那么就选择运行ID最小的那个</li>
</ul>
<p>挑选出之后，领头哨兵向这个从服务器发送<code>SLAVEOF no one</code>命令，将这个从服务器转换为主服务器</p>
<h5 id="修改其它从服务器的复制目标"><a href="#修改其它从服务器的复制目标" class="headerlink" title="修改其它从服务器的复制目标"></a>修改其它从服务器的复制目标</h5><p>​    领头哨兵向其它从服务器发送<code>SLAVEOF + &lt;new_main_server_ip&gt; + &lt;new_main_server_port&gt;</code>命令，让它们开始复制新的主服务器，复制的话一般使用部分同步就可以。</p>
<h5 id="将旧主服务器变为从服务器"><a href="#将旧主服务器变为从服务器" class="headerlink" title="将旧主服务器变为从服务器"></a>将旧主服务器变为从服务器</h5><p>​    旧主服务其上线后，也执行上面那个命令，就ok了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>哨兵只是一个特殊模式下的Redis服务器，它没有数据库，负责监视服务器。</li>
<li>哨兵一般是向服务器建立两个连接——命令连接和订阅连接。前者用于向主服务器发送命令请求，后者用于接收指定频道的信息。</li>
<li>哨兵每过10秒发送INFO命令，来获取主服务器下的新增从服务器信息，并为其建立两个连接。</li>
<li>哨兵会通过主服务器的订阅频道发送信息来向其它的哨兵宣告自己的存在，并且和其他哨兵也建立命令连接（无订阅连接）</li>
<li>哨兵每秒1次向建立命令连接的其他实例发送ping命令，如果有主服务器连续几次都是无效回复，那么判定其主观下线</li>
<li>判定之后会向其他监视该主服务器的哨兵发送命令，如果一定数量的哨兵都观察该服务器主观下线，那么判定其客观下线</li>
<li>当有主服务器客观下线，那么所有哨兵使用Raft算法选举领头哨兵</li>
<li>领头哨兵对服务器进行故障转移操作</li>
</ul>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="集群介绍"><a href="#集群介绍" class="headerlink" title="集群介绍"></a>集群介绍</h4><p>​    Redis集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。本章就是对集群的节点、槽指派、命令执行、重新分片、转向、故障转移、消息等各个方面进行介绍。</p>
<p>​    首先集群模式是一种选项，在启动服务器的时候，服务器会根据<code>cluster-enabled</code>配置选项是否为yes来决定开启服务器集群模式。（不开启的话就是普通的Redis单机模式）</p>
<p>​    集群的基本单位是节点，节点就是一个Redis服务器。一个集群由多个节点组成。在最开始的时候，每个节点都是独立在只包含自己节点的集群中，要想建立一个可靠的集群，必须得将这些这些节点连接起来。</p>
<p>​    节点结构是一个<code>clusterNode</code>，保存了一个节点当前的状态，比如节点的创建时间、节点的名字、节点当前的配置纪元、节点的IP地址和端口号地址等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">mstime_t</span> ctime; 					<span class="comment">// create time</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];	<span class="comment">// name</span></span><br><span class="line">    <span class="keyword">int</span> flags;							<span class="comment">// flag save the node state, such as main node or noy, online or outline</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;				<span class="comment">// select times</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN];			<span class="comment">// ip</span></span><br><span class="line">    <span class="keyword">int</span> port;							<span class="comment">// port</span></span><br><span class="line">    clusterLink* link;					<span class="comment">// save the information of node which is connected with this node</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clusterLink : connection</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span>&#123;</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;						<span class="comment">// connection create time</span></span><br><span class="line">    <span class="keyword">int</span> fd;								<span class="comment">// tcp socket fd</span></span><br><span class="line">    sds sndbuf;							<span class="comment">// write buffer</span></span><br><span class="line">    sds recbuf;							<span class="comment">// read buffer</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>* <span class="title">node</span>;</span>			<span class="comment">// the node which is linking with the struct</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    节点的连接通过<code>CLUSTER MEET</code>命令来完成，该命令的格式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">CLUSETR MEET <span class="tag">&lt;<span class="name">IP</span>&gt;</span> <span class="tag">&lt;<span class="name">PORT</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    <strong>向一个节点发送该命令，两个节点就会进行握手，握手成功后，目标节点就能够加入到源节点的集群中。</strong></p>
<h4 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h4><p>​    <strong>Redis集群通过分片的方式来保存数据库中的键值对</strong>：集群的整个数据库被分为16384个槽，数据库中的每个键都属于这个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。</p>
<p>​    <strong>当数据库中的所有槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果只要有一个槽没有被指定，那么就处于下线状态（fail）</strong></p>
<p>​    节点除了会将自己负责处理的槽记录在<code>clusterNode</code>结构的<code>slots</code>属性和<code>numslots</code>属性之外，还会告知其他节点自己目前处理的槽位信息。</p>
<h4 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h4><p>​    集群上线之后，客户端可以与该集群建立连接并发送命令。当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给自己。</p>
<ul>
<li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令</li>
<li>如果键所在的槽并没有指派给了当前节点，那么节点会向客户端返回一个<strong>MOVED错误</strong>，指引客户端重定向至正确的节点，并再次发送之前想要执行的命令。</li>
</ul>
<p>计算键属于哪个槽是利用<strong>CRC校验</strong>方法；计算槽是否由当前节点负责是查看节点内的slots数组，该槽位是否置为1，如果不是，那就去向其它的节点发送命令。</p>
<p><strong>MOVED错误相当于是个重定向信息，该错误被自动隐藏，因为重定向会直接执行下次命令寻找到该节点。如果是单机模式下，那MOVED错误会直接打印出来。</strong></p>
<h4 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h4><p>​    <strong>重新分片操作可以将任意数量已经指派给某个节点（源节点）的槽指派给另外一个节点（目标节点），并将相关槽所属的键值对也会从源节点被移动到目标节点。</strong></p>
<p>​    重新分片操作可以在线进行，再重新分片时，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</p>
<h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>​    重新分片操作是由Redis集群管理软件<code>redis-trib</code>负责执行的。该软件对集群的单个槽slot进行重新分片的步骤如下：</p>
<ol>
<li><code>redis-trib</code>对<strong>目标节点</strong>发送<code>CLUSTER SETSLOT &lt;SLOT&gt; IMPORTING &lt;SOURCE_ID&gt;</code>命令，让目标节点准备好从源节点导入（import）属于槽的键值对。</li>
<li><code>redis-trib</code>对<strong>源节点</strong>发送<code>CLUSTER SETSLOT &lt;SLOT&gt; MIGRATING &lt;TARGET_ID&gt;</code>命令，让源节点准备好将槽的键值对迁移（migrate）至目标节点。</li>
<li><code>redis-trib</code>向源节点发送<code>CLUSTER GETKEYSINSLOT &lt;SLOT&gt; &lt;COUNT&gt;</code>命令，获得最多count个属于槽slot的键值对的键名。</li>
<li>对于步骤3获得的键名，<code>redis-trib</code>都会向源节点发送一个<code>MIGRATE &lt;TARGET_IP&gt; &lt;TARGET_PORT&gt; &lt;KEY_NAME&gt; 0 &lt;TIMEOUT&gt;</code>命令，被选中的键原子地从源节点迁移至目标节点。</li>
<li>重复3和4，知道源节点保存的所有属于槽的slot的键值对都被迁移至目标节点位置。</li>
<li>迁移完成之后，<code>redis-trib</code>向集群中的任意一个节点发送<code>CLUSTER SETSLOT &lt;SLOT&gt; NODE &lt;TARGET_ID&gt;</code>命令，将槽SLOT指派给目标节点，这个信息会发送给整个集群，所有节点都会知道这件事。</li>
</ol>
<h5 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h5><p>​    在重新分片的过程中，源节点的槽可能一部分键已经保存在目标节点里面。如果在这个时候，<strong>客户端发送命令去获得已经被迁移的槽中的键值对（但是还没有完成重新分片过程）</strong>，就会触发这个错误，这个错误也是被隐藏的，会直接重定向到指定槽。</p>
<p>​    ASK和MOVED错误都会导致客户端重定向，它们的区别区别</p>
<ul>
<li>moved错误代表槽的负责全已经从一个节点到另外一个节点，相当于是迁移后的</li>
<li>ask错误是在迁移过程中发生的</li>
</ul>
<h4 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h4><p>​    Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点用于复制某个主节点，并在复制的主节点下线时，代替下线主节点继续处理命令请求。</p>
<p>​    其复制和故障转移原理和哨兵机制差不多。</p>
<h5 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h5><ol>
<li>复制下线主节点的所有从节点里面，会有一个从节点被选中</li>
<li>被选中的从节点会执行<code>SLAVEOF no one</code>命令</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己</li>
<li>新的主节点会向集群广播一条PONG消息，其他的节点就知道主节点的信息。</li>
<li>新的主节点执行所占槽的命令请求，故障转移完成。</li>
</ol>
<h5 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h5><p>​    基于Raft算法，直接看哨兵就行。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《Redis设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>分布式</tag>
        <tag>主从复制</tag>
        <tag>哨兵</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis服务器</title>
    <url>/posts/5edc58a6/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章通过命令请求执行过程，<code>serverCron</code>函数介绍，服务器初始化三个方面介绍一下Redis服务器。</p>
</blockquote>
<span id="more"></span>

<h4 id="服务器介绍"><a href="#服务器介绍" class="headerlink" title="服务器介绍"></a>服务器介绍</h4><p>​    Redis服务器负责与多个客户端建立网络连接，处理客户端发送和命令请求，在数据库宏保存客户端执行命令所产生的的数据，并通过资源管理来维持服务器自身的运转。</p>
<p>​    本章第一节以SET命令为例，介绍一个命令的执行流程；第二节介绍事件中的<code>serverCron</code>函数；最后介绍如何初始化启动服务器。</p>
<h4 id="命令请求执行过程"><a href="#命令请求执行过程" class="headerlink" title="命令请求执行过程"></a>命令请求执行过程</h4><p>命令请求和执行在客户端看来很简单：只需要输入正确的命令，然后就能看到服务器返回的结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET KEY VALUE</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>其实这些需要的步骤如下</p>
<ul>
<li><p>客户端发送请求</p>
<p>通过网络套接字连接将命令发送给服务器，传输过程可能要先将会命令转换成协议。</p>
</li>
<li><p>服务器接收并读取请求</p>
<p>命令到来，该连接套接字变得可读，因此服务器将调用命令请求处理器来执行一下操作：</p>
<ul>
<li>读取命令请求，并将其保存到客户端状态的输入缓冲区里面。</li>
<li>分析命令请求，将其保存到客户端状态中</li>
<li>命令执行<ul>
<li>查找命令实现</li>
<li>执行预备操作，将命令执行函数的参数全部准备好</li>
<li>调用命令函数</li>
<li>执行后续工作，比如添加日志</li>
</ul>
</li>
<li>结果回复</li>
<li>客户端打印回复结果</li>
</ul>
</li>
</ul>
<h4 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a><code>serverCron</code>函数</h4><p>Redis中该函数每隔100ms就执行一遍，该函数负责管理服务器的资源，并保持服务器自身的良好运转。以下就对该函数的功能进行一个介绍。</p>
<ul>
<li><p>更新服务器时间缓存</p>
<ul>
<li>获悉当地时间，注意系统调用的时间</li>
<li>更新LRU时钟，LRU时钟是该对象最后一次访问的时间</li>
</ul>
</li>
<li><p>更新服务器每秒执行命令的次数</p>
<ul>
<li>估算出最近1s命令的执行次数，是通过抽样估算。</li>
</ul>
</li>
<li><p>更新服务器内存峰值记录</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">size_t</span> stat_peak_memory</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该参数记录着内存的使用峰值情况。</p>
</li>
<li><p>处理SIGTERM信号</p>
<p>该信号关联处理器<code>sigtermHandler</code>函数，这个信号处理器负责在服务器接收SIGTERM信号，打开服务器状态的<code>shutdown_asap</code>标识，每次<code>serverCron</code>函数执行都会检查这个标识，并根据属性的值决定是否关闭服务器。</p>
</li>
<li><p>管理客户端资源</p>
<ul>
<li>检查客户端是否超时</li>
<li>检查客户端的输入缓冲区大小</li>
</ul>
</li>
<li><p>管理数据库资源</p>
<p>执行<code>databaseCron</code>,这个函数会对数据库进行检查，比如删除过期键，对字典进行收缩等。这个在数据库那章已经讲过了。</p>
</li>
<li><p>执行持久化操作</p>
<ul>
<li>执行被延迟的BGREWRITEAOF</li>
<li>检查持久化操作的运行状态</li>
<li>将AOF缓冲区中的内容写入AOF文件</li>
</ul>
</li>
<li><p>关闭异步客户端</p>
<p>将输出缓冲区大小超过限制的客户端关闭</p>
</li>
<li><p>增加<code>cronsLoops</code>计数器的值</p>
<p>记录该函数执行次数</p>
</li>
</ul>
<h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><p>服务器初始化会经过一下几步</p>
<ul>
<li><p>初始化服务器状态结构</p>
<p>创建一个<code>redisServer</code>类型的实例变量作为服务器的状态，并为结构中各个属性设置初始值。</p>
<ul>
<li>设置服务器运行ID</li>
<li>设置服务器的默认运行频率</li>
<li>设置服务器的默认配置文件路径</li>
<li>设置服务器的端口号</li>
<li>设置服务器的持久化条件</li>
<li>初始化LRU时钟</li>
<li>创建命令表</li>
</ul>
</li>
<li><p>载入配置选项</p>
<p>可以手动使用指定文件中的参数配置服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server redis.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果redis.conf里面有一些参数配置， 那么redis-server会载入里面的参数配置选项</span></span><br></pre></td></tr></table></figure>

<p>对server状态进行更新之后，服务器会进入下一个阶段</p>
</li>
<li><p>初始化服务器数据结构</p>
<p>在第一个状态结构中，只创建了命令表，除命令表之外，服务器状态还包含其他数据结构。比如</p>
<ul>
<li>clients链表：与该服务器连接的客户端状态</li>
<li>server.db数组，数组包含了数据库</li>
<li>channel字典，包含订阅消息</li>
<li>LUA环境</li>
<li>慢查询日志属性</li>
</ul>
<p>使用<code>initServer</code>会初始化这些数据结构。该函数执行完毕之后，服务器将在日志中打印出Redis图标，以及版本号信息。</p>
</li>
<li><p>还原数据库状态</p>
<p>查看数据库是否开启持久化功能，如果开启则进行还原数据库状态。</p>
</li>
<li><p>执行时间循环</p>
<p>这个时候开始执行四件循环</p>
</li>
</ul>
<p>总的来说就是</p>
<ol>
<li>初始化状态</li>
<li>配置服务器信息</li>
<li>初始化数据结构</li>
<li>还原数据库</li>
<li>执行事件循环</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事件</title>
    <url>/posts/912da1e/</url>
    <content><![CDATA[<blockquote>
<p>Redis是一个事件驱动程序，本篇文章来介绍下Redis中的事件，其实事件是个通用说法。通过本章的记录，会发现Redis和之前自己实现的Webserver的reactor事件驱动没区别</p>
</blockquote>
<span id="more"></span>

<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>​    Redis是一个<strong>事件驱动</strong>程序，服务器需要处理以下两类事件：</p>
<ul>
<li>文件事件：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而<strong>文件事件就是服务器对套接字操作的抽象。</strong>服务器与客户端的通信会产生文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li>
<li>时间事件：Redis服务器中的一些操作需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li>
</ul>
<h4 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h4><p>​    Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器。</p>
<ul>
<li>文件事件处理器使用的I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行<strong>连接应答、读取、写入、关闭</strong>等操作时，与操作相关的文件事件就会产生，这时文件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p><strong>虽然文件事件处理器是以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件既能实现高性能的网络通信模型，又可以很好地与Redis服务器中其他同样以单线程运行的模块对接，保证了Redis内部单线程设计的简单性。</strong></p>
<ol>
<li><p><strong>文件事件处理器的构成</strong></p>
<p>文件事件处理器四个组成部分：套接字、I/O多路复用程序、文件事件分派器以及事件处理器。</p>
<img src="/posts/912da1e/%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8.png" class title="文件事件处理器">

<ul>
<li>套接字：文件事件是对套接字操作的抽象，每当一个套接字准备好执行操作时，就会产生一个文件事件。</li>
<li>I/O多路复用程序：负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。 在Redis服务器中，套接字的分派是有序，同步的。只有当上一个套接字处理完，I/O多路复用程序才会向文件分派器传送下一个套接字。</li>
<li>文件分派器： 根据传送过来的套接字产生的事件类型，调用相应的事件处理器。</li>
</ul>
</li>
<li><p><strong>I/O多路复用程序的实现</strong></p>
<p>Redis的I/O多路复用程序的所有功能都是包装常见的<code>select</code>,<code>epoll</code>,<code>evport</code>,<code>kqueue</code>这些I/O多路复用函数库来实现的。每个函数库在Redis源码对应一个文件。这些文件构成了Redis的I/O多路复用程序的底层实现，这些底层是可以互换的。程序会在编译时自动选择系统中性能最高的I/O多路复用函数库来作为Redis的多路复用底层实现。</p>
</li>
<li><p><strong>事件类型</strong></p>
<ul>
<li><code>AE_READABLE</code>:当套接字变得可读时（客户端对套接字执行write操作或者是close操作），或者有新的可应答套接字出现时（connect操作），套接字产生<code>AE_READABLE</code>事件。</li>
<li><code>AE_WRITABLE</code>: 当套接字变得可写时（客户端对套接字执行read操作），套接字产生该事件。</li>
</ul>
<p>I/O多路复用程序允许服务器同时监听可读和可写事件。但是同时到来的时候，<strong>服务器将先读套接字，再写套接字。</strong></p>
</li>
<li><p><strong>文件处理器</strong></p>
<p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：</p>
<ul>
<li><p>为了对连接服务器的各个客户端进行应答，服务器要为<strong>监听套接字关联连接应答处理器。</strong>（包装accept函数）</p>
</li>
<li><p>为了接收客户端传来的命令请求，服务器要为<strong>客户端套接字关联命令请求处理器。</strong>（包装read函数）</p>
</li>
<li><p>为了向客户端返回命令执行结果，服务器要为<strong>客户端套接字关联命令回复处理器。</strong>（包装write函数）</p>
</li>
<li><p>当主服务器和从服务器进行复制时，主服务器都<strong>需要关联特别为复制功能编写的复制处理器</strong>。</p>
</li>
</ul>
</li>
</ol>
<h4 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h4><p>​    Redis时间事件分为以下两类：</p>
<ul>
<li>定时事件：让一段程序在指定的时间之后执行一次。</li>
<li>周期性事件：让一段程序每隔指定时间就执行一次。</li>
</ul>
<p>​    一次时间事件主要由三个属性组成：</p>
<ul>
<li>id：服务器为时间事件创建全局唯一ID，ID是自增的。</li>
<li>when： 毫秒精度的Unix时间戳，记录了时间事件的到达时间。</li>
<li><code>timeProc</code>： 时间事件处理器，一个函数。当时间时间到达时，服务器就会调用相应处理器来处理事件。</li>
</ul>
<blockquote>
<p>Q: 如何区别定时事件和周期性事件？</p>
<p>A:     事件处理器返回AE_NOMORE的整数值，那么这个事件为定时事件，如果返回事件整数值，那么为周期性事件。</p>
</blockquote>
<p>如果为定时事件，那么事件在到达一次之后就会被删除。</p>
<p>如果为周期性时间，那么服务器根据事件处理器返回的值对时间事件的when属性进行更新，并继续执行。</p>
<p>​    服务器将所有的时间事件都放在一个无序（指when属性的无序，id是逆序的）链表中。当时间事件执行器运行的时候，必须遍历整个时间事件，这样才能确保服务器中所有已到达的时间事件会被处理。</p>
<p>其伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processTimeEvents</span>():</span></span><br><span class="line">    <span class="comment"># 遍历服务器中的所有时间事件</span></span><br><span class="line">    <span class="keyword">for</span> time_event <span class="keyword">in</span> all_time_event():</span><br><span class="line">        <span class="comment"># 检查事件是否已经到达</span></span><br><span class="line">        <span class="keyword">if</span> time_event.when &lt;= unix_ts_now():</span><br><span class="line">            <span class="comment"># 事件已经到达</span></span><br><span class="line">            <span class="comment"># 执行时间事件处理器</span></span><br><span class="line">            reval = time_event.timeProc()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 定时事件</span></span><br><span class="line">            <span class="keyword">if</span> reval == AE_NOMORE:</span><br><span class="line">                <span class="comment"># delete</span></span><br><span class="line">                delete_time_event_for_server(time_event)</span><br><span class="line">               </span><br><span class="line">            <span class="comment"># 周期事件: 根据reval更新when属性</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                update_when(time_event, retval)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间事件应用实例：<code>serverCron</code>函数</p>
<p><strong>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行</strong>，这些定期操作由<code>serverCron</code>函数执行，它的主要工作包括：</p>
<ul>
<li>更新服务器的各类统计信息，如时间、内存占用、数据库占用的情况等。</li>
<li>清理数据库中的过期键值对。</li>
<li>关闭和清理链接失效的客户端。</li>
<li>尝试进行AOF和RDB持久化操作。</li>
<li>如果服务器是主服务器，那么对从服务器进行定期同步。</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试。</li>
</ul>
<p>（<code>serverCron</code>函数每10s运行一次）</p>
</li>
</ul>
<h4 id="事件的调度和执行"><a href="#事件的调度和执行" class="headerlink" title="事件的调度和执行"></a>事件的调度和执行</h4><p>​    当服务器中同时存在文件事件和时间事件两种事件类型的时候，先处理什么事件呢？</p>
<p>事件的调度和执行函数见下面伪代码：(这个也是服务器的主函数)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aeProcessEvents</span>():</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算最接近的时间事件还有多少毫秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    <span class="comment"># 事件已到达，设置为0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 根据remaind_ms,创建相应的timeval结构    </span></span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 阻塞并等待文件事件产生，最大阻塞事件由传入的timeval结构决定</span></span><br><span class="line">    <span class="comment"># 如果remaind_ms = 0 那么直接返回不阻塞</span></span><br><span class="line">    aeApiPoll(timeval)   <span class="comment"># epoll_wait</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先处理所有已产生的文件事件</span></span><br><span class="line">    processFileEvents()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再处理所有已到达的时间事件</span></span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure>



<img src="/posts/912da1e/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" class title="服务器运行流程">

<p>​                                                                                                        </p>
<p>事件调度和执行的规则：</p>
<ul>
<li><code>aeApiPoll</code>最大阻塞事件由到达时间最接近的时间事件决定，这样该函数阻塞事件最短。</li>
<li>文件事件随机出现，如果处理完该事件没有其它事件出现，那么会等待并文件事件。随着文件事件不断执行，时间文件不断逼近，服务器会开始处理时间事件。</li>
<li>对文件事件和时间事件的处理都是同步、有序、原子地执行，服务器不会中途中断事件处理，也不会对事件进行抢占，他们只会尽可能的减少<strong>阻塞时间</strong>。</li>
<li><strong>由于时间事件在文件事件之后处理，并且事件之间不会出现抢占，可能实际处理时间会比时间事件设置的时间稍晚一点</strong>。</li>
</ul>
<h4 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul>
<li>Redis是一个事件驱动时间，。服务器处理的事件分为时间事件和文件事件。</li>
<li><strong>文件事件处理器是基于Reactor模型</strong>。</li>
<li>文件事件是对套接字操作的抽象：套接字状态有三种<strong>（可应答acceptable，可读readable，可写writable）</strong></li>
<li>文件事件分为可读和可写事件两种。</li>
<li>时间事件分为定时事件和周期性事件。</li>
<li>服务器一般只执行一个时间事件<code>serverCron</code>函数，并且改为周期性事件。</li>
<li>文件事件和时间事件是合作关系，服务器会轮流处理两种事件，不会发生抢占。</li>
<li>时间事件实际处理时间会比设置的时间稍晚一点。</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title>AOF持久化</title>
    <url>/posts/e28a809/</url>
    <content><![CDATA[<blockquote>
<p>上一篇文章介绍了RDB持久化，RDB持久化是通过保存数据库中的键值对来记录数据库状态。RDB的本质是生成快照，适合当做备份，但可追加操作性不强。本篇文章就来介绍一下Redis另外一种持久化方法，AOF持久化。</p>
</blockquote>
<span id="more"></span>



<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>​    RDB持久化是通过保存数据库中的键值对来记录数据库状态不同。AOF持久化是通过保存Redis服务器所执行<strong>写命令</strong>来记录数据库状态。</p>
<p>​    服务器在启动的时候，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态。</p>
<p>​    本章将介绍AOF持久化功能，说明AOF文件的写入、保存、载入等操作的实现原理。然后再介绍AOF重写功能以及实现原理。</p>
<h4 id="AOF持久化实现"><a href="#AOF持久化实现" class="headerlink" title="AOF持久化实现"></a>AOF持久化实现</h4><p>​    AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p>
<ul>
<li><p>命令追加</p>
<p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line"> 	<span class="comment">// AOF Buffer</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>文件写入与同步</p>
<p>​    Redis的服务器进程就是一个事件循环(loop), 这个循环中的<strong>文件事件</strong>负责接收客户端的命令请求，以及向客户端发送命令回复。而<strong>时间事件</strong>则执行定时运行的函数。</p>
<p>​    在文件事件中会有写命令，使得内容被追加到缓冲区中，在服务器每次结束一个时间循环之前，它都会调用<code>flushAppendOnlyFile</code>函数，考虑将缓冲区中的内容写入和保存到AOF文件中。</p>
<p>​    <code>flushAppendOnlyFile</code>函数根据由服务器配置的<code>appendfsync</code>选项的值来决定，有三种行为。</p>
<table>
<thead>
<tr>
<th align="center"><code>appendfsync</code>选项值</th>
<th align="center"><code>flushAppendOnlyFile</code>函数的行为</th>
<th>效率</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>always</code></td>
<td align="center">将<code>aof_buf</code>缓冲区中所有内容<strong>写入并同步</strong>到AOF文件</td>
<td>慢</td>
</tr>
<tr>
<td align="center"><code>everysec</code></td>
<td align="center">将<code>aof_buf</code>缓冲区中所有内容<strong>写入</strong>到AOF文件，如果上次同步时间距离现在超过1s，那么再次进行同步。<strong>同步操作是由一个线程专门负责执行的。</strong></td>
<td>适中</td>
</tr>
<tr>
<td align="center"><code>no</code></td>
<td align="center">将<code>aof_buf</code>缓冲区中所有内容<strong>写入</strong>到AOF文件，<strong>但并不对AOF文件进行同步，何时同步由操作系统来决定。</strong></td>
<td>快</td>
</tr>
</tbody></table>
<p>这个选项值默认是<code>everysec</code></p>
</li>
</ul>
<h4 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h4><p>​    因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p>
<p>​    Redis读取AOF文件并还原数据库状态的详细步骤如下：</p>
<ol>
<li>创建一个不带网络连接的伪客户端：因为Redis命令只能在客户端上下文中执行， 而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器直接使用一个为客户端来执行AOF文件中写命令的效果和真实客户端效果相同。</li>
<li><strong>从AOF文件中分析并读取一条写命令</strong></li>
<li><strong>使用伪客户端执行被读出的写命令</strong></li>
<li>一直执行2和3，知道AOF中命令全部处理完。</li>
</ol>
<h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><blockquote>
<p>Q :  为什么要进行AOF重写</p>
</blockquote>
<p>​    因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件体积越来越大。这样会对AOF还原的效率产生影响，甚至会对服务器产生影响。</p>
<p>​    为了解决AOF文件体积膨胀问题，Redis提供了AOF文件重写功能。通过该功能，Redis服务器创建一个新的AOF文件替代现在的AOF文件，<strong>两个文件的数据库状态相同，但是新AOF文件不会包含任何浪费空间的冗余命令</strong>。</p>
<ul>
<li><p>实现AOF重写</p>
<p>​    <strong>AOF重写并不需要对现有AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</strong></p>
<p>​    <strong>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。</strong></p>
<p>由于新生成的AOF文件只包含还原当前数据库状态所必须的命令，所以新AOF文件不会浪费任何硬盘空间。</p>
<blockquote>
<p>注意： 在大部分情况下，大家都是直接用一条命令设置一个键的值，但是如果这个值的元素数量超过了<code>redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD</code> 常量（一般这个常量为64），重写程序则会用多条命令来记录键的值。</p>
</blockquote>
</li>
<li><p>AOF后台重写（BGREWRITEAOF命令)</p>
<p>AOF重写程序需要进行大量写入操作，因此Redis决定将该程序放到子进程里执行，这样的话有两个优点</p>
<ol>
<li><strong>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</strong></li>
<li>子进程带有服务器进程的数据副本，<strong>使用子进程而不是线程，可以在避免使用锁的情况下，保证数据安全性。</strong></li>
</ol>
<blockquote>
<p>Q：在子进程重写的时候，服务器有写命令执行怎么办？</p>
<p>A:   这里提供了一个AOF重写缓冲区，这个缓冲区创建子进程之后开始使用，当Redis服务器执行完一个命令之后，它会同时将这个写命令发送给AOF缓冲 区和AOF重写缓冲区。‘</p>
</blockquote>
<p>这里保证在AOF重写的时候，服务器执行的所有写命令都被记录到AOF重写缓冲区。等子进程AOF重写之后，会给父进程发送一个信号，父进程收到信号，会调用一个信号处理函数，并执行一下工作：</p>
<ol>
<li>将AOF重写缓冲区的所有内容写入到新的AOF文件中，这是新的AOF文件保存的数据库文件和服务器当前的数据库状态一致。</li>
<li>对新的AOF文件进行改名，<strong>原子</strong>的<strong>覆盖</strong>现有的AOF文件。</li>
</ol>
<p>在这个过程中，<strong>只有信号处理函数会对父进程造成阻塞，其他部分都不会造成阻塞。</strong></p>
</li>
</ul>
<h4 id="AOF的优缺点"><a href="#AOF的优缺点" class="headerlink" title="AOF的优缺点"></a>AOF的优缺点</h4><p>AOF优点：</p>
<ul>
<li>AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）</li>
<li>AOF文件易懂，都是命令操作，通过改变AOF文件，用户可以方便快捷的将Redis恢复到想要的状态。比如AOF最后直接使用了Flush All操作，redis想要恢复的话，直接将AOF文件的最后这个命令删除再导入即可。</li>
</ul>
<p>AOF缺点：</p>
<ul>
<li>对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积</li>
<li>关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此</li>
</ul>
<p>和RDB的对比</p>
<ul>
<li>RDB是一个快照持久化，它的持久化并不耐久，因为如果服务器因为某些状况停机了的话，服务器将丢失最近写入、仍未保存到快照中的那些数据。</li>
<li>如果数据需要追求耐久性的话，那么使用AOF，即使是那些毁坏状态，也会记录下来。</li>
</ul>
<h4 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul>
<li>AOF文件通过保存所有修改数据的写命令请求来记录数据库状态</li>
<li>AOF文件中的所有命令都以<strong>Redis命令请求协议</strong>的格式保存</li>
<li>命令请求会先保存到AOF缓冲区，再定期的写入并同步到AOF文件中</li>
<li><code>appendfsync</code>选项的不同值对AOF持久化功能的安全性和Redis服务器的性能有很大影响</li>
<li>服务器只要载入并重新执行保存唉AOF文件中的命令，就可以还原数据库本来的状态</li>
<li>AOF重写是产生一个效果相同但是体积更小的AOF文件</li>
<li><strong>AOF重写和上一个AOF文件无关，是根据目前数据库状态来实现的。无需对上一个AOF文件进行任何的操作。</strong></li>
<li>在执行BGREWRITEAOF命令时，Redis会设置一个AOF重写缓冲区。重写完成之后，该缓冲区的内容会追加(APPEND)到新的AOF文件中。最后新的AOF文件会原子性的覆盖旧的AOF文件，以此完成AOF文件重写操作。</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>《Redis设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>持久化</tag>
        <tag>AOF</tag>
      </tags>
  </entry>
  <entry>
    <title>RDB持久化</title>
    <url>/posts/5f64b03b/</url>
    <content><![CDATA[<blockquote>
<p>为什么会提到持久化功能？</p>
<p>这是因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，如果不想办法将存储在内存中的数据库状态保存在磁盘中的话，一旦服务器进程退出，服务器中的数据库状态也会发生变化。</p>
<p>因此为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中数据库状态保存到磁盘里面，避免数据意外丢失。</p>
<p>RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，RDB文件是保存在硬盘里面的，只要RDB文件还在，Redis服务器就可以用它来还原数据状态</p>
</blockquote>
<span id="more"></span>



<h4 id="RDB文件的创建和载入"><a href="#RDB文件的创建和载入" class="headerlink" title="RDB文件的创建和载入"></a>RDB文件的创建和载入</h4><ul>
<li>创建RDB文件</li>
</ul>
<p>​    有两个Redis命令可以用于生成RDB文件，一个是SAVE，一个是BGSAVE。二者区别是什么？</p>
<p>​    SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何请求。</p>
<p>​    BGSAVE命令会派生出一个子进程，然后有子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</p>
<p> （那么这个子进程处理完了如何通知父进程？）——  <strong>靠信号</strong>！</p>
<ul>
<li><p>载入RDB文件</p>
<p>Redis没有载入RDB文件的命令。其载入工作是在服务器启动时自动执行的，服务器在启动检测到RDB文件存在，它就会自动载入RDB文件。</p>
<p>此外，由于AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p>
<ul>
<li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li>
<li>只有在AOF持久化处于关闭功能时，服务器才会使用RDB文件来还原数据库状态。</li>
</ul>
<p><strong>服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入完成。</strong></p>
</li>
<li><p>SAVE, BGSAVE命令</p>
<p>​    当使用SAVE命令时，服务器阻塞了。因此一般来说SAVE命令不用。SAVE命令可以作为执行转储最新数据集的最后手段。</p>
<p>​    当使用BGSAVE命令时，服务器不能使用SAVE命令，也不能使用BGSAVE。防止两个命令产生竞争条件。</p>
<p>​    当使用BGSAVE命令时，服务器也不能用BGREWRITEAOF命令，这不是因为会产生竞争条件，而是二者都是创建子进程来执行对磁盘进行大量写入操作，这样的话浪费资源。</p>
</li>
</ul>
<h4 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h4><p>​    由于BGSAVE可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的Save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</p>
<p>​    用户可以设置多个保存条件，只要其中一个满足，BGSAVE命令就会被执行。这个保存条件见下结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 记录了保存条件的数组</span></span><br><span class="line">    <span class="comment">// 数组中的每个元素都是一个saveparam结构，每个saveparam结构中都保存着一个save选项设置的保存条件。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> * <span class="title">saveparams</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上一次执行保存的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastsave;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">saveparams[0]</th>
<th align="center">saveparams[1]</th>
<th align="center">saveparams[2]</th>
</tr>
</thead>
<tbody><tr>
<td align="center">seconds 900</td>
<td align="center">seconds 300</td>
<td align="center">seconds 60</td>
</tr>
<tr>
<td align="center">changes 1</td>
<td align="center">changes 10</td>
<td align="center">changes 10000</td>
</tr>
</tbody></table>
<p>​                                                                    (服务器状态中的保存条件)</p>
<p>除了saveparams数组之外，服务器还维持着一个dirty计数器，以及一个<code>lastsave</code>属性:</p>
<ol>
<li>dirty计数器记录距离上次成功执行SAVE或者BGSAVE命令之后，服务器对数据库状态<strong>（服务器中的所有数据库）</strong>进行了多少次修改。</li>
<li><code>lastsave</code>属性是一个时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</li>
</ol>
<p>针对这些保存条件，Redis服务器周期性操作函数会在默认情况下每隔100ms执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否满足，如果满足的话，就执行BGSAVE命令。</p>
<h4 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h4><p>​    一个完整的RDB文件如下表所示：(RDB文件是<strong>一个二进制文件</strong>)</p>
<table>
<thead>
<tr>
<th>结构项</th>
<th align="center">REDIS</th>
<th align="center">db_version</th>
<th align="center">databases</th>
<th align="center">EOF</th>
<th align="center">check_sum</th>
</tr>
</thead>
<tbody><tr>
<td>长度（bytes)</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">0-xxxx</td>
<td align="center">1</td>
<td align="center">8</td>
</tr>
<tr>
<td>存储数据</td>
<td align="center">“REDIS”</td>
<td align="center">字符串整数如”0006“，代表第六版</td>
<td align="center">存储0到多个数据库，<strong>文件结构核心</strong></td>
<td align="center">标志正文内容结束</td>
<td align="center">校验和</td>
</tr>
</tbody></table>
<p>databases: 每个非空数据库在RDB文件中都可以保存为三个部分</p>
<table>
<thead>
<tr>
<th align="center">SELECTDB</th>
<th align="center">db_number</th>
<th align="center">key_value_pairs</th>
</tr>
</thead>
<tbody><tr>
<td align="center">常量，1byte，标识作用</td>
<td align="center">可能是1/2/5bytes（数据库号码）</td>
<td align="center">保存着该数据库中所有键值对</td>
</tr>
</tbody></table>
<p>key_value_pairs： 这个部分保存了一个或多个键值对，如果键值对带有过期时间的话，那么也会保存进去。</p>
<p>如果是不带过期键的键值对的话，在RDB文件中由三个部分组成：</p>
<table>
<thead>
<tr>
<th align="center">TYPE</th>
<th align="center">key</th>
<th align="center">value</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1bytes, 记录value的类型</td>
<td align="center">字符串对象</td>
<td align="center">值对象</td>
</tr>
</tbody></table>
<p>如果有过期键，那么由五个部分组成：</p>
<table>
<thead>
<tr>
<th align="center">EXPIRETIME_MS</th>
<th align="center">ms</th>
<th align="center">TYPE</th>
<th align="center">key</th>
<th align="center">value</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1byte，常量，标识作用</td>
<td align="center">8bytes，过期时间（以毫秒为单位的UNIX时间戳）</td>
<td align="center">1byte, 记录value的类型</td>
<td align="center">字符串对象</td>
<td align="center">值对象</td>
</tr>
</tbody></table>
<p>针对value对象，会有一个<strong>编码</strong>。（这个编码是第八章中介绍过的）</p>
<p><em>编码大概意思就是根据Type值不同，选择不同的对象结构。对于字符串结构来说，如果长度较短（小于等于20字节），原样存储，如果长度较大，那么就压缩后存储。</em></p>
<p>这里有个细节，由于RDB是二进制文件，如果是INTSET整数集合编码的话，RDB文件保存这种对象的方法是，<strong>先将整数集合转换为字符串对象</strong>，然后将这个字符串对象保存到RDB文件里面</p>
<p><strong>（ZIPLIST编码的列表，哈希表或者有序集合都是先转换成一个字符串对象，再将该字符串对象保存到RDB文件中。）</strong></p>
<h4 id="分析RDB文件"><a href="#分析RDB文件" class="headerlink" title="分析RDB文件"></a>分析RDB文件</h4><p>使用下面的命令对保存了的RDB文件进行分析</p>
<blockquote>
<p>od     -c     temp.rdb    (ASCII码分析)</p>
</blockquote>
<blockquote>
<p>0000000   R   E   D   I   S   0   0   0   9 372  \t   r   e   d   i   s<br>0000020   -   v   e   r 005   5   .   0   .   7 372  \n   r   e   d   i<br>0000040   s   -   b   i   t   s 300   @ 372 005   c   t   i   m   e 302<br>0000060   &gt;   o   D   ` 372  \b   u   s   e   d   -   m   e   m 302 210<br>0000100 346  \a  \0 372  \f   a   o   f   -   p   r   e   a   m   b   l<br>0000120   e 300  \0 376  \0 373 001  \0 016 006   f   r   u   i   t   s<br>0000140 001   “   “  \0  \0  \0 031  \0  \0  \0 003  \0  \0 005   a   p<br>0000160   p   l   e  \a 006   b   a   n   a   n   a  \b 006   c   h   e<br>0000200   r   r   y 377 377 226 312 026 300   W   f   t   d<br>0000215</p>
</blockquote>
<blockquote>
<p>od     -cx    temp.rdb        (十六进制分析)</p>
</blockquote>
<blockquote>
<p>0000000   R   E   D   I   S   0   0   0   9 372  \t   r   e   d   i   s<br>0000020   -   v   e   r 005   5   .   0   .   7 372  \n   r   e   d   i<br>0000040   s   -   b   i   t   s 300   @ 372 005   c   t   i   m   e 302<br>0000060   &gt;   o   D   ` 372  \b   u   s   e   d   -   m   e   m 302 210<br>0000100 346  \a  \0 372  \f   a   o   f   -   p   r   e   a   m   b   l<br>0000120   e 300  \0 376  \0 373 001  \0 016 006   f   r   u   i   t   s<br>0000140 001   “   “  \0  \0  \0 031  \0  \0  \0 003  \0  \0 005   a   p<br>0000160   p   l   e  \a 006   b   a   n   a   n   a  \b 006   c   h   e<br>0000200   r   r   y 377 377 226 312 026 300   W   f   t   d<br>0000215</p>
</blockquote>
<p>认真分析里面的东西。大概就明白了RDB文件如何存储。</p>
<h4 id="RDB持久化优缺点"><a href="#RDB持久化优缺点" class="headerlink" title="RDB持久化优缺点"></a>RDB持久化优缺点</h4><p>优点</p>
<ul>
<li>RDB是一个非常紧凑（有压缩）的文件,它保存了某个时间点的数据,非常适用于数据的备份。</li>
<li>RDB作为一个非常紧凑（有压缩）的文件，可以很方便传送到另一个远端数据中心 ，非常适用于灾难恢复.</li>
<li>RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化Redis的性能.</li>
<li>与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些.</li>
</ul>
<p>缺点</p>
<ul>
<li>Redis意外宕机时，会丢失部分数据</li>
<li>当Redis数据量比较大时，fork的过程是非常耗时的，fork子进程时是会阻塞的，在这期间Redis 是不能响应客户端的请求的。</li>
</ul>
<h4 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul>
<li>RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。</li>
<li>SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。</li>
<li>BGSAVE命令由子进程执行保存操作，所以该命令不会阻塞服务器。</li>
<li>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会执行BGSAVE命令。</li>
<li>RDB文件是一个经过压缩的二进制文件，由多个部分组成。</li>
<li>对于不同类型的键值对，RDB文件会使用不同的方式来保存它们。</li>
</ul>
<h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><ul>
<li>当我设置几个键值对之后保存RDB文件之后，重启这个客户端，想要修改这几个保存的键值对，发现会出现一下错误。</li>
</ul>
<blockquote>
<p>MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error.</p>
</blockquote>
<p>Redis被配置为保存数据库快照，但它目前不能持久化到硬盘。用来修改集合数据的命令不能用。请查看Redis日志的详细错误信息。</p>
<p>网上的原因：</p>
<p>​    强制关闭Redis快照导致不能持久化。本质上是内存不足导致的。因此需要进行相关的内存处理：</p>
<p><strong>修改Redis config 修改快照备份的目录，即将快照重定向到其他目录 修改主机内存配置</strong></p>
<p>方案1：将<code>stop-writes-on-bgsave-error</code>设置为no，这个方式是直接关闭<strong>保存持久化快照</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt;<span class="built_in"> config </span><span class="builtin-name">set</span> stop-writes-on-bgsave-<span class="builtin-name">error</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure>

<p>这个在生产中可能会出现一些问题，这个然而这个方法治标不治本，他只是让我们“忽略”他而已，使用之前需要确认<code>bgsave</code>失败的原因，比如当Redis用于缓存、会话的场景的时候，这么做是允许的</p>
<p>方案2： 将备份的rdb文件，重定向到目录</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">CONFIG SET dir /tmp/some/directory/other/than/var</span><br><span class="line">CONFIG SET dbfilename temp.rdb</span><br></pre></td></tr></table></figure>

<p>使用这个命令之后，需要确保<code>bgsave_in_progress</code>返回结果是<code>0</code></p>
<p>方案3： 在内核运行时动态地修改内核的运行参数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&#x27;vm.overcommit_memory = 1&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl vm.overcommit_memory=<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>《Redis设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>RDB</tag>
        <tag>持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库</title>
    <url>/posts/eb52a7b2/</url>
    <content><![CDATA[<blockquote>
<p>在介绍了Redis基本数据结构，Redis对象之后，本章来全面且简要的介绍一下Redis数据库。</p>
</blockquote>
<span id="more"></span>



<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>​    本章将对Redis服务器的数据库进行详细介绍。说明服务器保存数据库的方法，客户端切换数据库的方法，数据库保存键值对的方法，以及针对数据库的添加、删除、查看、更新操作的实现方法等。此外，服务器针对键的过期的方法。</p>
<h4 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h4><p>​    Redis服务器将所有数据库都保存在服务器状态结构的db数组中。每一个db数组项代表着一个服务器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中所有的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">  	<span class="comment">// 服务器的数据库数量, 有服务器配置的database选项决定，默认情况下，该选项的值为16.即redis服务器会创建16个数据库。</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h4><p>​    每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库会成为这些命令的操作对象。 <strong>默认情况下，操纵的都是0号数据库。但是客户端可以用SELECT命令切换数据库。</strong></p>
<p>为什么可以这样呢？ 这是因为在服务器内部，还有另外一个结构标志着客户端的状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">    <span class="comment">// 该指针指向redisServer.db数组其中的一个项，这个项就是客户端的目标数据库。</span></span><br><span class="line">    <span class="comment">// 使用SELECT 2，可以将目标数据库改为2号数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h4><p>​    Redis是一个键值对数据库服务器。每个数据库都是由一个<code>redisDb</code>结构表示，<strong>其中该结构中的<code>dict</code>字典保存了数据库中的所有键值对，我们将这个字典称之为键空间。（键空间包括键和值）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>键空间的键就是数据库的键，每个键都是一个字符串对象。</li>
<li>键空间的值就是数据库的值，这个值可以是五种对象的任意一个。</li>
</ul>
<p>由于键空间是字典结构，那么可以对这个字典进行添加删除更新取值等操作。</p>
<ul>
<li><p>添加新建：SET命令等（如HSET）</p>
</li>
<li><p>删除键：DEL命令</p>
</li>
<li><p>更新键：SET命令等（如HSET）</p>
</li>
<li><p>对键取值：GET命令等（如LRANGE）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 		命令  键    值</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加</span></span><br><span class="line">redis &gt; SET date &quot;2013.12.1&quot;</span><br><span class="line">OK</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除</span>	</span><br><span class="line">redis &gt; DEL book</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新</span></span><br><span class="line">redis &gt; SET message &quot;blah blah&quot;</span><br><span class="line">OK</span><br><span class="line">redis &gt; HSET book page 320</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取值</span></span><br><span class="line">redis &gt; GET message</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">redis &gt; LRANGE alphabet 0 -1</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;c&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>其他键操作：如清空数据库的FLUSHDB，返回数据库键数量的DBSIZE命令等。</p>
</li>
<li><p>读写键空间的维护操作</p>
<ul>
<li><p>在读取一个键时（读和写操作都要对键进行读取），<strong>服务器会根据键是否存在更新服务器的键空间命中次数和不命中次数。</strong>（这两个可以在INFO stats命令中查看<code>keyspace_hits</code>属性和<code>keyspace_misses</code>属性中查看。</p>
</li>
<li><p>在读取一个键的之后，服务器会更新键的LRU时间，这个时间可以计算键的闲置时间，使用命令<code>OBJECT idletime&lt;key&gt;</code>可以查看键key的闲置时间。</p>
</li>
<li><p><strong>如果服务器读取一个键时发现这个键已经过期了，那么服务器会先删除这个键，再执行余下的操作。</strong></p>
</li>
<li><p>如果有客户端使用<strong>WATCH</strong>命令监视某个键，那么服务器对该键进行修改之后，会将这个键标记为脏(dirty)，从而让事务注意到这个键已经被修改了。</p>
</li>
<li><p><strong>服务器每次修改一个键之后，都会对脏键计数器增加1，这个计数器会触发服务器的持久化和复制操作</strong></p>
</li>
<li><p>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器会按照配置发送相应的数据库通知。</p>
</li>
</ul>
</li>
</ul>
<h4 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h4><ul>
<li>命令</li>
</ul>
<p>​    通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置<strong>生存时间</strong>(TTL)——在经过指定的时间后，服务器会自动的将这个键给删除。（P是毫秒）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> <span class="built_in">set</span> key value</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> expire key 5</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> get key    // 5秒之内</span></span><br><span class="line">&quot;value&quot;</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> get key 	  // 5秒之后</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>​    同样的，通过EXPIREAT命令或PEXPIREAT命令，客户端可以以秒或者毫秒精度给数据库中的某个键设置<strong>过期时间</strong>（expire time）—— 过期时间是个<strong>时间戳</strong>，当时间到来之后，服务器会自动删除这个键。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> <span class="built_in">set</span> key value</span></span><br><span class="line">ok</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> expireat key 1377257300	  1377257300 是一个时间戳，表示没到这个时间是存在的</span></span><br></pre></td></tr></table></figure>

<p>​    以上两个是生存时间和过期时间命令的用法。现在我们可以去了解下这些命令的实现方式。</p>
<p>实际上，EXPIRE,PEXPIRE, EXPIREAT三个命令都是使用PEXPIREAT命令实现的。他们都会通过一定的转换来得到这个命令。</p>
<ul>
<li><p>过期字典</p>
<p><code>redisDb</code>结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典是过期字典。</p>
<ul>
<li>过期字典的键是一个指针，指向键空间中的某个键对象（即某个数据库键）</li>
<li>过期字典的值是一个long long类型的整数，这个整数保存了键所保存的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li>
</ul>
</li>
<li><p>移除过期时间</p>
<p>通过PERSIST命令可以移除一个键的过期时间（该命令是PEXPIREAT命令的反操作), 在过期字典中查找给定的键，并解除键和值的关联。</p>
</li>
<li><p>计算生存时间</p>
<p>通过TTL/PTTL以秒/毫秒来计算并返回键的剩余生存时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pttl</span>(<span class="params">key</span>):</span></span><br><span class="line">    <span class="comment"># 键不存在</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> redisDb.<span class="built_in">dict</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">2</span></span><br><span class="line">    <span class="comment"># 尝试获得键的过期时间</span></span><br><span class="line">    <span class="comment"># 如果键没有设置过期时间，那么 expire_time_in_ms 将为 None</span></span><br><span class="line">    expire_time_in_ms = redisDb.expires.get(key)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 键没有设置过期时间</span></span><br><span class="line">    <span class="keyword">if</span> expire_time_in_ms <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获得当前时间</span></span><br><span class="line">	now_ms = get_current_unix_timestamp_in_ms()</span><br><span class="line">    <span class="comment"># 过期时间减去当前时间，得出的差就是键的剩余生存时间</span></span><br><span class="line">    <span class="keyword">return</span> (expire_time_in_ms - now_ms)</span><br></pre></td></tr></table></figure></li>
<li><p>过期键的判定</p>
<p>通过检查过期字典，程序可以检查一个给定键是否过期</p>
<ul>
<li>检查给定键是否存在于过期字典： 如果存在，那么取得键的过期时间。</li>
<li>检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期，否则键为过期。</li>
</ul>
</li>
</ul>
<h4 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h4><p>​    上节了解到过期键会保存在过期字典中，那么问题来了，采用什么策略来删除过期键呢？ 以下有三种可能答案</p>
<ol>
<li><strong>定时删除</strong>：在设置键的过期时间时，同时创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</li>
<li><strong>惰性删除</strong>：放任键过期不管，每次从键空间取出键的时候，检查是否过期，如果过期的话那么就删除。</li>
<li><strong>定期删除</strong>：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。</li>
</ol>
<p>其中1和3是主动删除，2是被动删除。</p>
<ol>
<li>定时删除：该策略是对内存最友好的，定时器能够确保过期键尽可能快的被删除，并且释放过期键所占的内存。但是这个是对CPU时间最不友好的，因为删除过期键会占用一部分CPU时间，当CPU时间紧张的时候就可能对服务器性能造成影响。</li>
<li>惰性删除：这个策略和上面的策略相反，对内存最不友好，对CPU时间最友好。</li>
<li>定期删除：该策略是两者策略的一种折中，但是这个难点是如何确定删除操作执行的时长和频率。</li>
</ol>
<h4 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h4><p>​    Redis服务器实际上使用的是惰性删除+定期删除，这样可以合理使用CPU时间和避免浪费内存空间之间取得平衡。</p>
<ul>
<li><p>惰性删除策略的实现</p>
<p>过期键的惰性删除策略由<code>db.c/expireIfNeeded</code>函数实现，所有读写数据库的Redis命令在执行之前会调用该函数对输入键进行检查。</p>
<ul>
<li>如果输入键已经过期，那么<code>expireIfNeeded</code>函数将输入键从数据库中的删除。</li>
<li>如果输入键未过期，那么<code>expireIfNeeded</code>函数不做动作。</li>
</ul>
<p>该函数相当于一个过滤器，可以让真正的命令接触不到过期键。</p>
</li>
<li><p>定期删除策略的实现</p>
<p>过期键的定期删除策略由<code>redis.c/activeExpireCycle</code>函数实现，每当Redis的服务器周期性操作执行时，这个函数都会被调用。它在规定时间内，分多次遍历服务器的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
</li>
</ul>
<h4 id="AOF，RDB和复制功能对过期键的处理"><a href="#AOF，RDB和复制功能对过期键的处理" class="headerlink" title="AOF，RDB和复制功能对过期键的处理"></a>AOF，RDB和复制功能对过期键的处理</h4><ul>
<li><p>针对RDB文件</p>
<ul>
<li><p>生成RDB文件：一言以蔽之，<strong>已过期的键不会被保存到新创建的RDB文件中</strong>。</p>
</li>
<li><p>载入RDB文件：</p>
<p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p>
<ul>
<li>如果服务器是主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入数据库，过期键被忽略。</li>
<li>如果是从服务器模式运行，则无论是否过期，都会直接载入到数据库中。不过，<strong>因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空。</strong>因此不会对从服务器造成影响。</li>
</ul>
</li>
</ul>
</li>
<li><p>针对AOF文件</p>
<ul>
<li><p>AOF写入</p>
<p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但还没有被删除，那么对AOF文件不会造成任何影响。</p>
<p>当过期键被删除之后，AOF会在文件追加一条DEL命令，来显示记录该键被删除。</p>
</li>
<li><p>AOF重写</p>
<p>当重写的时候，那么直接忽略已过期的键即可。</p>
</li>
</ul>
</li>
<li><p>复制模式</p>
<p>当服务器运行在复制模式下，从服务器的过期键删除动作由主服务器控制：</p>
<ul>
<li><p>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</p>
</li>
<li><p>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样处理过期键。</p>
</li>
<li><p>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</p>
</li>
</ul>
</li>
</ul>
<h4 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h4><p>​    数据库通知这个功能可以让客户端通过订阅给定的频道或者模式，来获取数据库中的键的变化，以及数据库中的命令的执行情况。</p>
<p>​    通知分为以下两类：</p>
<ul>
<li>键空间通知：某个键执行了什么命令，关注的主体是键。</li>
<li>键事件通知：某个命令被哪个键执行了，关注的主体是命令。</li>
</ul>
<p>发送通知</p>
<p>​    发送数据库通知的功能是由<code>notify.c/notifyKeyspaceEvent</code>函数实现的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span>* event, robj* key, <span class="keyword">int</span> dbid)</span></span>;</span><br><span class="line"><span class="comment">// type：想要发送通知的类型，程序会根据这个值来判断通知是否就是服务器配置的通知类型，从而决定是否发送通知</span></span><br><span class="line"><span class="comment">// event, key, dbid 分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数通过这三个参数构建一个事件。</span></span><br></pre></td></tr></table></figure>



<h4 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h4><ul>
<li>Redis服务器的所有数据库都保存在<code>redisServer.db</code>数组中，而数据库的数量则由<code>redisServer.dbnum</code>属性保存。</li>
<li>客户端通过修改目标数据库指针，让它指向<code>redisServer.db</code>数组中的不同元素来切换不同的数据库。</li>
<li><strong>数据库主要有dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。</strong></li>
<li><strong>因为数据库由字典构成，所有对数据库的操作都是建立在字典操作的基础上。</strong></li>
<li>数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型。</li>
<li>expires字典的键指向数据库的某一个键，而值则记录了该数据库键的过期时间，是一个以毫秒为单温的UNIX时间戳。</li>
<li>Redis使用惰性删除和定期删除两种策略删除过期键： 惰性删除只在碰到过期键才进行删除工作，定期删除是每隔一段时间主动查找并删除过期键。</li>
<li>执行SAVE和BGSAVE命令所产生的RDB文件不会包含已经过期的键。</li>
<li>执行BGREWRITEAOF命令所产生的重写AOF文件不会包含过期的键。</li>
<li>当一个过期键被删除之后，服务器会追加一条DEL命令在AOF文件末尾，显式删除过期键。</li>
<li>当<em><strong>主服务器</strong></em>删除一个过期键之后，它会向所有<em><strong>从服务器</strong></em>发送一条DEL命令，显式删除过期键。</li>
<li>从服务器发现过期键也不会删除它，而是等待主服务器发来DEL命令，才会删除它。这样统一、中心化过期键删除策略保证主从服务器数据的<strong>一致性</strong>。</li>
<li><strong>当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</strong></li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>《Redis设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>中断</title>
    <url>/posts/81b224e1/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章介绍一下操作系统中重要的概念——中断。中断是将处理器和外部设备系统工作的重要方式。中断机制就是让硬件在需要的时候向内核发出信号。不过中断也不是一句话就能够总结的，因此写此文章来记录一下中断的全部面貌。</p>
</blockquote>
<span id="more"></span>

<p>处理器和外部设备系统工协同工作的机制：<strong>让硬件需要的时候再向内核发送信号</strong>。这个机制就是中断机制。</p>
<h4 id="中断介绍"><a href="#中断介绍" class="headerlink" title="中断介绍"></a>中断介绍</h4><p>​    <strong>中断本质是一种特殊的电信号，由硬件发向处理器</strong>。处理器收到中断后，会马上向操作系统反映该信号的到来，然后就由操作系统去负责处理新来的数据。</p>
<ul>
<li><p>中断随时可以产生，因此内核随时可能因为新来的中断而被打断。</p>
</li>
<li><p>每个中断都通过唯一的中断号标志。这些中断值通常被称为中断请求（IRQ）线，每个IRQ线都会被关联一个数值量。如在经典PC机上，IRQ0是时钟中断，IRQ1是键盘中断。</p>
</li>
</ul>
<blockquote>
<p> 异常：</p>
<p> ​    异常和中断不同，它在产生时必须考虑与处理器时钟同步。因此常常被称为同步中断，异常是由处理器本身产生的。</p>
<p> ​    在处理器执行到由于编程失误而导致的错误指令的时候，或者实在执行期间出现特殊情况，必须靠内核来处理的时候，处理器就会产生一个异常。</p>
<p> ​    异常的例子：在上一章系统调用时，软中断陷入内核，引起的是系统调用处理异常。</p>
</blockquote>
<h4 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h4><p>​    在响应一个特定中断的时候，内核会执行一个函数，该函数叫做<strong>中断处理程序或中断服务例程</strong>。（中断处理程序是一个内核执行的函数）</p>
<p>​    Linux中断程序就是普通的C函数，不过必须按照特定的方式声明，以便内核识别。但是中断程序和其他内核函数的区别在于：</p>
<ul>
<li>普通内核函数运行在进程上下文中。</li>
<li><strong>中断程序运行在中断上下文中，中断上下文也称原子上下文，不可阻塞。</strong></li>
<li>由于中断上下文不可阻塞，因此执行中断处理程序得迅速！</li>
</ul>
<h4 id="上半部与下半部的对比"><a href="#上半部与下半部的对比" class="headerlink" title="上半部与下半部的对比"></a>上半部与下半部的对比</h4><p>​    中断处理被分为两个部分：</p>
<p>​    中断处理程序为上半部分：接到中断立即执行，只做严格实现的工作，此时<strong>中断被禁止。</strong></p>
<p>​    下半部：被允许稍后完成的工作，此时为开中断。</p>
<h4 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h4><p>中断处理程序是管理硬件的驱动程序的组成部分。每个设备都有相关的驱动程序，如果设备使用中断（大部分设备如此），那么响应的驱动程序就注册一个中断处理程序。</p>
<p>驱动程序可以通过<code>request_irq()</code>函数注册一个中断处理程序（它被声明在文件<code>&lt;linux/interrupt.h&gt;</code>中），并且激活给定的中断线，以处理中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* request_irq: 分配一条给定的中短线 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handle_t</span> handler, usigned <span class="keyword">long</span> flags, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">void</span>* dev)</span></span>;</span><br><span class="line"><span class="comment">// 第一个参数irq表示要分配的中断号。</span></span><br><span class="line"><span class="comment">// 第二个参数handler这是一个指针，指向实际中断处理程序</span></span><br><span class="line"><span class="comment">// typedef irqreturn_t (*irq_handler_t) (int, void*);</span></span><br></pre></td></tr></table></figure>



<ol>
<li><p>中断处理程序标志</p>
<p>在上面那个函数，第三个参数flags可以为0，也可以是一个或多个标志的位掩码。</p>
<ul>
<li><p>IRQF_DISABLED：意味着内核在处理中断程序本身期间，要禁止所有的其他中断</p>
</li>
<li><p>IRQF_SAMPLE_RANDOM：此标志表明这个设备产生的中断对内核熵池有贡献</p>
</li>
<li><p>IRQF_TIMER：特别为系统定时器的中断处理而准备的</p>
</li>
<li><p>IRQF_SHARED：可以在多个中断的处理程序之间的贡献中断线</p>
</li>
</ul>
<p>第四个参数name是与中断相关的设备的ASCII文本表示。</p>
<p>第五个参数dev用于共享中短线，当一个中断处理程序释放时，dev将提供标志信息。如果不需要共享中断线，设置为空(NULL)就行。</p>
</li>
</ol>
<p>注意：<code>request_irq()</code>函数可能睡眠，原因是该函数中调用了<code>kmalloc()</code>,这个函数是睡眠的。</p>
<ol start="2">
<li><p>释放中断处理程序</p>
<p><strong>卸载驱动程序时，需要注销相应的中断处理程序，并释放中断线</strong>。（中断线如果是共享的，那么删除处理程序即可，如果不是共享的或者是最后一个处理程序，则必须禁用该中断线）</p>
</li>
</ol>
<h4 id="编写中断程序"><a href="#编写中断程序" class="headerlink" title="编写中断程序"></a>编写中断程序</h4><ol>
<li><p>重入和中断处理程序</p>
<p><strong>当前中断线在处理时总是被禁止的，所以中断处理程序无须重入。同一个中断处理程序绝对不会被同时调用以处理嵌套的中断。</strong></p>
</li>
<li><p>共享的中断处理程序</p>
<ol>
<li>request_irq()的flags被设为IRQF_SHARED</li>
<li>dev参数必须唯一</li>
<li>中断处理程序必须区分是否真产生了中断</li>
</ol>
</li>
<li><p>中断处理程序实例<br>例：RTC(real-time clock)驱动程序：从系统定时器独立出来，用于设置系统时钟（向某个特定寄存器或IO地址写入时间即可）、周期性的定时器或报警器（中断实现）。</p>
</li>
</ol>
<h4 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h4><p>​    当执行一个中断处理程序时，内核处于中断上下文中。中断上下文有以下的特点：</p>
<ul>
<li>中断上下文不可睡眠，也不可能重新调度。</li>
<li>中断上下文有着严格的时间限制，因为它打断了其他代码。</li>
<li>中断处理程序并不具备自己的栈，需要共享别人的堆栈，而内核栈本身就有限，因此中断使用栈必须节约。</li>
</ul>
<h4 id="中断处理机制的实现"><a href="#中断处理机制的实现" class="headerlink" title="中断处理机制的实现"></a>中断处理机制的实现</h4><p>​    中断处理系统非常依赖体系结构。</p>
<img src="/posts/81b224e1/%E4%B8%AD%E6%96%AD%E4%BB%8E%E7%A1%AC%E4%BB%B6%E5%88%B0%E5%86%85%E6%A0%B8%E7%9A%84%E8%B7%AF%E7%94%B1.png" class title="中断从硬件到内核的路由">

<p>设备产生中断 ⇒ 总线把电信号发给中断控制器 ⇒ 若为激活的，中断控制器将中断发往处理器 ⇒ 处理器关闭中断 ⇒ 跳到中断处理程序入口 ⇒ 返回内核运行中断的代码。</p>
<p>中断开始于预定义入口，和系统调用类似，处理器会跳到对应的一个唯一位置。</p>
<p><strong><code>/proc/interrupts</code></strong></p>
<p><code>procfs</code>是一个虚拟文件系统，它只存在于内核内存，一般安装于/proc目录。在procfs读写文件都要调用内核函数，模拟从真实数据中读写。 </p>
<h4 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h4><p>Linux内核提供了一组接口用于操作机器上的中断状态。这些接口可以提供能够禁止当前处理器的中断系统，或屏蔽掉整个机器的一条中断线的能力。</p>
<p>一般来说，<strong>控制中断系统的原因是需要提供同步</strong>。</p>
<p>通过禁止中断，中断处理程序不会抢占当前代码。不过也可以禁止内核抢占，这样内核就可以在该处理器上同步。</p>
<p>不过如果是多处理器的并发访问，这两种方式都不能解决同步问题。这种情况下就要提供锁，锁在下一个部分会重点介绍。</p>
<ul>
<li><p>禁止和激活中断</p>
<p>用于禁止和激活当前处理器的本地中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">local_irq_disable(); <span class="comment">// 禁止		-&gt; cli指令</span></span><br><span class="line">local_irq_enable();	 <span class="comment">// 激活		-&gt; sti指令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个函数都是以单个汇编指令实现</span></span><br></pre></td></tr></table></figure></li>
<li><p>禁止指定的中断线</p>
<p>禁止所有中断的函数有的时候用不到，有的时候只需要屏蔽掉一条中断线即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>; <span class="comment">//只有当前正在执行的所有处理程序完成后才能返回。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_irq_nosync</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;<span class="comment">//不会等待当前中断处理程序完成</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">synchronize_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些函数可以在中断或者进程上下文中调用，而且不会睡眠。设备必须支持中断线共享，不然这些函数无意义。</p>
</li>
<li><p>中断状态</p>
<ul>
<li>宏<code>irqs_diable()</code>用于判断本地处理器上中断是否被禁止。</li>
<li><code>in_interrupt()</code>：判断内核是否在中断处理程序或下半部处理程序中</li>
<li><code>in_irq()</code>：判断是否在中断处理程序</li>
</ul>
</li>
</ul>
<blockquote>
<p>截止到现在讲述的是中断处理程序，中断处理程序是在中断的上半部，处于中断上下文中，中断处理程序执行的时间很短，因为它把有必要推迟的东西全部放到下半部去执行了，之后我们就来看看下半部。</p>
</blockquote>
<h4 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h4><p>​    上一章讨论了内核为处理中断提供的<strong>中断处理程序机制</strong>。中断处理程序是内核必不可少的部分，但是也存在着一些局限。因此只能完成上半部工作。局限包括</p>
<ul>
<li>中断处理程序以<strong>异步</strong>方式执行，并且可能打断其他代码的执行，这样的话必须得快！</li>
<li>如果一个中断处理程序正在执行，那么与该中断同级的其他中断会被屏蔽（当然也可能设计该处理器的所有中断都被屏蔽），这样的话为了让其他中断响应，中断越快越好。</li>
<li>中断处理程序是对硬件进行操作，因此一般有时限要求。</li>
<li><strong>中断处理程序运行在中断上下文，不能阻塞。</strong></li>
</ul>
<p>在诸多局限下，一般来说中断处理程序最好处理：</p>
<ul>
<li>对时间敏感的任务；</li>
<li>和硬件相关的任务；</li>
<li>该任务不能被其他中断打断。</li>
</ul>
<p>其它的任务都可以放到下半部去做。</p>
<p><strong>这种设计能够让系统处于中断屏蔽状态（上半部）的时间尽可能短，以此提高系统的响应能力。</strong></p>
<p>下半部的工作实现机制：</p>
<ul>
<li>软中断（和系统调用中的软件中断不同，<strong>系统调用的中断是软件触发的中断，所以称为软中断，而对于中断下半部的软中断，虽然也是软件触发，但是并不经过中断向量表。</strong>）</li>
<li><code>tasklet</code></li>
<li>工作队列</li>
<li>内核定时器（推后到具体的某一时间）</li>
</ul>
<h4 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h4><ol>
<li><p>软中断的实现</p>
<p>软中断在<strong>编译器静态分配</strong>的。由<code>softirq_action</code>结构表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span>&#123;</span></span><br><span class="line">	<span class="keyword">void</span> (*action)(struct softirq_action *);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>];</span>要么</span><br><span class="line"><span class="comment">//每个被注册的软中断占据数组一项，因此最多32个软中断</span></span><br></pre></td></tr></table></figure></li>
<li><p>软中断的执行</p>
<p>一般来说中断处理程序在返回前标记它的软中断，使其在稍后合适时刻执行。软中断执行都在<code>do_softirq()</code>函数中执行。该函数会遍历每一个待处理的软中断，并执行它。</p>
<p>一个软中断不能抢占另外一个软中断，软中断只能够被中断处理程序抢占。</p>
</li>
<li><p>使用软中断</p>
<p>软中断是在系统中对<strong>时间要求最严格以及最重要的下半部使用。</strong>内核定时器和<code>tasklet</code>都建立在软中断的实现上。软中断使用方便，性能也不错，但是需要对时间要求严格。</p>
<ul>
<li>分配索引：在编译期间给每个软中断分配索引，索引小的先执行。</li>
<li>注册处理程序：运行时调用<code>open_softirq()</code>注册<strong>软中断处理程序</strong></li>
<li>触发软中断：使用<code>raise_softirq()</code>将软中断设置为挂起，让它在<code>do_softirq()</code>时投入运行。<strong>在触发一个软中断之前必须先禁止中断，触发后再恢复</strong>。</li>
</ul>
</li>
</ol>
<h4 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a><code>tasklet</code></h4><p>​        <code>tasklet</code>是一个利用软中断实现的下半部机制，二者很像。在大部分情况都使用这个机制而非软中断。</p>
<ol>
<li><p><code>tasklet</code>的实现：</p>
<p>tasklet由两类软中断代表：<code>HI_SOFTIRQ</code>和<code>TASKLET_SOFTIRQ</code>,前者优先执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> state;    <span class="comment">//tasklet状态，仅能0、TASKLET_STATE_SCHED,TASKLET_STATE_RUN</span></span><br><span class="line">	<span class="keyword">atomic_t</span> count;			<span class="comment">//引用计数，不为0，则tasklet被禁止；为0才可执行</span></span><br><span class="line">	<span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);		<span class="comment">// tasklet处理函数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> data;					<span class="comment">//给tasklet处理函数的参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>tasklet</code>的使用：</p>
<p>(1)声明自己的tasklet</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_TASKLET(name,func,data) <span class="comment">//静态的创建</span></span><br><span class="line">Tasklet_init(t, tasklet_hander, dev) <span class="comment">//动态的创建</span></span><br></pre></td></tr></table></figure>

<p>(2)编写自己的tasklet处理函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Void <span class="title">tasklet_handler</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br></pre></td></tr></table></figure>

<p>(3)调度自己的tasklet</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tasklet_schedule(struct tasklet_struct *t);</span><br></pre></td></tr></table></figure>

<p>(4)tasklet的执行—ksoftirqd<br>前面说到tasklet的实现也是通过软中断来实现的，并且在ksoftirqd中会执行软中断。<br>每个处理器都有一个辅助处理软中断的内核线程—ksoftirqd/n n就是处理器的编号。<br>线程的实现在 kernel/softirq.c中，被设计为以下的死循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!softirq_pending(CPU))</span><br><span class="line">    Schedule();</span><br><span class="line">    Set_current_state(TASK_RUNNING);</span><br><span class="line">    <span class="keyword">while</span>(softirq_pending(cpu)</span><br><span class="line">    &#123;</span><br><span class="line">	    do_doftirq();</span><br><span class="line">	    If(need_resched())</span><br><span class="line">	    &#123;</span><br><span class="line">	   	 	Schedule();</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Set_current_state()TASK_INTERRUPTIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​       只要有待处理的软中断，ksoftirq就会调用do_softirq()去处理他们。同时tasklet是软中断实现的，也就会同时被调用。</p>
</li>
</ol>
<p>tasklet相较于软中断的优点：</p>
<ul>
<li>可以动态创建和销毁，因为软中断是编译期创建的</li>
<li>接口相对比较简洁，只利用了其中两个软中断，所有的复杂性都被简洁的接口隐藏起来了。</li>
<li>tasklet有着序列化保障，同一类型的tasklet不允许同时进行（即使是在不同的处理器上）</li>
</ul>
<p>因此只有当tasklet无法被实现的时候，才会选择软中断。</p>
<h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>​    工作队列不是基于软中断，而是把工作推后，<strong>交由一个内核线程去执行（这个下半部是在进程上下文中）</strong>，这样的话工作队列允许重新调度甚至是睡眠。</p>
<p>​    因此如果任务需要睡眠，选工作队列。如果不需要，就选软中断和tasklet。</p>
<ol>
<li><p>工作队列的实现</p>
<p>工作队列可以让你的驱动创建一个专门的工作者线程来处理要推后的工作，不过工作队列子系统提供了缺省的工作者线程称为<code>events/n</code>,n为处理器编号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// work</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span> data;		<span class="comment">//参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="keyword">work_func_t</span> func;		<span class="comment">//待执行函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// work_queue thread</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工作、工作队列、工作者线程之间的关系.png</p>
<img src="/posts/81b224e1/%E5%B7%A5%E4%BD%9C%E3%80%81%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E3%80%81%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" class title="工作、工作队列、工作者线程之间的关系"></li>
</ol>
<p>最高一层是工作者线程。系统允许多种工作者线程，<strong>每种类型</strong>，<strong>CPU上都有一个该类的工作者线程。</strong>每个工作者线程都要cpu_workqueue_struct结构体表示。</p>
<h4 id="下半部的选择机制"><a href="#下半部的选择机制" class="headerlink" title="下半部的选择机制"></a>下半部的选择机制</h4><p>三种机制的工作环境不同，因此选择机制也不同。</p>
<ul>
<li><p><strong>tasklet与软中断不能睡眠，是中断上下文环境</strong></p>
</li>
<li><p><strong>工作队列可以睡眠，可以产出调度，是进程上下文环境</strong></p>
<p>当选择方法的时候，如果需要睡眠，则选择任务队列；当不需要睡眠的时候，选择tasklet，当tasklet无法实现时才考虑使用软中断。</p>
</li>
<li><p>软中断处理程序执行的时候，允许响应中断，但自己不能休眠。</p>
</li>
<li><p><strong>如果软中断在执行的时候再次触发，则别的处理器可以同时执行，所以加锁很关键。</strong></p>
</li>
<li><p>tasklet负责执行的序列化保障，<strong>两个类型的tasklet不允许同时执行</strong>，<strong>即使在不同的处理器上也不行。所以相同tasklet之间不需要操心同步的问题，只需要考虑不同tasklet之间的同步问题。</strong></p>
</li>
</ul>
<h4 id="下半部之间加锁"><a href="#下半部之间加锁" class="headerlink" title="下半部之间加锁"></a>下半部之间加锁</h4><p>首先来看一下三者的比较</p>
<table>
<thead>
<tr>
<th align="center">下半部</th>
<th align="center">上下文</th>
<th align="center">顺序执行比较</th>
</tr>
</thead>
<tbody><tr>
<td align="center">软中断</td>
<td align="center">中断</td>
<td align="center">没有</td>
</tr>
<tr>
<td align="center"><code>tasklet</code></td>
<td align="center">中断</td>
<td align="center">同类型不能同时执行</td>
</tr>
<tr>
<td align="center">工作队列</td>
<td align="center">进程</td>
<td align="center">没有（和进程上下文一样被调度）</td>
</tr>
</tbody></table>
<p>上表可知，tasklet的一个优点是保证了一定的序列化保障。但是不同类型的tasklet还是需要使用锁。</p>
<ul>
<li>如果<strong>进程上下文和下半部共享数据</strong>，在访问数据之前，需要<strong>禁止下半部</strong>处理并得到锁的使用权，这样是为了本地和SMP的保护，防止死锁的出现。</li>
<li>如果<strong>中断上下文和下半部共享数据</strong>，在访问数据之前，需要<strong>禁止中断</strong>并得到锁的使用权，这样也是为了本地和SMP的保护，防止死锁的出现。</li>
</ul>
<p>即三者的优先级：<strong>进程上下文 &gt; 下半部 &gt; 中断</strong></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>中断是一种电信号，是硬件给内核发送的通知。内核一收到这个通知之后，立刻停住手头的工作，切换到中断上下文，执行中断处理程序。这是中断上半部，中断上半部执行要快，而且不可睡眠。</p>
<p>这样的话，一些非时间必要的任务可以挪到下半部稍后执行。下半部有四种机制：软中断，tasklet，工作队列，定时器。定时器之后再说，其他三个的工作机制和特点也足够清晰。</p>
<p>​    相信通过这两章的学习，中断在我们面前就足以清晰了。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>《Linux内核设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/posts/1abadc07/</url>
    <content><![CDATA[<blockquote>
<p>死锁是一个在操作系统和数据库中都非常常见的一个问题。本文我们就来介绍一下死锁相关的知识</p>
</blockquote>
<span id="more"></span>



<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    计算机系统中有很多独占性的资源，在同一时刻只能每个资源只能由一个进程使用。比如同一时刻不能有两个打印机同时输出结果，因为文件在文件打印进程是一个独占性资源。</p>
<p>​    这样的话如果两个进程独占性的访问某个资源，从而等待另外一个资源的执行结果，会导致两个进程都被阻塞，并且两个进程都不会释放各自的资源，这种情况下就是死锁（deadlock）</p>
<p>死锁可以发生在任何层面，在不同的机器之间可能会发生死锁，在数据库系统中也会导致死锁，比如进程 A 对记录 R1 加锁，进程 B 对记录 R2 加锁，然后进程 A 和 B 都试图把对象的记录加锁，这种情况下就会产生死锁。</p>
<p>死锁能够极大降低CPU的效率，而且甚至会出现错误或者异常，因此这是一个很重要的知识点。</p>
<p>下面我们就来讨论一下什么是死锁、死锁的条件是什么、死锁如何预防、活锁是什么等。</p>
<p>首先你需要先了解一个概念，那就是资源是什么。</p>
<h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>​    资源分为可抢占资源和不可抢占资源。</p>
<ul>
<li>可抢占资源：可以从拥有它的进程中抢占而不造成任何影响。比如内存，任何进程都可以直接抢占。</li>
<li>不可抢占资源：指的是除非出现错误或者异常，否则进程无法抢占指定资源。比如光盘，文件打印等。</li>
</ul>
<p>因此一般来说死锁是发生在不可抢占资源上。以下进程处理不可抢占资源的流程</p>
<ol>
<li>请求资源：如果资源不存在，那么请求进程会强制等待（一般来说进程处于阻塞态）。</li>
<li>使用资源：使用资源时，该资源被标记为正在使用，其他进程不能抢占这个资源。</li>
<li>释放资源：使用完资源，将其标志位空闲状态，其他进程可以去请求该资源。</li>
</ol>
<h4 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h4><p>针对我们上面的描述，资源死锁可能出现的情况主要有</p>
<ul>
<li>互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li>
<li>保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li>
<li>不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li>
<li>循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li>
</ul>
<p>以上就是发生死锁的四个条件，上面四种情况必须同时发生，才会出现死锁。如果其中一个条件不成立，死锁就不会发生。</p>
<p>总结一下，进程一般都是本身持有资源，但是又想着别人的资源，结果别人也是这么想的，那么就互相死锁了。</p>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><p>​    死锁是不可接受的，一般来说需要去尽量避免死锁。</p>
<p>​    死锁避免的最常规方式是正确加锁，在合适的临界区加锁和解锁，养成良好代码习惯。</p>
<p>​    但是四所本质是无法避免的，因为它需要后的未知的资源与请求，一般来说我们对死锁进行避免是通过破坏死锁的条件。</p>
<ul>
<li>破坏互斥条件：如果资源不被一个进程独占，那么死锁不会产生。尽量做到尽可能少的进程请求资源。</li>
<li>破坏保持等待谈条件：如果我们能够阻止持有资源的进程请求其他资源，我们就能消除死锁。不如进程在请求其他资源时，首先释放所占用的资源，然后再尝试一次获取全部资源。这个方法的缺点是无法合理利用资源。</li>
<li>破坏不可抢占条件：使用虚拟化的方式来实现抢占，但这也不是个好方法。</li>
<li>破坏循环等待条件：这个是最靠谱的方法，一般来说是对所有资源统一编号，进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。但是如果资源很多的时候，编号也是无法使用。</li>
</ul>
<h4 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h4><p>​    当死锁发生之后，对死锁进行检测并且从死锁中恢复。</p>
<p>​    死锁检测手段</p>
<ul>
<li>使用周期函数，每隔k分钟检测一次，或者CPU使用率降低到某一阈值，对其进行检测算法</li>
<li>死锁检测算法：通过资源和进程的向量关系，来判断哪个进程发生了死锁。</li>
</ul>
<p>​    死锁恢复，发生死锁之后如何从死锁中恢复</p>
<ul>
<li>通过抢占恢复，其实这也是破坏了不可抢占的条件，这往往需要人工干预。</li>
<li>使用回滚恢复，定期存储检查点映像，如果发生死锁就回退到正常映像版本中。这也是数据库中常见死锁恢复的方法。</li>
<li>杀死进程恢复，杀死一个死锁进程就会破坏掉循环等待条件，从而达到死锁恢复的效果。</li>
</ul>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p><strong>两阶段加锁</strong></p>
<p>​    虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。</p>
<p>​    一种解决方式是使用 两阶段提交(two-phase locking)。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。</p>
<p>​    如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。</p>
<p>​    不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。</p>
<p><strong>通信死锁</strong></p>
<p>​    之前讨论的都是资源死锁，其实<strong>每个进程因为等待其他进程引起的事件而产生阻塞</strong>，这也是一种死锁，称之为通信死锁。</p>
<p>​    通信死锁不能过通过调度的方式来解除，不过因为事件是可以设置定时器的，可以通过超时来规避死锁。</p>
<p><strong>活锁</strong></p>
<p>死锁：多个进程拿住资源不放手。<br>活锁：多个进程同时松开资源，又同时请求资源，依然造成阻塞。就像两个人相对着走，同时向同一边跨一步让行，结果还是对着</p>
<p><strong>饥饿</strong></p>
<p>当进程没有资源的时候，就叫做饥饿。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    死锁是一类通用问题，任何操作系统都会产生死锁。当每一组进程中的每个进程都因等待由该组的其他进程所占有的资源而导致阻塞，死锁就发生了。这种情况会使所有的进程都处于无限等待的状态。</p>
<p>​    死锁的检测和避免可以通过安全和不安全状态来判断，其中一个检测方式就是银行家算法；当然你也可以使用鸵鸟算法对死锁置之不理，但是你肯定会遭其反噬。</p>
<p>​    也可以在设计时通过系统结构的角度来避免死锁，这样能够预防死锁；也可以破坏死锁的四个条件来破坏死锁。资源死锁并不是唯一性的死锁，还有通信间死锁，可以设置适当的超时时间来完成。</p>
<p>​    活锁和死锁的问题有些相似，它们都是一种进程无法继续向下执行的状态。由于进程调度策略导致尝试获取进程的一方永远无法获得资源后，进程会导致饥饿的出现。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>《现代操作系统》</li>
<li><a href="https://leetcode-cn.com/leetbook/read/awesome-os-guide/">https://leetcode-cn.com/leetbook/read/awesome-os-guide/</a></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>死锁</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用</title>
    <url>/posts/4f5d4e8d/</url>
    <content><![CDATA[<blockquote>
<p>本文简单介绍一下操作系统中的系统调用</p>
</blockquote>
<span id="more"></span>

<p>​    在现代操作系统中，内核提供了用户进程与内核进行交互的一组接口。这些接口让应用设备受限地访问硬件设备。这些接口在应用程序和内核中扮演了“使者”的角色，应用程序负责发出各种请求，而内核负责满足这些请求（或者无法满足时返回一个错误）。 这些接口保证了系统稳定可靠，避免应用程序肆意妄行。</p>
<p>​    这些接口的名字叫做系统调用。</p>
<h4 id="与内核通信"><a href="#与内核通信" class="headerlink" title="与内核通信"></a>与内核通信</h4><p>​    系统调用在用户空间和硬件设备之间添加了一个中间层。</p>
<p>​    该层主要作用有三个：</p>
<ul>
<li>它为用户空间提供了一种硬件的抽象接口。</li>
<li>系统调用保证了系统的稳定和安全。内核可以基于权限、用户类型和其他一些规则对需要进行的访问进行裁决。</li>
<li>每个进程都运行在虚拟系统中，如果没有这层安全性公共接口，就无法实现多任务和虚拟内存。</li>
</ul>
<p>系统调用是用户空间访问内核的唯一手段；除异常和陷入之外，它们是内核唯一的合法入口。</p>
<p>​    </p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul>
<li><p>系统调用号</p>
<ul>
<li><p>每个系统调用被赋予了一个系统调用号，这个独一无二的系统调用号指明了到底要执行哪个系统调用。</p>
</li>
<li><p>系统调用号一旦分配就不再改变。</p>
</li>
<li><p>内核在系统调用表中保存着已经注册过得系统调用的列表，存储在<code>sys_call_table</code>中</p>
</li>
</ul>
</li>
<li><p>系统调用性能</p>
<p>设计原则： 简洁、高效。</p>
<p>原因：上下文切换时间很短。</p>
</li>
</ul>
<h4 id="系统调用处理程序"><a href="#系统调用处理程序" class="headerlink" title="系统调用处理程序"></a>系统调用处理程序</h4><ol>
<li><p>什么是系统调用处理程序</p>
<ul>
<li><p>用户空间的程序无法直接执行内核代码。因为内核主流在受保护的地址空间上，不能直接调用内核空间中的函数。</p>
</li>
<li><p>因此应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，希望系统切换到内核态，这样内核态就可以代表应用程序在内核空间执行系统调用。</p>
</li>
<li><p>通知内核的机制是靠<strong>软中断</strong>实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序。<strong>该异常处理程序实质就是系统调用处理程序</strong></p>
</li>
</ul>
<p>总结：用户程序通过异常或者陷入内核，执行系统调用处理程序。</p>
</li>
<li><p>系统调用处理程序中的参数</p>
<p>所有系统调用陷入内核的方式都一样，但是在陷入内核的过程中，用户程序需要把一些参数一并传递给内核。</p>
<ul>
<li>系统调用号：用户空间通过eax寄存器将系统调用号传递给内核。</li>
<li>外部参数：同样也是按照顺序放入<code>ebx, ecx, edx, esi, edi</code>寄存器</li>
<li>返回值： 同样是放在<code>eax</code>寄存器中传递。</li>
</ul>
</li>
</ol>
<h4 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h4><ol>
<li><p>实现系统调用：</p>
<ol>
<li>首先得决定该系统的用途。</li>
<li>原则：用途明确、简介稳定、通用、可移植、健壮。</li>
</ol>
</li>
<li><p>参数验证：</p>
<p>参数合法有效并正确：<strong>不能让内核访问无权访问的资源。</strong></p>
<p>最重要的检查：<strong>检查用户提供的指针是否有效</strong></p>
<p>该指针必须有以下要求：</p>
<ul>
<li>指向的内存区域属于用户空间。</li>
<li>指向的内存区在进程的地址空间里。</li>
<li>指向的内存区在内存的访问权限范围中。</li>
</ul>
<p>最后的检查：<strong>检查用户权限是否合法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span>(!capable(CAP_SYS_BOOT))&#123;</span><br><span class="line">    <span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// CAP_SYS_BOOT：系统调用</span></span><br><span class="line"><span class="comment">// -EPERM: 返回错误。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h4><ol>
<li><p>上下文</p>
<ol>
<li><strong>内核执行系统调用时是在进程上下文。<code>current</code> 指针指向当前任务，即引发系统调用的进程。</strong>    </li>
<li>在进程上下文中，这就意味着内核可以休眠、被抢占。系统调用是可重入的，这样来说也要对同步问题进行关注。</li>
<li>当系统调用返回是，控制权仍在<code>system_call()</code>中，负责切换到用户空间，并让用户进程继续执行下去。</li>
</ol>
</li>
<li><p>绑定系统调用的最后步骤：</p>
<p>最后步骤是把<strong>它注册成一个正式的系统调用</strong>。</p>
<ul>
<li>在系统调用表中加入表项。</li>
<li>系统调用号定义在<code>asm/unistd.h</code>中。</li>
<li>必须被编译进内核内核映像（不能编译到模块中），放入<code>kernel/</code>下的相关文件中。</li>
</ul>
</li>
<li><p>从用户空间访问系统调用。</p>
<p>系统调用靠C库支持，通常对已经有的系统调用，可以直接调用系统调用（或者调用库函数，再由库函数调用系统调用）。但是如果是自己写的系统调用，glibc库恐怕是不支持的。</p>
<p>不过，Linux提供了一组宏，用于直接对系统调用进行访问。它会设置好寄存器并调用陷入指令。</p>
<p><code>_syscalln()</code>：</p>
<ul>
<li><p>n的范围是0-6，代表着传递给系统调用的参数。</p>
</li>
<li><p>对于每个宏来说，都有2+2*n个参数。</p>
<p>第一个参数： 对应系统调用的返回值</p>
<p>第二个参数：系统调用的名称</p>
<p>按照系统调用参数顺序排列的每个参数的类型和名称。</p>
</li>
</ul>
<p>举个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flags, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> NR_open 5</span></span></span><br><span class="line"><span class="function">_<span class="title">syscall3</span><span class="params">(<span class="keyword">long</span>, open, <span class="keyword">const</span> <span class="keyword">char</span>*, filename, <span class="keyword">int</span>, flags, <span class="keyword">int</span>, mode)</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在本章中，我们描述了</p>
<ul>
<li>系统调用到底是什么？</li>
<li>它们和库函数，API之间又怎么样的关系（API调用库函数，库函数调用系统调用）。</li>
</ul>
<p>然后我们考察了</p>
<ul>
<li>Linux如何实现系统调用</li>
<li>执行系统调用的步骤：陷入内核，传递调用号和参数，执行系统调用函数，把返回值带回用户空间。</li>
</ul>
<p>最后我们讨论了</p>
<ul>
<li>如何写增加一个系统调用？</li>
<li>写系统调用需要注意的是什么？</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>《Linux内核设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>系统调用</tag>
      </tags>
  </entry>
  <entry>
    <title>文件管理</title>
    <url>/posts/ae533703/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章介绍一下Linux系统中的文件系统和I/O设备，这两块的知识点很多，本篇只是简要介绍一下。</p>
</blockquote>
<span id="more"></span>

<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>​    虚拟文件系统(VFS)作为内核子系统，为用户空间程序提供了文件和文件系统相关的接口。系统中所有文件系统不但依赖VFS共存，而且也依靠VFS系统协同工作。系统中所有文件系统不但依赖VFS共存，而且也依靠VFS系统协同工作。</p>
<h4 id="通用文件系统接口"><a href="#通用文件系统接口" class="headerlink" title="通用文件系统接口"></a>通用文件系统接口</h4><p>​    VFS为不同的文件系统和实际物理介质提供了相同的接口。用户可以对所有文件都使用read(), open(), write()这样的系统调用。这也是VFS最大的意义：<strong>将各种不同的文件系统抽象后采用统一的方式进行操作。</strong>下一章的块I/O设备支持各种各样的存储设备。<strong>VFS和块I/O相结合，使得用户空间调用统一的系统调用访问各种文件。</strong></p>
<h4 id="文件系统抽象层"><a href="#文件系统抽象层" class="headerlink" title="文件系统抽象层"></a>文件系统抽象层</h4><p>​    之所以能使用通用接口对所有类型的文件系统进行操作，是因为内核在底层文件系统接口建立了一个抽象层。该抽象层定义了所有文件都支持的基本的概念上的接口和数据结构。从而隐藏了具体的实现细节。这样除了文件系统本身之外，上层调用者不需要知道实际的细节。</p>
<img src="/posts/ae533703/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" class title="文件系统的系统调用">

<p>​    </p>
<h4 id="Unix文件系统"><a href="#Unix文件系统" class="headerlink" title="Unix文件系统"></a>Unix文件系统</h4><p>​    Unix使用了四种和文件系统相关的传统抽象概念：文件、目录项、索引节点（inode）和安装点(mount point)</p>
<ul>
<li>文件：是一个有序字节串。是文件的名字</li>
<li>目录项：文件通过目录项组织。目录可以层层嵌套组成文件路径。VFS把目录当做文件对待，因此二者的执行和操作相同。</li>
<li>索引节点：存储文件相关信息的数据结构。（权限、大小、拥有者、创建时间等）</li>
<li>安装点：文件卷在目录层次内存在的位置</li>
</ul>
<p>超级块：文件系统的控制信息</p>
<h4 id="VFS对象及其数据结构"><a href="#VFS对象及其数据结构" class="headerlink" title="VFS对象及其数据结构"></a>VFS对象及其数据结构</h4><p>​    VFS通过面向对象的设计思路，使用一组数据结构来代表通用文件对象。</p>
<ul>
<li>超级块对象：代表一个具体的已安装文件系统</li>
<li>索引节点对象： 代表一个具体文件</li>
<li>目录项对象：代表一个目录项，是路径的一个组成部分</li>
<li>文件对象：<strong>由进程打开的文件。</strong></li>
</ul>
<p>每个对象都包含一个操作对象；</p>
<ul>
<li>super_operation对象，针对特定文件系统能调用的方法，如write_inode()和sync_fs()等</li>
<li>inode_operation对象，针对特定文件的方法，如create()、link()</li>
<li>dentry_operation对象，针对特定目录，如d_compare()和d_delete()</li>
<li>file_operation对象，针对已打开文件，如read()和write()</li>
</ul>
<h4 id="超级块对象"><a href="#超级块对象" class="headerlink" title="超级块对象"></a>超级块对象</h4><p>​    所有文件都必须实现超级块对象，<strong>该对象用于存储特定文件系统的信息</strong>。结构体<code>super_lock</code>，通过<code>alloc_super()</code>创建并初始化。文件安装时文件系统会调用该函数以便从磁盘中读取超级块，并将其信息填充到内存中的超级块对象中。<strong>针对的层级是文件系统级。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">s_list</span>;</span>		<span class="comment">/* Keep this first */</span></span><br><span class="line">	<span class="keyword">dev_t</span>			s_dev;		<span class="comment">/* search index; _not_ kdev_t */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>		s_blocksize_bits;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		s_blocksize;</span><br><span class="line">	<span class="keyword">loff_t</span>			s_maxbytes;	<span class="comment">/* Max file size */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>	*<span class="title">s_type</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>	*<span class="title">s_op</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span>	*<span class="title">dq_op</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">quotactl_ops</span>	*<span class="title">s_qcop</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">export_operations</span> *<span class="title">s_export_op</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		s_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		s_iflags;	<span class="comment">/* internal SB_I_* flags */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		s_magic;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">s_root</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>	<span class="title">s_umount</span>;</span></span><br><span class="line">	<span class="keyword">int</span>			s_count;</span><br><span class="line">	<span class="keyword">atomic_t</span>		s_active;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xattr_handler</span> **<span class="title">s_xattr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span>	<span class="title">s_roots</span>;</span>	<span class="comment">/* alternate root dentries for NFS */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">s_mounts</span>;</span>	<span class="comment">/* list of mounts; _not_ for fs use */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>	*<span class="title">s_bdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">s_bdi</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span>		*<span class="title">s_mtd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">s_instances</span>;</span></span><br><span class="line">	.....</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>&#123;</span></span><br><span class="line">    (*alloc_inode)(struct super_block *sb);</span><br><span class="line">    (*destroy_inode)(struct inode*);</span><br><span class="line">    (*dirty_inode)</span><br><span class="line">    (*write_inode)</span><br><span class="line">    (*drop_inode)</span><br><span class="line">    (*delete_inode)</span><br><span class="line">    (*put_inode)</span><br><span class="line">    (*write_inode)</span><br><span class="line">    (*sync_fs)</span><br><span class="line">    (*freeze_fs)</span><br><span class="line">    (*statfs)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="索引节点对象"><a href="#索引节点对象" class="headerlink" title="索引节点对象"></a>索引节点对象</h4><p>​    <strong>索引节点对象包含了内核在操作文件或目录需要的全部信息。</strong>索引节点对象必须在内存中创建，以便于文件系统使用。</p>
<p>一个inode代表文件系统中的一个文件，它也就可以是设备或管道这样的特殊文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span>&#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作：</span></span><br><span class="line">create();</span><br><span class="line">link();		<span class="comment">// 硬链接</span></span><br><span class="line">symlink();	<span class="comment">//符号链接</span></span><br><span class="line">mkdir();</span><br><span class="line">rename();</span><br><span class="line">setattr();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="目录项对象"><a href="#目录项对象" class="headerlink" title="目录项对象"></a>目录项对象</h4><p>目录项由dentry表示，与前面两个不同，<strong>目录项对象没有对应的磁盘数据结构，VFS根据字符串形式的路径名现场创建</strong>。</p>
<ul>
<li><p>目录项状态</p>
<p><strong>被使用</strong>：对应有效的索引节点，存在使用者<br><strong>未被使用</strong>：该目录项指向有效对象，只是尚未使用，路径查找更迅速<br><strong>负状态</strong>：没有对应的有效索引，仍然保留，以快速解析以后的路径查询。</p>
</li>
<li><p>目录项缓存<br><strong>内核将目录项对象缓存在目录项缓存中(dcache)</strong>,目录项缓存包括三个主要部分：</p>
<ul>
<li><p>“被使用的”目录项链表。通过inode的i_dentry项关联。</p>
</li>
<li><p>“最近被使用的”双向链表。含有未被使用的和负状态的目录项。头部插入目录项，尾部删除。</p>
</li>
<li><p>散列表及其散列函数用于快速将路径解析为dentry，由dentry_hashtable表示，散列函数d_hash()，查找散列表通过d_lookup()</p>
</li>
</ul>
<p>dcache一定意义也提供对inode的缓存，即icache，只要目录项被缓存，其相应的索引节点也就被缓存。</p>
</li>
<li><p>目录项操作<br>d_revalidate()：目录对象是否有效<br>d_hash()<br>d_compare()<br>d_delete()：目录项d_count计数值等于0时调用<br>d_release()：释放</p>
</li>
</ul>
<h4 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h4><p>文件对象表示<strong>进程已经打开的文件,无实际磁盘数据对应</strong>。<strong>多个进程可以同时打开和操作同一个文件，虽然一个文件对应的文件对象不唯一，但其索引和目录项是唯一的。其f_dentry指针指向相关的目录项对象。目录项对象会指向inode节点，inode会记录文件是否dirty。</strong></p>
<p>进程直接处理的是文件，而不是超级块、索引节点和目录项。</p>
<p><strong>文件对象是已打开的文件在内存中的表示。该对象由open()系统调用创建。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>&#123;</span></span><br><span class="line">…</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件操作file_operations:</span></span><br><span class="line"><span class="comment">                            llseek;</span></span><br><span class="line"><span class="comment">                            read;</span></span><br><span class="line"><span class="comment">                            write;</span></span><br><span class="line"><span class="comment">                            aio_read;</span></span><br><span class="line"><span class="comment">                            aio_write;</span></span><br><span class="line"><span class="comment">                            readdir;</span></span><br><span class="line"><span class="comment">                            ioctl：需要调用者持有BKL锁</span></span><br><span class="line"><span class="comment">                            unlocked_ioctl()：不需要加锁</span></span><br><span class="line"><span class="comment">                            mmap</span></span><br><span class="line"><span class="comment">                            open</span></span><br><span class="line"><span class="comment">                            flush</span></span><br><span class="line"><span class="comment">                            fsync</span></span><br><span class="line"><span class="comment">                            lock</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="和文件系统相关的数据结构"><a href="#和文件系统相关的数据结构" class="headerlink" title="和文件系统相关的数据结构"></a>和文件系统相关的数据结构</h4><p>​    除了上面的VFS基础对象外，内核还使用了另外一些标准数据机构管理文件系统的其他数据。</p>
<ol>
<li>file_system_type：特定文件系统类型</li>
<li>vfsmount：在安装点被创建，它还保存了安装时指定的标志信息，在mnt_flags域中</li>
</ol>
<h4 id="和进程相关的数据结构"><a href="#和进程相关的数据结构" class="headerlink" title="和进程相关的数据结构"></a>和进程相关的数据结构</h4><p>​    系统中每一个进程都有自己的一组打开的文件，像根文件系统、当前工作目录、安装点等。有3个数据结构将VFS和进程紧密联系在一起。</p>
<ul>
<li><p><code>file_struct</code></p>
<p>该结构体由进程描述符中的files目录项指向。所有与单个进程相关的信息（如打开的文件及文件描述符）都包含在内。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>				count;					<span class="comment">// 结构使用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span>			*<span class="title">fdt</span>;</span>					<span class="comment">// 指向其他fd表的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> 			*<span class="title">fdtab</span>;</span>					<span class="comment">// 基fd表</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>				file_lock;				<span class="comment">// 单个文件的锁</span></span><br><span class="line">    <span class="keyword">int</span> 					next_fd;				<span class="comment">// 缓存下一个可用的fd</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span>	<span class="title">close_on_exec_init</span>;</span>		<span class="comment">// exce()时关闭的文件描述符链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> 	<span class="title">open_fds_init</span>;</span>			<span class="comment">// 打开的文件描述符链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span>				*<span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>]	// 缺省的文件对象数组</span></span><br><span class="line"><span class="class">&#125;;</span>	</span><br></pre></td></tr></table></figure></li>
<li><p><code>fs_struct</code></p>
<p>该结构由进程描述符的fs域指向。<strong>它包含文件系统和进程相关的信息。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span>&#123;</span></span><br><span class="line">  	<span class="keyword">int</span> 					users;					<span class="comment">// 用户数目  </span></span><br><span class="line">    <span class="keyword">rwlock_t</span>				lock;					<span class="comment">// 保护该结构体的锁</span></span><br><span class="line">    <span class="keyword">int</span> 					umask;					<span class="comment">// 掩码</span></span><br><span class="line">    <span class="keyword">int</span> 					in_exec;				<span class="comment">// 当前正在执行的文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>				<span class="title">root</span>;</span>					<span class="comment">// 根目录路径</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>				<span class="title">pwd</span>;</span>					<span class="comment">// 当前工作目录的路径</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>包含了文件所在的工作目录路径和根目录路径</p>
</li>
<li><p><code>namespace</code>结构体</p>
<p>它使得每个进程在系统中都看到唯一的安装文件系统——不仅是唯一的根目录，而且还是唯一的文件系统层次结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mmt_namespace</span>&#123;</span></span><br><span class="line">  	<span class="keyword">atomic_t</span>				count;					<span class="comment">// 使用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span>			*<span class="title">root</span>;</span>					<span class="comment">// 根目录安装点对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">list</span>;</span>					<span class="comment">// 安装点链表		连接已安装文件系统，包含的元素组成了全体命名空间。</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span>		poll;					<span class="comment">// 轮询的等待队列</span></span><br><span class="line">    <span class="keyword">int</span>						event;					<span class="comment">// 时间计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上述的这些数据结构都是通过<strong>进程描述符</strong>连接的。对多数进程来说，它们的描述符都指向唯一的<code>files_struct</code>和<code>fs_struct</code>结构体。不过如果是线程的话，使用克隆标志<code>CLONE_FILES</code>或<code>CLONE_FS</code>创建的进程，那么会共享这个结构体。</p>
<p><code>namespace</code>结构体的使用方法和前两种结构体完全不同，默认情况下，所有进程共享同样的命名空间（也就是说，他们都是从相同的挂载表中看到同一文件系统层次结构）。只有在clone()使用了<code>clone_news</code>标志，才会开辟新的命名空间。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​    本章介绍了VFS的目的，讨论了各种数据结构，包括最重要的索引节点、目录项以及超级块对象。对了，千万别忘了inode和fd之间的区别。</p>
<p>下一章将介绍数据如何从物理上存放在文件系统中。</p>
<h3 id="块I-O层"><a href="#块I-O层" class="headerlink" title="块I/O层"></a>块I/O层</h3><h4 id="块设备介绍"><a href="#块设备介绍" class="headerlink" title="块设备介绍"></a>块设备介绍</h4><p>这一章算是文件和设备的交界点。</p>
<p>设备分为以下三种设备：</p>
<ul>
<li>字符设备：字符设备按照<strong>字符流的方式被有序访问</strong>（如键盘）</li>
<li>块设备： 块设备能够<strong>随机访问固定大小的数据片</strong>（如硬盘，光驱、闪存等） 块设备是以安装<strong>文件系统</strong>的方式使用的——这也是块设备的一般访问方式。</li>
<li>网络设备： 通过socket套接字去访问，支持字节流和数据包的形式访问。</li>
</ul>
<p>字符设备只需要控制一个位置——当前位置就能完成它的工作，而块设备访问的位置必须能够在介质的不同区间前后移动。而且<strong>块设备对执行性能要求很高</strong></p>
<p><strong>块设备中最小寻址单位是扇区，一般大小为512B</strong>。不过<strong>块最小逻辑可寻址单元是块</strong>，一般来说都是<strong>基于块来访问文件系统</strong>。在逻辑层面上块就是最小单位。</p>
<h4 id="缓冲区和缓冲区头"><a href="#缓冲区和缓冲区头" class="headerlink" title="缓冲区和缓冲区头"></a>缓冲区和缓冲区头</h4><p>当一个块被调入内存时（等待读入后或等待写出时），它要存储在一个缓冲区中。<strong>每个缓冲区和一个块对应，相当于是磁盘块在内存中的表示。</strong></p>
<p>块包含一个或多个扇区，但大小不能超过一个页面，所以一个页可以容纳一个到多个页之间（一页4KB）。由于内核在处理数据时需要一些相关的控制信息（如块属于哪个设备，块对应哪个缓冲区等），因此每个缓冲区都有一个对应的描述符，描述符用<strong>buffer_head</strong>表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/buffer_head.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含了内核操作缓冲区所需要的的全部信息</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> b_state;		<span class="comment">/* buffer state bitmap (see above) 缓冲区状态标志*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span><span class="comment">/* circular list of page&#x27;s buffers 页面中的缓冲区*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span>		<span class="comment">/* the page this bh is mapped to存储缓冲区的页面 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">sector_t</span> b_blocknr;		<span class="comment">/* start block number 起始块号*/</span></span><br><span class="line">	<span class="keyword">size_t</span> b_size;			<span class="comment">/* size of mapping映像的大小 */</span></span><br><span class="line">	<span class="keyword">char</span> *b_data;			<span class="comment">/* pointer to data within the page页面内的数据指针 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">b_bdev</span>;</span>		<span class="comment">// 相关联的块设备</span></span><br><span class="line">	<span class="keyword">bh_end_io_t</span> *b_end_io;		<span class="comment">/* I/O completion  I/O完成方法 */</span></span><br><span class="line"> 	<span class="keyword">void</span> *b_private;		<span class="comment">/* reserved for b_end_io io完成方法*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_assoc_buffers</span>;</span> <span class="comment">/* associated with another mapping 相关的一个映射链表*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">b_assoc_map</span>;</span>	<span class="comment">/* mapping this buffer is  相关的地址空间</span></span><br><span class="line"><span class="comment">						   associated with */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> b_count;		<span class="comment">/* users using this buffer_head */</span>缓冲区使用计数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>(1). b_state域表示缓冲区的状态。合法的标识存放在bh_state_bits中<br>(2). b_count<br>在操作缓冲区头之前，应先使用get_bh()增加引用，确保该缓冲区头不会再被分配出去；完成操作之后，put_bh()减少引用计数。<br>(3). b_blocknr-th是缓冲区对应的磁盘物理块的逻辑块号<br>(4). b_page是缓冲区对应的内存物理页<br>(5). b_data直接指向响应的块（位于b_page域所指明的页面中的某个位置上），块在内存中的起始位置在b_data处，结束在(b_data + b_size) 处</p>
<p>总之，缓冲区头的目的在于<strong>描述磁盘块和物理内存缓冲区（在特定页面上的字节序列）之间的映射关系</strong>。这个结构体在内核中只扮演一个从缓冲区到块的映射关系的作用。</p>
<p>缓冲区的缺点：</p>
<p>(1). 缓冲区头很大且是不易控制的数据结构<br>(2). 仅能描述单个缓冲区，当作为I/O容器使用时，将大块数据的I/O操作分解为对多个buffer head的操作。</p>
<h4 id="BIO结构体"><a href="#BIO结构体" class="headerlink" title="BIO结构体"></a>BIO结构体</h4><p>​    内核中<strong>块I/O操作的基本容器</strong>由BIO结构体表示。该结构体代表了正在活动的以segment链表形式组织的块I/O操作。 <strong>一个片段是一小块连续的内存缓冲区</strong>。这样就不代表单个缓冲区一定要连续。</p>
<ul>
<li><p>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>bio结构体主要是代表正在现场执行的I/O操作，重要的几个域是bi_io_vecs、bi_vcnt和bi_idx。</p>
</li>
<li><p>bio_io_vec结构体<br><strong>bio_io_vec结构体数组指向一个bio_vec结构体数组，表示一个完整的缓冲区</strong>。bio_vec结构指明&lt;page, offset, len&gt;</p>
</li>
<li><p>bi_cnt引用计数<br>如果该值为0，则撤销该bio结构体，释放内存。通过：</p>
<ul>
<li>bio_get(bio)</li>
<li>bio_put(bio)</li>
</ul>
<p>进行管理，在操作正在活动的bio结构体时，一定要先增加它的引用计数，以免操作时bio被释放；操作完毕后，减少引用计数。</p>
</li>
<li><p>bi_private<br>创建者的私有域</p>
</li>
</ul>
<ul>
<li><p>新老方法对比</p>
<ul>
<li><p>缓冲区头</p>
<p><strong>代表的是一个缓冲区</strong>，描述的是磁盘的一个块，<strong>关联的是单独页中的单独磁盘块</strong>，所以它可能会引起不必要的分割，将请求按块为单位进行划分，之后再重新组合。</p>
<p>数据结构来说是重量级</p>
</li>
<li><p>bio结构体</p>
<p><strong>代表的是I/O操作</strong>，<strong>可以包括内存中的一个或多个页</strong>，不需要连续存储，也不需要分割I/O操作</p>
<p>数据结构来说是轻量级</p>
</li>
</ul>
</li>
<li><p>使用BIO的优点</p>
<ul>
<li>bio很容易处理高端内存，因为它处理的是物理页而不是直接指针。</li>
<li>bio结构体既可以代表普通页I/O，同时也可以代表直接I/O。</li>
<li>bio结构体便于执行分散-集中的块I/O操作</li>
<li>bio结构体较为轻量。因为它只需要包含块I/O操作所需信息。</li>
</ul>
</li>
</ul>
<h4 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h4><p>​    块设备将它们挂起的块I/O操作请求保存在请求队列<code>reques_queue</code>结构体中。该结构体包含一个双向请求链表以及相关控制信息。</p>
<p>​    请求队列只要不为空，队列对应的<strong>块设备驱动程序就会从队列头获取请求</strong>，然后将其送入对应的块设备中。请求可以有多个bio结构体组成。</p>
<h4 id="I-O调度程序"><a href="#I-O调度程序" class="headerlink" title="I/O调度程序"></a>I/O调度程序</h4><p>​    如果简单的以内核产生请求的顺序直接将请求发送给块设备的话，性能肯定很低。</p>
<p>​    <strong>磁盘寻址是整个计算机中最慢的操作之一。</strong>所以要提升性能首先得尽量缩短寻址时间。</p>
<p>​    为了优化寻址，内核在将请求提交给磁盘前，先执行名为<strong>合并与排序的预操作</strong>，这种预操作能够极大提升系统的性能。</p>
<p>​    <strong>在内核中负责提交I/O请求的子系统叫做I/O调度程序</strong>：I/O调度程序将<strong>磁盘I/O资源分配给系统中所有挂起的块I/O请求</strong>。资源分配的方式正是合并和排序。</p>
<ul>
<li><p>工作</p>
<p><strong>I/O调度程序的工作是管理块设备的请求队列</strong>。它决定队列中的请求排序顺序以及在什么时候发请求到块设备。</p>
<p>以下是两种能够减少磁盘寻址时间的操作：</p>
<ul>
<li><p>合并操作</p>
<p>如果两个或多个请求访问的磁盘扇区相同的话，那么将它们合并成一个请求。 这样能够缩短请求数目，减少磁盘寻址次数。</p>
<p>合并分为向前合并和向后合并。这看两个扇区之前的相对位置。</p>
</li>
<li><p>排序操作</p>
<p>整个请求队列将按扇区增长方向有序排列。这样可以保证<strong>磁盘头以直线方向移动寻址</strong>，从而缩短了所有磁盘寻址时间。</p>
<p>这种排序算法与电梯调度类似，因此I/O调度程序又被称为地奥体调度。</p>
</li>
</ul>
</li>
<li><p>linux电梯调度</p>
<p>当一个请求加入到队列中时，有可能发生下面四种操作。</p>
<ul>
<li>如果队列中已存在一个对相邻磁盘扇区操作的请求，那么新请求和现在请求合并为一个请求。        —&gt;    合并</li>
<li><strong>如果队列中存在一个驻留时间过长的请求，那么新请求将被插入队尾，保证旧请求的产生饥饿。</strong>    —-&gt;   饥饿避免</li>
<li>如果队列中以扇区方向为序存在合适的插入位置，那么新的请求会插入到这个位置，使得队列一直有序        —&gt; 排序</li>
<li>如果队列中没有适合的位置，那么请求被插入到队列尾部。</li>
</ul>
</li>
<li><p>最终期限I/O调度程序</p>
<p>电梯调度有个缺点——旧请求的饥饿问题。而如果是读操作，一般是和系统同步发生的，这样一来读请求饥饿的话，会使系统长时间不响应。<strong>因此读请求能够直接影响系统性能。</strong>如果在该位置请求过了，然后又需要对该位置进行读请求，这样调度程序只能回过来再次进行该位置的寻址，这样就寻址了两次。</p>
<p>在该调度程序中。每个请求都有一个超时时间，读操作为0.5s,写操作为5s。这样调度程序实现了另外两个队列——读FIFO和写FIFO。在请求超时时间到达之前，系统必须牺牲一部分磁盘读取性能来处理这些请求。</p>
</li>
<li><p>预测I/O调度程序</p>
<p>上一个调度程序同样带来了缺点，系统的吞吐量降低了。预测I/O调度程序在此基础上增加了<strong>预测启发</strong>的能力</p>
<p>预测调度在提交一个请求后并不直接返回去处理其他请求，而是有意空闲几ms，等待是否有该位置的读请求出现，如果有直接执行，如果没有，返回处理其他请求。这个等待只会造成轻微损失。<strong>如果能够正确预测应用程序和文件系统的行为，那么这个会大大减少服务读请求所需的寻址开销。</strong></p>
<p>预测I/O调度程序是linux内核中缺省的I/O调度程序。</p>
</li>
</ul>
<ul>
<li><p>空操作I/O调度程序</p>
<p>该种操作不进行排序，只进行合并。该种调度方式用在闪存等块设备上。因为这种硬件是真正的随机访问，因此没必要进行排序。</p>
</li>
</ul>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>​    本结先介绍块设备是什么，然后对两种缓冲区的结构进行对比（<strong>bio，表示活动的I/O操作； buffer_head，表示块到页的映射</strong>）。然后讨论了请求结构，之后我们重点讨论了内核对请求的调度——I/O调度程序。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《Linux内核设计与实现》</li>
<li>《现代操作系统》</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>VFS</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/posts/41e39f2b/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章总结一下Linux操作系统中内存管理相关知识，比如虚拟内存以及虚拟内存中的分页分表，内存分配算法和slab分配器，缺页中断和页面置换算法，页缓存和页回写等。</p>
</blockquote>
<span id="more"></span>

<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="虚拟内存是什么？"><a href="#虚拟内存是什么？" class="headerlink" title="虚拟内存是什么？"></a>虚拟内存是什么？</h4><p>​    虚拟内存是将整个程序切割成多个片段，在需要的时候将该片段加载入内存，在不需要的时候又将其换出。这样在宏观层次上就可以认为该内存能够完全装满该程序。（但实际上可能内存比程序要小）</p>
<p>​    虚拟内存的基本思想是<strong>每个程序拥有自己的地址空间，避免在加载时重定位</strong>，这个空间被分割成多个快，每个块称作一页或页面。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行。</p>
<p>​    之后会详细的介绍如何实现虚拟内存以及分页技术。</p>
<p>​    Linux使用虚拟内存技术，因此<strong>系统中所有进程之间以虚拟方式共享内存</strong>。对一个进程而言，它好像都可以访问整个系统的所有物理内存。即使单独一个进程，它拥有的地址空间也可以远远大于系统物理内存。</p>
<p>​    </p>
<h4 id="为什么使用虚拟内存"><a href="#为什么使用虚拟内存" class="headerlink" title="为什么使用虚拟内存"></a>为什么使用虚拟内存</h4><p>首先，如果不使用虚拟内存的话，那么就是直接使用物理内存，物理内存的使用会造成以下问题：</p>
<ol>
<li>地址空间不隔离，可能被恶意程序修改其他程序内存数据。</li>
<li>内存使用效率低</li>
<li>程序运行的地址不确定</li>
<li>如果程序的大小大于内存，那该怎么办？</li>
</ol>
<p>这些问题都是直接使用物理内存出现的无法接受的缺点，使用虚拟地址空间能够完美的将这些问题都解决。</p>
<p>首先是第四条，在上文已经介绍过了，程序大小大于内存，将程序分段，可以将不常用的程序段放入磁盘，常用的放在内存中，如果需要磁盘中的程序段的话，操作系统能够动态地将内存换入换出。</p>
<p>针对第一条和第三条，分段能够完美解决：<strong>分段是指将一段与程序所需要的的内存空间大小的虚拟空间映射到某个地址空间。</strong>这样确实能够将程序隔离，但是内存使用效率依旧很低，因此必须使用分页技术，将内存的利用效率提高。</p>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>​    分页的基本思想是把地址空间人为地等分成固定大小的页，每一页的大小有硬件决定，一般来说是4KB（64位就是8KB）。<strong>分页不仅适用于虚拟内存空间，还适用于物理内存空间。</strong></p>
<p>​    由于物理地址和虚拟地址都有页的概念，因此对其加以区分：<strong>物理页称为页框，虚拟页称为页面。</strong></p>
<p>​    内核把物理页作为内存管理的基本单位。虽然说CPU的最小寻址单位是字甚至是字节，但内存管理空间(<strong>MMU, 管理内存并把虚拟地址转换为物理地址的硬件</strong>)通常以页为单位进行处理。<strong>从虚拟内存的角度来看，页就是最小单位。</strong></p>
<p>​    内核用<code>struct page</code>结构表示系统中的每个<strong>物理页</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> 			flags;</span><br><span class="line">    <span class="keyword">atomic_t</span> 				_count;</span><br><span class="line">    <span class="keyword">atomic_t</span> 				_mapcount;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> 			<span class="keyword">private</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> 	*<span class="title">mapping</span>;</span></span><br><span class="line">    <span class="keyword">pgoff_t</span>					index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">lru</span>;</span></span><br><span class="line">    <span class="keyword">void</span> 					*<span class="keyword">virtual</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	flags 	-&gt; 存放页的状态：每一位单独表示一种状态。	如这些页是不是脏的，是不是被锁定在内存中。</span></span><br><span class="line"><span class="comment">*	_count 	-&gt; 存放页的引用计数，如果没被引用，则置为-1。</span></span><br><span class="line"><span class="comment">*	virtual	-&gt; 页的虚拟地址。通常情况下是页在虚拟内存中的地址。</span></span><br><span class="line"><span class="comment">* 	该结构体占40B的内存。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><p>​    </p>
<p>​    上文可知由程序产生的这些地址叫做虚拟地址。因为有了虚拟内存的技术，程序现在处理的是虚拟地址，但是处理器直接操作的仍是物理地址，这样的话当程序去访问一个地址时，首先是要将虚拟地址转化为物理地址。然后处理器才能解析访问请求。</p>
<p>​    <strong>通过内存管理单元MMU将虚拟地址映射为物理内存地址</strong>，该过程称为内存映射。不同的页面能够映射到同一个页框。</p>
<p><strong>页表：</strong></p>
<p>​    内存映射是通过MMU解析该页面的<strong>页表</strong>来实现的，Linux使用了三/四级页表结构完成地址转换。每个进程都会有自己的页表（线程会共享页表）</p>
<p>​    <strong>操作页表的时候必须使用page_table_lock锁</strong></p>
<p>​    页表是把虚拟页面映射为页框，页表项上有个<strong>页框号</strong>，页面就是通过这个来映射到页框的。</p>
<p>然后是一些页表上的位：</p>
<ul>
<li><p>在/不在标志位</p>
<ul>
<li>为0，页面没有映射到页框，访问该页面地址直接引发缺页中断。</li>
<li>为1，可以使用，会有一个页框号的值</li>
</ul>
</li>
<li><p>保护位：允许执行什么操作</p>
<ul>
<li>三位，分别表示读写执行（类似文件）</li>
</ul>
</li>
<li><p>修改位：是否修改（在页面置换，页回写和缓存中很重要）</p>
<ul>
<li>为0，未修改，该页面是“干净”的</li>
<li>为1，已修改，该页面是“脏”的</li>
</ul>
</li>
<li><p>访问位：该页面被访问的次数（读，写，执行）</p>
<ul>
<li>这个标志着该页面使用的频繁程度。</li>
</ul>
</li>
</ul>
<p>值得强调的，虚拟内存本质上是用来创建一个新的抽象概念——地址空间。虚拟地址对物理内存的抽象就像是进程对CPU的抽象。</p>
<h4 id="加速分页过程"><a href="#加速分页过程" class="headerlink" title="加速分页过程"></a>加速分页过程</h4><p>​    目前我们已经了解到了内存映射和分页概念。现在可以讨论可能的实现了。在任何分页系统都需要考虑以下两个主要问题：</p>
<ul>
<li>虚拟地址到物理地址的映射必须快！</li>
<li>如果虚拟地址空间很大，页表也会很大</li>
</ul>
<p>​    针对第一个问题，我们可以使用缓存机制。总所周知的二八原则，百分之八十的时间在跑百分之二十的代码，因此使用缓存去存储这些很常用的页表是很有效的一件事。</p>
<p>​    这个缓存称之为<strong>转换检测缓冲区（TLB）</strong>。一般可以有两种实现：硬件或者软件</p>
<ul>
<li>使用一个在MMU里面的硬件设备，将虚拟地址直接映射到物理地址，而不必再访问页表。<ul>
<li>这样其实会加重MMU的负担，会使得MMU复杂化。但是这种方式很快。</li>
</ul>
</li>
<li>使用一个TLB软件，在内存中的固定位置维护一个大的TLB表项的高速缓存。<ul>
<li>这样能够获得一个简单的MMU，这就在CPU芯片上为高速缓存以及其他改善性能的设计腾出了相当大的空间。</li>
<li>不过这个的效率没有硬件块</li>
</ul>
</li>
</ul>
<p>​    针对第二个问题，大内存的页表，采用多级页表的方法，这样能够避免将所有页表都放在内存中。</p>
<p>使用多级页表，可以出现虽然虚拟空间有超过100万个页面，实际上只有四个页表</p>
<ul>
<li>顶级页表<ul>
<li>正文段（0~4M）</li>
<li>数据段（4~8M）</li>
<li>堆栈段（4M）</li>
</ul>
</li>
</ul>
<p>以上是一级页表和二级页表，二级页表还能继续扩充。目前基本上都使用四级页表。页表寻址通过页目录指针。</p>
<h3 id="缺页中断和页面置换算法"><a href="#缺页中断和页面置换算法" class="headerlink" title="缺页中断和页面置换算法"></a>缺页中断和页面置换算法</h3><h4 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a><strong>缺页中断</strong></h4><p>​    在上面的章节有物理页的数据结构，其中有些变量可以与虚拟页进行关联以及是否为脏页。</p>
<p>​    当程序访问一个未映射页框的页面，那么CPU会陷入到内核，发生缺页中断或者缺页错误（虽然是缺页中断，但其实是软件中断，因为是指令执行因为找到该页面出错而引发的中断）。</p>
<p>​    <strong>操作系统找到一个很少使用的页框且把它的内容写入磁盘（如果它不在磁盘上）。随后把需要访问的页面读到刚才回收的页框中，修改映射关系，然后重新启动引发陷阱的指令。</strong></p>
<p>​    </p>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>​    当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。如果换出的页面在内存驻留期间已经被修改过，就必须把它写回磁盘更新该页面的副本（这称为页回写），如果在磁盘中的副本是最新的，那么直接调入页面覆盖该页面即可。</p>
<p>​    当发生缺页中断时，虽然可以随机选择一个页面进行置换，但是如果每次都选择不常使用的页面会提升系统的性能。因此在页面置换的研究中，发明了几个页面置换算法，下面我们就来看看。</p>
<h5 id="最优页面置换"><a href="#最优页面置换" class="headerlink" title="最优页面置换"></a>最优页面置换</h5><ul>
<li>原理：在缺页中断发生时，这些页面之一将在下一条指令（包含该指令的页面）上被引用。其他页面则可能要到 10、100 或者 1000 条指令后才会被访问。<strong>每个页面都可以用在该页首次被访问前所要执行的指令数作为标记</strong>。通过标记来选择该要置换的算法</li>
<li>特点：无法实现，因为当发生缺页中断时，操作系统无法知道各个页面下一次将在什么时候访问，因此这不现实。</li>
<li>总结：该算法主要是突出一个思想，就是尽量用最近不会使用的页面置换出去。</li>
</ul>
<h5 id="最近未使用页面置换（NRU"><a href="#最近未使用页面置换（NRU" class="headerlink" title="最近未使用页面置换（NRU)"></a>最近未使用页面置换（NRU)</h5><ul>
<li><p>原理：虚拟内存为每一页面都设置了两个状态位，R和M。每当页面被访问（读或写）时设置R位；当页面被写入（即修改）时设置M位。一般在缺页中断的时候，选中的页面R位会置为1（R位会被时钟中断定期清0）</p>
<p>因此，可以通过R和M位来构造简单的页面置换算法：操作系统将其所有页面的两个位都设置为 0。R 位定期的被清零（在每个时钟中断）。用来将最近未引用的页面和已引用的页面分开。</p>
<p>当出现缺页中断后，操作系统会检查所有的页面，并根据它们的 R 位和 M 位将当前值分为四类：</p>
<p>第 0 类：没有引用 R，没有修改 M<br>第 1 类：没有引用 R，已修改 M<br>第 2 类：引用 R ，没有修改 M<br>第 3 类：已被访问 R，已被修改 M</p>
<p>其中第0类很少，可以直接替换，第一类看似没有，但是经过一个时钟中断能够将第三类转换为第一类。</p>
</li>
<li><p>特点：该算法从编号最小的非空类随机删除一个页面。易于理解且能够有效的实现。</p>
</li>
<li><p>总结：在一个时钟内（大概20ms）淘汰一个已修改但是没被访问的页面要比一个大量引用未修改的页面好。</p>
</li>
</ul>
<h5 id="先进先出页面置换（FIFO）"><a href="#先进先出页面置换（FIFO）" class="headerlink" title="先进先出页面置换（FIFO）"></a>先进先出页面置换（FIFO）</h5><ul>
<li>原理：和队列一样，先访问的先被修改。</li>
<li>特点：最最最简单的页面替换算法</li>
<li>总结：FIFO思想还是很重要的，在很多时候都是个简单易懂但不高效的方法</li>
</ul>
<h5 id="第二次机会页面置换"><a href="#第二次机会页面置换" class="headerlink" title="第二次机会页面置换"></a>第二次机会页面置换</h5><p>​    FIFO有个缺陷，入对和出队并不会进行check检查，这样会把经常使用的页面置换出去。因此本算法对FIFO有了一个改进。</p>
<ul>
<li>原理：检查最老页面的R位，如果是0，那就是最老且没有被使用，直接换出，如果是1，清除R位，让该页面放到队尾入队，然后继续检查链表头。</li>
<li>特点：在FIFO上增加了一个检查机制，也是一个很简单的算法，但是效率提高了不少。</li>
<li>总结：FIFO+R位检查机制</li>
</ul>
<h5 id="时钟页面置换"><a href="#时钟页面置换" class="headerlink" title="时钟页面置换"></a>时钟页面置换</h5><p>​    第二次机会页面置换比较合理，但是它经常要在链表中移动页面，降低了效率。本算法继续为上个算法进行改进。</p>
<ul>
<li>原理：<strong>把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面</strong>。当发生缺页中断中，检查表针指向的页面的R位，根据R为采取动作：R为0，淘汰页面，将新的页面插入到这个位置，指针前移; R为1，清除R位并向前移动表针，直到找到R为0的算法。</li>
<li>特点：在上一个算法基础上减少了链表移动页面的次数，效率继续提高</li>
<li>总结： FIFO+R位检查机制+环形链表</li>
</ul>
<h5 id="最少最近使用页面置换（LRU）"><a href="#最少最近使用页面置换（LRU）" class="headerlink" title="最少最近使用页面置换（LRU）"></a>最少最近使用页面置换（LRU）</h5><p>​    LRU老朋友了。在最优页面置换算法中，想要将以后不会被用到的指令页面进行替换，因为以后的使用情况不清楚，所以完全不可行。既然未来的统计不了，那就统计之前的。</p>
<ul>
<li>原理：统计之前的页面使用情况，在缺页中断时，置换未使用时间最长的页面。</li>
<li>特点：理论上可以实现，使用哈希链表，但是代价比较高，需要<strong>在内存中维护一个所有页面的链表</strong>。当然可以通过硬件来实现，不过能够拥有此类硬件的设备比较少。</li>
<li>总结：好方法但是代价高</li>
</ul>
<h5 id="老化算法"><a href="#老化算法" class="headerlink" title="老化算法"></a>老化算法</h5><p>​    老化算法是用软件实现LRU。老化算法是使用多个R位来实现简单的时间记录</p>
<ul>
<li>在R位被添加进来之前先把计数器右移一位。</li>
<li>R位被添加到最左边位</li>
</ul>
<img src="/posts/41e39f2b/%E8%80%81%E5%8C%96%E7%AE%97%E6%B3%95.png" class title="老化算法">

<p>从上图中可以看出</p>
<ul>
<li>在 0 个时钟周期到 1 个时钟周期之间，0，2，4，5 都被引用了，从而把它们的 R 位设置为 1，剩下的设置为 0 。在相关的六个计数器被右移之后 R 位被添加到左侧。</li>
<li><strong>这样八位计数器就能记录着最近八个时钟周期内的页面使用情况，而且这八位越大就代表近期使用越频繁</strong></li>
<li>在发生缺页中断的时候，只要<strong>置换掉计数器值最小的页面</strong>即可。</li>
</ul>
<p>该算法和LRU的差别</p>
<ul>
<li>在一个时钟周期内无法判断哪个先使用，哪个后使用</li>
<li>计数器是有位数的，前第九个时钟周期和前第100个时钟周期使用的页面计数器值都为0</li>
</ul>
<p>总结：老化算法是LRU的一个阉割版，<strong>它牺牲了精度（在同一个时钟周期内的使用先后顺序不管）和广度（只关注最近八个时钟周期）。但是效率大大提升</strong>。</p>
<h5 id="工作集页面置换"><a href="#工作集页面置换" class="headerlink" title="工作集页面置换"></a>工作集页面置换</h5><p>​    一个进程当前使用的页面的集合称为它的工作集。如果整个工作集都在内存中，那么不会产生很多缺页中断；如果内存太小无法容纳整个工作集，那么进程的运行过程中会产生大量缺页中断，导致运行速度变得缓慢。</p>
<p>​    这样一来如果进程切换之后，工作集一般会保留，以待<strong>下一次进程切换回来之后，直接使用预先调页，将这个进程的工作集提前调入内存中。</strong>这样会很好的减少缺页中断，而且工作集是随着时间变化的。</p>
<ul>
<li><p>原理：明白工作集理论之后，该算法基本思路就是找出一个不在工作集中的页面并淘汰它。每个页面表项至少包含两个信息，一个是R位，一个是上次使用页面的时间，每个时钟周期都会将R位清0。之后缺页中断时对页表进行处理。</p>
<ul>
<li><p>R位为1，就会将当前时间写入页表时间，证明该页表在工作集中。</p>
</li>
<li><p>R位为0，检查当前时间，如果<code>当前时间-页表记录时间  &gt; t (t为进程近似运行时间)</code>,那么说明它不在工作集中，这样就可以置换该页面。如果小于等于t，那么说明他在工作集中，去找下一位，如果都是在工作集中，那么置换时间最旧的那个页面。</p>
</li>
</ul>
<p>最坏情况下诗置换一个R位为1的页面。</p>
</li>
<li><p>特点：引入工作集，综合R位和时间，用两个维度来决定页面置换。但是<strong>要扫描整个页表才能确定被淘汰的页面</strong></p>
</li>
<li><p>总结：FIFO+R位检查+工作集时间检查</p>
</li>
</ul>
<h5 id="工作集时钟页面置换（WSClock）"><a href="#工作集时钟页面置换（WSClock）" class="headerlink" title="工作集时钟页面置换（WSClock）"></a>工作集时钟页面置换（WSClock）</h5><ul>
<li><p>原理：基于时钟算法，又结合工作集</p>
<img src="/posts/41e39f2b/WSClock.png" class title="WSClock"></li>
<li><p>特点：数据结构为一个以页框为元素的循环列表。每个表项有三位：R位，M位，上次使用时间</p>
<ul>
<li>R位为1，那么不适合淘汰，将R置为0，然后指针前移。</li>
<li>R位为0，查看工作集的时间，根据工作集算法，判断是否删除。</li>
</ul>
<p>当然如果M为1，那么必须回写。</p>
</li>
<li><p>总结：FIFO+R位检查+工作集时间检查+循环链表</p>
</li>
</ul>
<h5 id="页面置换算法总结"><a href="#页面置换算法总结" class="headerlink" title="页面置换算法总结"></a>页面置换算法总结</h5><img src="/posts/41e39f2b/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" class title="页面置换算法">

<p>总之，最好的算法是老化算法和WSClock算法。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>Linux支持多种内存分配机制。分配物理内存页框的主要机制是<strong>页面分配器，它使用了著名的伙伴算法</strong></p>
<h4 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a>伙伴算法</h4><p>​    简而言之，就是将内存分成若干块，然后尽可能以最适合的方式满足程序内存需求的一种内存管理算法，伙伴算法的一大优势是它能够完全避免外部碎片的产生。Linux把<strong>所有的空闲页框分组为 11 块链表</strong>，每一块链表分别包含大小为1，2，4，8，16，32，64，128，256，512 和 1024 个连续的页框。</p>
<ul>
<li><p>原理：申请时，伙伴算法会给程序分配一个较大的内存空间，即保证所有大块内存都能得到满足。很明显分配比需求还大的内存空间，会产生<strong>内部碎片</strong>。所以伙伴算法虽然能够完全避免外部碎片的产生，但这恰恰是以产生内部碎片为代价的。</p>
</li>
<li><p>举例：假设要请求一个256（129~256）个页框的块。算法先在256个页框的链表中检查是否有一个空闲块。如果没有这样的块，算法会查找下一个更大的页块，也就是，在512个页框的链表中找一个空闲块。如果存在这样的块，内核就把512的页框分成两等分，一般用作满足需求，另一半则插入到256个页框的链表中。如果在512个页框的块链表中也没找到空闲块，就继续找更大的块——1024个页框的块。如果这样的块存在，内核就把1024个页框块的256个页框用作请求，然后剩余的768个页框中拿512个插入到512个页框的链表中，再把最后的256个插入到256个页框的链表中。如果1024个页框的链表还是空的，算法就放弃并发出错误信号。</p>
</li>
<li><p>总结：伙伴算法在分配时找到比申请内存大的二的幂内存块，使用它并标记为可用，同时将该内存分配给应用程序。如果这样的内存不存在，则操作系统将寻找更大快的空闲内存，然后平分该内存。在回收内存的时候，内存大小相同的合并成更大的单独块。 </p>
</li>
<li><p>伙伴： 满足一下条件的叫伙伴</p>
<ul>
<li>两个块具有相同大小，记作b</li>
<li>它们物理地址是连续的</li>
<li>第一个块的第一个页框物理地址是2 * b * 2^12的倍数。</li>
</ul>
</li>
</ul>
<h4 id="获得页"><a href="#获得页" class="headerlink" title="获得页"></a>获得页</h4><p>​    伙伴算法是针对物理页分配的思想，这里我们就来了解下Linux内核是如何获取页和释放页的。</p>
<p>​    内核获得页和释放页是通过下面几个函数来实现的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获得页</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct page* <span class="title">alloc_pages</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span>;</span><br><span class="line"><span class="comment">// 该函数分配 2^order个连续的物理页，并返回一个指针，该指针指向第一个页的结构体，如果出错，那么返回NULL。 gfp是分配器标志。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">page_address</span><span class="params">(struct page* page)</span></span>;</span><br><span class="line"><span class="comment">// 物理地址转换为逻辑地址。</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> __get_free_page(<span class="keyword">gfp_t</span> gfp_mask);</span><br><span class="line"><span class="comment">// 该函数是上面两个函数的结合。</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_zero_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gfp_mask)</span></span>;</span><br><span class="line"><span class="comment">// 返回的页内容全为0.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 释放页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __free_pages(struct page* page, <span class="keyword">unsigned</span> <span class="keyword">int</span> order);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_pages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span>;</span><br><span class="line"><span class="comment">// 上面三个释放函数简单易懂，第一个是中断物理页释放物理页，后面是通过虚拟页来释放。</span></span><br></pre></td></tr></table></figure>

<p>释放页时需谨慎，只能释放属于自己的页。因为CPU在内核态权级很大，内核完全信赖自己。如果删除错误可能会导致系统崩溃。</p>
<h4 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc()"></a><code>kmalloc()</code></h4><p>kmalloc()函数与用户空间的mallo()一族函数非常类似，只不过多了一个flags参数。</p>
<p><strong>kmalloc()函数可以获得一个以字节为单位的内核内存。</strong>（如果需要一整块页，上面的函数更适合你）</p>
<p><strong>kmalloc()保证物理地址上是连续的（自然虚拟地址也是连续的）</strong></p>
<p><strong>kfree()函数释放有kmalloc()分配出来的内存块。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>gfp_mask标志</p>
<p>这个是分配器标志。标志可分为三类：行为修饰符、区修饰符及类型。</p>
<ul>
<li><p>行为修饰符：表示内核应当如何分配所需的内存，在特定情况下只能有特定办法分配内存。如中断情况下不能睡眠。</p>
</li>
<li><p>区修饰符：表示内核从哪里分配内存，Normal，DMA，HighEM。（默认Normal）</p>
</li>
<li><p>类型：组合上面两类修饰符，将各种组合用到的组合归纳为不同类型。</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">修饰符组合</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GFP_ATOMIC</td>
<td align="center">__GFP_HIGH</td>
<td align="center">用于中断处理程序，下半部，持有自旋锁以及其他不能睡眠的地方。</td>
</tr>
<tr>
<td align="center">GFP_NOWAIT</td>
<td align="center">0</td>
<td align="center">与上者类似，不同之处是调用不会退给紧急内存池。</td>
</tr>
<tr>
<td align="center">GFP_NOIO</td>
<td align="center">__GFP_WAIT</td>
<td align="center">可以阻塞，但是不会启动磁盘I/O</td>
</tr>
<tr>
<td align="center">GFP_NOFS</td>
<td align="center"><code>__GFP_WAIT</code></td>
<td align="center"><code>__GFP_IO</code></td>
</tr>
<tr>
<td align="center">GFP_KERNEL</td>
<td align="center"><code>__GFP_WAIT</code></td>
<td align="center"><code>__GFP_IO</code></td>
</tr>
<tr>
<td align="center">GFP_USER</td>
<td align="center"><code>__GFP_WAIT</code></td>
<td align="center"><code>__GFP_IO</code></td>
</tr>
<tr>
<td align="center">GFP_HIGHUSER</td>
<td align="center"><code>__GFP_WAIT</code></td>
<td align="center"><code>__GFP_IO</code></td>
</tr>
<tr>
<td align="center">GFP_DMA</td>
<td align="center">__GFP_DMA</td>
<td align="center">这个是从ZONE_DMA进行分配。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="vmalloc"><a href="#vmalloc" class="headerlink" title="vmalloc()"></a><code>vmalloc()</code></h4><p>​    <strong>vmalloc()函数的工作方式类似于kmalloc(),只不过前者分配的内存虚拟地址是连续的，而物理地址无需连续。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要gfp标志。就是malloc(不过malloc是分配用户空间的，kv二者是关注内核空间)</span></span><br><span class="line"><span class="comment">// 该函数可能睡眠</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">vmalloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* addr)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>这也是用户空间分配函数的工作方式： 由malloc()返回的页在进程的虚拟空间内是连续的，但不保证在物理RAM找那个也是连续的。</strong></p>
<p>​    一般来说，只有硬件设备需要物理地址连续的内存，因此硬件分配内存一定使用kmalloc()。不过vmalloc()函数为了把物理上不连续的页转换为虚拟地址空间上连续的页，必须专门建立页表项。而且获得的页必须一个一个映射，这样映射特别大。因此vmalloc()只有在不得已时才使用——典型就是为了获得大块内存是。</p>
<h4 id="Slab层"><a href="#Slab层" class="headerlink" title="Slab层"></a>Slab层</h4><p>​    分配和释放数据结构是内核中最普遍的操作之一。为了便于数据的频繁分配和回收，Linux内核提供了Slab层（也就是Slab分配器）。</p>
<p>​    slab层扮演了<strong>通用数据结构缓存层</strong>的角色。slab分配器尝试在以下几个基本原则寻求一种平衡</p>
<ul>
<li><p>基本原则：</p>
<ul>
<li>频繁使用的数据结构也会频繁分配和释放，因此应当缓存它们。</li>
<li>频繁分配和后手必然会导致内存碎片。因此使用空闲链表的缓存会连续的存放。因为已释放的数据结构又会放回空闲链表，因此不会导致碎片。</li>
<li>回收的对象可以立即投入下一次分配。</li>
<li>如果分配器知道对象大小、页大小和总高速缓存的大小概念，它能做出更明智的选择。</li>
<li>如果让部分缓存属于单个处理器（对系统上的每个处理器独立而唯一），那么分配和释放就不需要加处理器锁。</li>
<li>对存放的对象进行着色，以防止多个对象映射到相同的高速缓存行。</li>
</ul>
</li>
<li><p>设计</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span>&#123;</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> 	<span class="title">list</span>;</span>		<span class="comment">// 空闲链表</span></span><br><span class="line">   	<span class="keyword">unsigned</span> <span class="keyword">long</span> 		colouroff;	<span class="comment">// slab着色偏移量</span></span><br><span class="line">    <span class="keyword">void</span> 				*s_mem;		<span class="comment">// slab分配的第一个对象</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> 		inuse;		<span class="comment">// slab中已分配的对象数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_bufctl_t</span> <span class="title">free</span>;</span>		<span class="comment">// 第一个空闲对象，如果有的话</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>slab层把不同的对象划分为<strong>高速缓存组</strong>。高速缓存组存放不同类型的对象。每个告诉缓存由一个或多个slab组成。一个slab由多个连续物理页组成。</li>
</ul>
<ul>
<li>每个slab都包含一些对象成员，这些对象成员就是被缓存的数据结构。每个slab有三种状态。<ul>
<li>满：满的slab意味着slab中所有对象都被分配出去了。</li>
<li>部分满：有一部分对象被分配出去了，还有一部分没有。</li>
<li>空：所有对象都是空闲的。</li>
</ul>
</li>
<li>当内核某一部分需要新的对象时，先从部分满slab进行分配，如果没有就从空的slab分配，如果两种都没有就只能创建一个slab。</li>
<li>slab相当于一个高速缓存的专用分配器，可以为具体对象进行分配。</li>
</ul>
</li>
<li><p>接口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高速缓存结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的高速缓存		void(* ctor)(void*)为其构造函数。可以赋值NULL</span></span><br><span class="line"><span class="function">struct kmem_cache* <span class="title">kmem_cache_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> align, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">void</span>(* ctor)(<span class="keyword">void</span>*))</span></span>;</span><br><span class="line"><span class="comment">// 撤销高速缓存 撤销时保证下面所有的slab都为空。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmem_cache_destory</span><span class="params">(struct kmem_cache* cachep)</span></span>;</span><br><span class="line"><span class="comment">// 从缓存中分配对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">kmem_cache_alloc</span><span class="params">(struct kmem_cache* cachep, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 从缓存中释放对象，将该cachep中的对象objp标记为空闲。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_free</span><span class="params">(struct kmem_cache* cachep, <span class="keyword">void</span>* objp)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>总结：slab分配器就相当于是一个<strong>申请内存的高速缓存</strong>。它专门为某一模块预先一次性申请一定数量的内存备用，当这个模块想要使用内存的时候，就不再需要从系统中分配内存了（因为从系统中申请内存的时间开销相对来说比较大），而是直接从预申请的内存中拿出一部分来使用，这样就提高了这个模块的内存申请速度。</p>
</li>
</ul>
<h4 id="在栈上静态分配"><a href="#在栈上静态分配" class="headerlink" title="在栈上静态分配"></a>在栈上静态分配</h4><p>​    内核栈小而且固定。为何如此设计？ 给进程分配一个固定大小的小栈后，不但能够减少内存的消耗，而且内核也无须负担太重的工作。</p>
<p>​    任何一个函数，都必须减少栈的分配。想想什么东西会在栈上分配吧。因此如果要分配大块内存，还是使用动态分配，这样会分配在堆上。</p>
<h4 id="分配内存的选择"><a href="#分配内存的选择" class="headerlink" title="分配内存的选择"></a>分配内存的选择</h4><p><strong>如果需要的是连续物理页，则使用低级页分配器或者kmalloc();</strong> （这是内核常见分配方式）</p>
<p>如果高端内存进行分配，就使用<code>alloc_pages()</code>,然后调用kmap()将高端内存映射到内核的逻辑地址空间中。</p>
<p>如果不需要连续物理页，仅仅需要连续虚拟页，则使用vmalloc(); 这和用户空间的malloc()非常相似。</p>
<p>如果要创建和撤销很多大的数据结构，那么考虑建立<strong>slab高速缓存</strong>。slab分配器建立与空闲链表的数据结构上。slab层会给<strong>每个处理器维持一个对象高速缓存</strong>（空闲链表），这种高速缓存会极大地提高对象分配和回收的机制。 高速缓存避免了频繁分配和释放内存，是事先将分配好的对象放到高速缓存中。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​    本章中，我们从内核的物理页出发，了解了内核的内存管理机制。<strong>伙伴算法和slab高速缓存</strong>是本章的重点。其实这一章之前可以看看之前做的现代操作系统中内存管理的笔记。下一章我们介绍进程地址空间。来看看进程中的内存管理。</p>
<h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><h4 id="地址空间布局"><a href="#地址空间布局" class="headerlink" title="地址空间布局"></a>地址空间布局</h4><p>​    <strong>进程地址空间是指用户空间进程看到的内存。内核进程是没有地址空间的。</strong></p>
<p>​    Linux使用虚拟内存技术，因此<strong>系统中所有进程之间以虚拟方式共享内存</strong>。对一个进程而言，它好像都可以访问整个系统的所有物理内存。即使单独一个进程，它拥有的地址空间也可以远远大于系统物理内存。</p>
<p>​    地址空间</p>
<p>​    进程地址空间由进程可寻址的虚拟内存组成，内核允许进程是用虚拟内存中的地址。每个进程都有一个32位或64位的平坦(flat)地址空间；平坦指的是地址空间范围是一个独立的连续区间。</p>
<p>​    不过操作系统提供了<strong>段地址空间</strong>，一个平坦的地址空间被段分成了几部分。不过现代采用虚拟内存的操作系统通常是使用平坦地址空间的内存模式。</p>
<p>​    如果两个进程的地址空间相同，实际上也互不相干。那我们称这样的进程为线程。</p>
<p>​    内存地址是一个给定的值，它在地址空间范围之内，代表着进程32位地址空间中一个特定的字节。尽管进程可以寻址4GB的虚拟内存，但是并不代表它有权访问所有的虚拟地址。</p>
<p>​    能被合法访问的内存地址称作内存区域。进村只能访问有效内存区域内的内存地址。内存区域包括各种内存对象。</p>
<img src="/posts/41e39f2b/%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" class title="进程地址空间">

<p>地址从低往高：</p>
<ul>
<li>可执行文件代码的内存映射，称为代码段。(.text)</li>
<li>可执行文件的已初始化全局变量的内存映射，称为数据段(.data)</li>
<li>包含未初始化的全局变量的内存映射(.bss)</li>
<li>用于进程用户空间栈（不要和进程内核栈混淆，进程的内核栈独立存在并由内核维护）的内存映射</li>
<li>任何共享内存段</li>
<li>任何匿名的内存映射：堆，比如有malloc()分配的内存（使用mmap和brk）</li>
</ul>
<h4 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h4><p>​    内核使用内存描述符来表示进程地址空间，该结构包含了和进程地址空间有关的全部信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>&#123;</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>	*<span class="title">mmap</span>;</span>				<span class="comment">// 内存区域链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>			<span class="title">mm_rb</span>;</span>				<span class="comment">// VMA形成的红黑树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>	*<span class="title">mmap_cache</span>;</span>		<span class="comment">// 最近使用的内存区域</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			free_area_cache;	<span class="comment">// 地址空间第一个空洞</span></span><br><span class="line">    <span class="keyword">pgd_t</span> 					*pgd;				<span class="comment">// 页全局目录</span></span><br><span class="line">    <span class="keyword">atomic_t</span>				mm_users;			<span class="comment">// 使用地址空间的用户数</span></span><br><span class="line">    <span class="keyword">atomic_t</span>				mm_count;			<span class="comment">// 主使用计数器</span></span><br><span class="line">    <span class="keyword">int</span>						map_count;			<span class="comment">// 内存区域的个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>		<span class="title">mmap_sem</span>;</span>			<span class="comment">// 内存区域的信号量</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>				page_table_lock;	<span class="comment">// 页表锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">mmlist</span>;</span>				<span class="comment">// 所有mm_struct形成的链表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			start_code;			<span class="comment">// 代码段的开始地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			end_code;			<span class="comment">// 代码段的结束地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			start_data;			<span class="comment">// 数据段的开始地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			end_data;			<span class="comment">// 数据段的结束地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			start_brk;			<span class="comment">// 堆的首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			brk;				<span class="comment">// 堆的尾地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			start_stack;		<span class="comment">// 进程栈的首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			arg_start;			<span class="comment">// 命令行参数的首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			arg_end;			<span class="comment">// 命令行参数的尾地址 </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			env_start;			<span class="comment">// 环境变量的首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			env_end;			<span class="comment">// 环境变量的尾地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			rss;				<span class="comment">// 所分配的物理页</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			total_vm;			<span class="comment">// 全部页面数目</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			locked_vm;			<span class="comment">// 上锁的页面数目</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>			saved_auxv[AT_VECTOR_SIZE];	<span class="comment">// 保存的auxv</span></span><br><span class="line">    <span class="keyword">cpumask_t</span>				cpu_vm_mask;		<span class="comment">// 懒惰TLB交换掩码</span></span><br><span class="line">    <span class="keyword">mm_context_t</span>			context;			<span class="comment">// 体系结构特殊数据</span></span><br><span class="line">    unsigned_long			flags;				<span class="comment">// 状态标志</span></span><br><span class="line">    <span class="keyword">int</span> 					core_waiters;		<span class="comment">// 内核转储等待线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">core_state</span>		*<span class="title">core_state</span>;</span>		<span class="comment">// 核心转储的支持</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>				ioctx_lock;			<span class="comment">// AIO I/O链表锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>		<span class="title">ioctx_list</span>;</span>			<span class="comment">// AIO I/O链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    mm_users域记录正在使用该地址的进程数目。（线程共享）</p>
<p>​    mmap和mm_rb两个不同的数据结构描述的对象是相同的：<strong>该地址空间中的全部内存区域。 前者以链表的形式存放而后者以红-黑树的方式存放。</strong>这个冗余是有必要的，既可以快速搜索元素，也可以快速遍历元素。</p>
<ul>
<li><p>分配内存描述符</p>
<ul>
<li><p>在进程描述符<code>task_struct</code>中的mm域里面存放的就是内存描述符。<strong>每个进程都有唯一的进程地址空间。</strong></p>
</li>
<li><p><strong>fork函数利用copy_mm()复制父进程的内存描述符。然后再利用alloctate_mm()从slab缓存中分配自己的进程地址空间。</strong></p>
</li>
<li><p><strong>如果父进程希望和子进程共享空间，可以调用clone()时，设置clone_vm标志</strong>。这样就是线程。</p>
</li>
</ul>
</li>
<li><p>撤销内存描述符</p>
<ul>
<li>当进程退出时，内核会调用exit_mm(),该函数执行常规的撤销工作，然后减少mm_users的计数。</li>
<li>当mm_users计数到0，调用mmdrop()函数，减少mm_count主使用计数器。</li>
<li>如果mm_count也减少到0， 说明内存描述符没有任何使用者，调用free_mm()将结构体归还到mm_cachep_slab缓存中。</li>
</ul>
</li>
<li><p>内核线程</p>
<p><strong>内核线程没有用户空间，因此也没有进程地址空间，也没有相关的内存描述符。</strong></p>
</li>
</ul>
<h4 id="虚拟内存区域"><a href="#虚拟内存区域" class="headerlink" title="虚拟内存区域"></a>虚拟内存区域</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>&#123;</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>	*<span class="title">vm_mm</span>;</span>			<span class="comment">// 相关的mm_struct结构体</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> 			vm_start;		<span class="comment">// 区间首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> 			vm_end;			<span class="comment">// 区间尾地址	（左闭右开）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span>	*<span class="title">vm_next</span>;</span>		<span class="comment">// vma链表</span></span><br><span class="line">    <span class="keyword">pgprot_t</span> 				vm_page_prot;	<span class="comment">// 访问控制权限</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> 			vm_flags;		<span class="comment">// 标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>			<span class="title">vm_rb</span>;</span>			<span class="comment">// 树上的该VMA节点</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span>									<span class="comment">// 关联与address_space-&gt;i_mmap字段,或者是关联于</span></span><br><span class="line">        <span class="comment">// address_space-&gt;i_mmap_nonlinear 字段</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span></span><br><span class="line">            <span class="keyword">void</span>				*parent;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_strcut</span> *<span class="title">head</span>;</span></span><br><span class="line">        &#125;vm_set;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">    &#125;shared;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> 		<span class="title">anon_vma_node</span>;</span>	<span class="comment">// anon_vma项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span>			*<span class="title">anon_vma</span>;</span>		<span class="comment">// 匿名VMA对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span>	*<span class="title">vm_ops</span>;</span>	<span class="comment">// 相关操作表</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> 			vm_pgoff;		<span class="comment">//	文件中的偏移量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> 			*<span class="title">vm_file</span>;</span>		<span class="comment">// 被映射的文件</span></span><br><span class="line">    <span class="keyword">void</span> 					*vm_private_data;<span class="comment">// 私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    每个内存描述符都对应与进程地址空间唯一区间。</p>
<p>​    vm_mm域指向和VMA相关的mm_struct结构体。每个VMA对其相关的mm_struct结构体来说是唯一的，所以即使在两个独立的进程将同一文件映射到它们自己的进程地址空间内，它们会分别生成一个结构体标志自己的内存区域。相反，如果两个线程共享同一个地址空间，那么他们也共享其中所有vm_area_struct结构体。</p>
<ul>
<li><p>VMA标志</p>
<p>VMA标志反映了内核处理页面所需要的遵守的行为准则</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">对VMA及其页面的影响</th>
</tr>
</thead>
<tbody><tr>
<td align="center">VM_READ</td>
<td align="center">页面可读取</td>
</tr>
<tr>
<td align="center">VM_WRITE</td>
<td align="center">页面可写</td>
</tr>
<tr>
<td align="center">VM_EXEC</td>
<td align="center">页面可执行</td>
</tr>
<tr>
<td align="center">VM_SHARED</td>
<td align="center">页面可共享</td>
</tr>
</tbody></table>
<p>还有很多没有写出来。这些是最基本的。</p>
</li>
<li><p>VMA操作</p>
<p>对虚拟内存地址相关操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">open</span><span class="params">(struct vm_area_struct* area)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">close</span><span class="params">(struct vm_area_struct* area)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="操作内核区域"><a href="#操作内核区域" class="headerlink" title="操作内核区域"></a>操作内核区域</h4><p>​    内核对指定区域操作是非常频繁的，这同时也是mmap()例程的基础</p>
<ul>
<li><p>给定内存地址属于哪个区域</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct vm_area_struct* <span class="title">find_vma</span><span class="params">(struct mm_struct* mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>//…</p>
</li>
</ul>
<h4 id="操作地址空间"><a href="#操作地址空间" class="headerlink" title="操作地址空间"></a>操作地址空间</h4><ul>
<li><strong>mmap()和do_mmap()：创建地址区间</strong></li>
</ul>
<p>​    <strong>内核使用do_mmap()创建一个新的线性地址区间</strong>。如果该区间和已存在的地址区间相邻，并且具有同样的访问权限，那么两个区间会合并成一个VMA。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">do_mmap</span><span class="params">(struct file *file, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> len, <span class="keyword">unsigned</span> <span class="keyword">long</span> prot,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">unsigned</span> <span class="keyword">long</span> flag, <span class="keyword">unsigned</span> <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 该函数映射由file指定的文件，具体映射的是文件中从偏移offset开始，长度为len字节的范围内数据。 </span></span><br><span class="line"><span class="comment">// 如果file是NULL并且offset = 0; 那就代表和文件没关系，称为匿名映射。</span></span><br><span class="line"><span class="comment">// 如果这两个值有意义的话，那么称该映射为文件映射。</span></span><br></pre></td></tr></table></figure>

<p>​    在用户空间可以通过mmap()系统调用获取内核函数do_mmap()de gongneng .</p>
<ul>
<li><p><strong>munmap()和do_munmap()：删除地址区间</strong></p>
<p>do_munmap()函数从特定的进程地址空间中删除地址区间。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_munmap</span><span class="params">(struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>​    本章讲了下进程地址空间以及内核如何表示和操作这个空间。最后还讨论了页表。下一章我们通过页表去讨论下页缓存和数据回写。</p>
<p>​    这两章都是站在内存的角度看内存管理，如果要细致的了解内存管理的知识，首先先去看《MOS》中的相关章节，了解下缺页中断和页面置换算法吧！</p>
<h3 id="页高速缓存和回写"><a href="#页高速缓存和回写" class="headerlink" title="页高速缓存和回写"></a>页高速缓存和回写</h3><p>​    <strong>页高速缓存是Linux内核实现磁盘缓存。主要用来减少磁盘的I/O操作。</strong>具体的讲，就是将那些容易被访问的磁盘数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。</p>
<p>​    <strong>回写就是将高速缓存中变更的数据重新写到磁盘中去。</strong></p>
<h4 id="缓存手段"><a href="#缓存手段" class="headerlink" title="缓存手段"></a>缓存手段</h4><p>​    <strong>页高速缓存是由内存中的物理页框组成的，</strong>其内容对应磁盘上的物理块。页高速缓存大小能够自适应调整。</p>
<ul>
<li><p>流程</p>
<p>当内核开始一个读操作（比如发起一个read()系统调用），它首先会检查需要的数据是否在高速缓存中。如果在直接从内存中读取，这个行为叫<strong>缓存命中</strong>。如果数据没有在缓冲中，称为缓存未命中，那么内核必须调度块I/O从磁盘中读取数据。然后将读取的数据放到页缓存中。</p>
</li>
<li><p>写缓存</p>
<p>Linux采取“回写”策略。在这个策略下，<strong>程序执行写操作直接写到缓存中，后端存储不会立刻直接更新</strong>，而是将页高速缓存这一页标记为“脏”，并将其添加到一个脏也链表中。然后统一由<strong>一个进程（回写进程）周期性将脏页链表中的页写回到磁盘</strong>，从而让磁盘中的数据和内存中最终一致。</p>
</li>
<li><p>缓存回收</p>
<p>Linux的缓存回收是通过<strong>选择干净页（不脏）进行简单替换</strong>。如果干净页不足，强行执行回写操作，以腾出更多的干净可用页。然后<strong>回收那些以后最不可能使用的页面</strong>。如何选择到这些页面？</p>
<ul>
<li>LRU算法</li>
<li>双链策略：维持两个链表——活跃链表和非活跃链表。两个链表都是通过LRU维护的，<strong>活跃链表是不可能换出的，只可能换出非活跃链表。</strong></li>
</ul>
</li>
</ul>
<h4 id="Linux页高速缓存"><a href="#Linux页高速缓存" class="headerlink" title="Linux页高速缓存"></a>Linux页高速缓存</h4><p>​    Linux页高速缓存使用了一个<strong>新对象管理缓存项</strong>和页I/O操作。这个对象是<code>addree_space</code>,和<code>vm_area_struct</code>物理地址是对等体。</p>
<p>​    <code>Address_space</code>结构往往和某些内核对象关联.通常情况下,会与一个索引节点(inode)关联.此时host域便宜指向该索引节点.a_ops域指向地址空间对象中的操作函数表.由address_space_operations结构体表示。</p>
<ul>
<li><p>页面读操作流程<br>(1). linux内核试图在页高速缓存中找到需要的数据，find_get_page(mapping, index)负责<br>(2). 若没有找到，page_cache_alloc_cold(mapping), add_to_page_cache_lru(page, mapping, index)内核分配一个新页面，然后将之前搜索的页加入高速缓存中。<br>(3). 需要的数据从磁盘被读入，再被加入页高速缓存. mapping-&gt;a_ops-&gt;readpage(file, page)</p>
</li>
<li><p>页面写流程<br>当页被写了，VM仅需要调用SetPageDirty(page)，即可，内核晚些时候会通过writepage()方法写出。<br>特定文件的写操作路径包括：<br>(1). page = __grab_cache_page(mapping,index,&amp;cached_page,&amp;lru_prec);在页高速缓冲中搜索需要的页，不在则分配。<br>(2). status = a_ops-&gt;prepare_write(file,page,offset,offset+bytes);创建一个写请求<br>(3). page_fault = filemap_copy_from_user(page, offset, buf, bytes);数据从用户空间拷贝到内核<br>(4). status = a_ops-&gt;commit_write(file, page, offset, offset + bytes);数据写入磁盘</p>
</li>
<li><p>基树</p>
<p>因为在任何页I/O操作前内核需要检查页是否已经在页高速缓存中，因此这种频繁的查找必须快。</p>
<p>页高速缓存通过address_space和一个偏移量进行搜索，每个address_space对象都有唯一的基树，页高速缓存的搜索函数find_get_page()要调用函数radix_tree_lookup()进行查找。</p>
</li>
</ul>
<h4 id="flusher线程"><a href="#flusher线程" class="headerlink" title="flusher线程"></a>flusher线程</h4><p>​    该线程是负责脏页写回磁盘。脏页被写回磁盘有三种情况。</p>
<ul>
<li><strong>当空闲内存低于一个特定的阈值时</strong>（即缓存需要回收的时候）</li>
<li><strong>当脏页在内存中驻留时间超过特定阈值时</strong></li>
<li><strong>当用户进程调用sync()和fsync()系统调用时</strong><br>由一群内核线程(flusher线程)执行这3种工作。</li>
</ul>
<p>空闲内存比阈值dirty_background_ratio低时，内核调用flusher_threads()唤醒一个或多个线程，随后flusher线程调用bdi_writeback_all()开始将脏页写回，直到有指定的最小数目的页被写出到磁盘或达到阈值。<br>为达到第二个条件，<strong>flusher线程会被周期性唤醒</strong>。 内核初始化一个定时器，周期唤醒flusher线程，随后使其运行wb_writeback()刷回。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>​    本章只需要明白以下两点</p>
<ul>
<li>页高速缓存对写缓存的手段，已经如何执行缓存回收。</li>
<li>脏页的产生，回写的条件，回写是交给专门的线程来执行的。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内存管理的重点其实是分为这几个部分</p>
<ul>
<li><p>虚拟内存</p>
<ul>
<li>为什么要有虚拟内存</li>
<li>虚拟内存实现</li>
</ul>
<p>虚拟内存是基础，由此可以与各个部分进行结合。</p>
</li>
</ul>
<blockquote>
<p>与进程结合：进程内的虚拟内存——进程地址空间</p>
</blockquote>
<ul>
<li>进程地址空间<ul>
<li>地址空间布局</li>
</ul>
</li>
</ul>
<blockquote>
<p>虚拟内存不是凭空而来的，内核如何去分配内存</p>
</blockquote>
<ul>
<li>内存分配<ul>
<li>伙伴算法</li>
<li>分配页，分配字节</li>
<li>slab缓存</li>
</ul>
</li>
</ul>
<blockquote>
<p>虚拟内存当发生缺页中断，如何进行页面置换？如何能够提高页面置换效率以及页回写</p>
</blockquote>
<ul>
<li>缺页中断</li>
<li>页面置换算法<ul>
<li>老化算法</li>
<li>WSClock算法</li>
</ul>
</li>
<li>页高速缓存</li>
<li>脏页回写</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《现代操作系统》</li>
<li>《Linux内核设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>虚拟内存</tag>
        <tag>进程地址空间</tag>
        <tag>缺页中断</tag>
        <tag>页面置换</tag>
        <tag>内存分配</tag>
        <tag>页缓存和页回写</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统简介</title>
    <url>/posts/a6fc81d9/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章来简单介绍一下操作系统是什么以及其构成。该文章只是简单介绍，如果</p>
</blockquote>
<span id="more"></span>

<h3 id="简介：什么是操作系统"><a href="#简介：什么是操作系统" class="headerlink" title="简介：什么是操作系统"></a>简介：什么是操作系统</h3><p>现代计算机由处理器，主存，磁盘，键盘鼠标即其它输入输出设备组成。现代计算机系统是一个复杂的系统，由很多硬件组成，为了管理这些硬件，计算机安装了一层软件，称为<strong>操作系统</strong>。</p>
<p>因此操作系统是一个管理计算机的软件。</p>
<table>
<thead>
<tr>
<th>用户态</th>
<th align="center">用户程序</th>
</tr>
</thead>
<tbody><tr>
<td>用户态</td>
<td align="center">用户接口程序</td>
</tr>
<tr>
<td>内核态</td>
<td align="center">操作系统</td>
</tr>
<tr>
<td>硬件</td>
<td align="center">硬件</td>
</tr>
</tbody></table>
<p>从上表中可以看出计算机的大概结构，用户是直接和用户程序打交道的，用户程序然后通过用户接口程序中的系统调用来进入操作系统内核。操作系统内核是负责管理整个系统的核心。内核通过中断来与硬件进行”交流”。这便是计算机系统的基本结构。</p>
<p><strong>启动Linux系统做了什么？</strong></p>
<ol>
<li>BIOS加电自检，对硬件进行检测和初始化</li>
<li>启动第一个扇区，即主引导记录（MBR)，将其读入到一个固定的内存区域并执行一个名为boot的独立程序。</li>
<li>boot程序读取气动设备的根目录，读入操作系统并把控制权交给内核</li>
<li>系统内核运行，配置内核数据结构等。</li>
</ol>
<h3 id="概念：操作系统里的基本概念"><a href="#概念：操作系统里的基本概念" class="headerlink" title="概念：操作系统里的基本概念"></a>概念：操作系统里的基本概念</h3><h4 id="操作系统状态"><a href="#操作系统状态" class="headerlink" title="操作系统状态"></a>操作系统状态</h4><p>首先，操作系统是有状态的，一般是0~3四种状态，但使用的基本上就是用户态（3）和内核态（0）。</p>
<p>用户态和内核态的区别：</p>
<ul>
<li>用户态和内核态的本质区别在于处于这两个状态的程序的权限不同，用户态只能获得有限的权力，不能修改操作系统的配置。</li>
<li>用户态和内核态的地址空间不同，用户态的地址空间为0<del>3G，内核地址空间为3</del>4G（在32bitOS下）。这样也保证了其权限的不同。</li>
</ul>
<h4 id="内核结构"><a href="#内核结构" class="headerlink" title="内核结构"></a>内核结构</h4><p>​    <img src="/posts/a6fc81d9/%E5%BE%AE%E5%86%85%E6%A0%B8.png" class title="内核结构"></p>
<p>上图为内核的基本结构，从上图中我们可以得到一些有关内核的基本知识：</p>
<ul>
<li><p>内核落在硬件之上，负责实现与I/O设备和存储管理单元的交互，并控制对前述设备的访问。</p>
</li>
<li><p>内核也分层次。最底层和硬件交互的是<strong>中断和分配器</strong>，同时还存在一个分派机制。分派机制在中断时发生，<strong>底层代码中止正在运行的进程，并且将其状态存储在内核进程结构中</strong>（这就是利用中断来切换进程），然后启动相应的程序。</p>
</li>
<li><p>在中断之上的层次就是三大部件：<strong>I/O部件， 内存管理部件， 进程管理部件</strong></p>
<ul>
<li><p>I/O部件是负责所有与<strong>设备交互</strong>以及实现<strong>联网</strong>和<strong>存储（文件）</strong>的I/O功能的内核部件。在最高层，这些I/O功能全部整合在一个<strong>虚拟文件系统</strong>层中。</p>
</li>
<li><p>在虚拟文件系统下面安装有三个小类，分别对应上一条的设备交互，联网和存储。其中设备交互类有着字符设备驱动和规则。<strong>联网有着网络设备驱动和网络协议以及套接字。存储有着块设备驱动和I/O调度器，文件系统等。</strong></p>
<p>（其中这里的驱动可以理解为对硬件的管理和抽象）</p>
</li>
<li><p>进程管理部件最主要的任务就是<strong>进程的创建和终止</strong>。这里也有进程调度器，负责选择下一步运行哪个进程或线程。（进程和线程都是统一的调度策略）</p>
</li>
<li><p>内存管理部件：<strong>维护好虚拟地址和物理地址的映射关系，维护最近被访问页面的缓存以及实现一个好的页面置换算法并且根据需要把需要的数据和代码页读入内存中。</strong></p>
</li>
</ul>
</li>
<li><p>处在内核最顶层的就是系统调用接口</p>
</li>
</ul>
<p>对于操作系统中的三大部件，我们分别深入到内核中慢慢分析，并作以笔记。下面我们来继续看一看操作系统中的相关概念。</p>
<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>​    进程是操作系统最核心的概念，进程是对正在运行程序中的一个抽象。操作系统其他所有内容都是围绕着进程来展开的。同时，进程也是多道设计程序的基础，通过进程能够在单CPU很容易的实现并行（伪并发）。</p>
<p>进程相关的知识点有</p>
<ul>
<li>进程的数据结构</li>
<li>进程创建运行终止过程</li>
<li>进程状态</li>
<li>进程切换与调度</li>
<li>进程间通信</li>
</ul>
<p>同时，在进程的基础上有了线程，线程的相关知识点有</p>
<ul>
<li>线程的数据结构</li>
<li>线程的实现</li>
<li>线程和进程的区别（优势和特点）</li>
<li>线程同步</li>
</ul>
<p>随着技术的日新月异，现在又在这二者的基础上创建了协程，协程的相关知识点有</p>
<ul>
<li>协程概念</li>
<li>有栈协程和无栈协程</li>
</ul>
<p>目前现在正在看协程相关知识，但是还没有实际运用，所以对于协程来说能有个基本的了解就可以了</p>
<h4 id="内存及内存管理"><a href="#内存及内存管理" class="headerlink" title="内存及内存管理"></a>内存及内存管理</h4><p><strong>内存</strong></p>
<p>内存是计算机系统不可或缺的硬件，一般来说硬件内存分为以下几个部分。</p>
<img src="/posts/a6fc81d9/%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" class title="存储层次结构">

<p>顶级的存储器速度最高，但是容量最小，成本也非常高。这里来介绍一下寄存器和高速缓存和主存</p>
<ul>
<li>存储器的顶层是 CPU 中的<code>寄存器</code>，它们用和 CPU 一样的材料制成，所以和 CPU 一样快。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）</li>
<li>位于寄存器下面的是高速缓存，它多数由硬件控制。主存被分割成高速缓存行(cache lines) 为 64 字节，内存地址的 0 - 63 对应高速缓存行 0 ，地址 64 - 127 对应高速缓存行的 1，等等。使用最频繁的高速缓存行保存在位于 CPU 内部或非常靠近 CPU 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是<strong>高速缓存命中</strong>(cache hit)。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。</li>
<li>在上面的层次结构中再下一层是<code>主存</code>，这是内存系统的主力军，主存通常叫做 <code>RAM(Random Access Memory)</code></li>
</ul>
<p><strong>虚拟内存</strong></p>
<p>操作系统一般都支持虚拟内存的机制，这种机制能够使期望运行的存储空间大于机器的物理存储空间。</p>
<p><strong>其方法是将程序放在磁盘上，而将主存作为一部分缓存，去存放那些使用最为频繁的程序。</strong></p>
<p>虚拟内存和物理内存的准换由MMU完成，是通过多级页表结构来实现转换的。</p>
<p>综上可以总结出内存及内存管理的一些知识点</p>
<ul>
<li><p>物理内存的地址空间</p>
</li>
<li><p>物理内存与虚拟内存的转换</p>
</li>
<li><p>虚拟内存的分页，页表</p>
</li>
<li><p>内存的分配算法</p>
</li>
<li><p>slab分配器</p>
</li>
<li><p>缺页中断和页面置换算法</p>
</li>
<li><p>页缓存和页回写</p>
</li>
</ul>
<h4 id="文件系统与I-O设备"><a href="#文件系统与I-O设备" class="headerlink" title="文件系统与I/O设备"></a>文件系统与I/O设备</h4><p>​    文件是由进程创建的逻辑信息单元，可以将每个文件都看做是一个独立的进程地址空间。进程能够读取已经存在的文件，并在需要时重新创建他们。存储在文件中的信息必须是<code>持久的</code>，这也就是说，不会因为进程的创建和终止而受影响。</p>
<p>​    操作系统内核在底层文件系统接口上建立了一个抽象层，该抽象层叫做VFS层，在VFS中，所有底层文件都是相同的，这样能够方便处理和操作</p>
<p>​    其实文件系统内容很多，但是不算是特别重点，以下这些知识点需要了解</p>
<ul>
<li>VFS及VFS对象<ul>
<li>超级块对象</li>
<li>索引节点对象</li>
<li>目录项对象</li>
<li>文件对象</li>
</ul>
</li>
<li>文件相关的数据结构</li>
</ul>
<p>之后就是I/O设备相关的知识</p>
<ul>
<li><p>流设备相关概念</p>
</li>
<li><p>块设备结构</p>
</li>
<li><p>块设备调度程序（linux电梯）</p>
</li>
<li><p>模块</p>
</li>
</ul>
<h3 id="其他：计算机系统中的接口"><a href="#其他：计算机系统中的接口" class="headerlink" title="其他：计算机系统中的接口"></a>其他：计算机系统中的接口</h3><p>在计算机系统分层中，我们了解到了用户态，内核态和硬件。那么操作系统使用什么手段将这些层次进行分层呢？</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>系统调用是用户态访问内核态的唯一手段</p>
<ul>
<li>系统调用的概念</li>
<li>系统调用程序</li>
<li>系统调用上下文</li>
</ul>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断是内核和硬件通信的唯一正常手段（异常不是正常手段）</p>
<ul>
<li>中断的概念</li>
<li>中断处理程序</li>
<li>中断上下文</li>
<li>下半部环境</li>
<li>软中断，tasklet和工作队列</li>
</ul>
<h4 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h4><p>同时，现代计算机系统都有多个CPU，在多个CPU中会出现并发操作，这就需要内核同步方法</p>
<ul>
<li>自旋锁</li>
<li>信号量</li>
<li>互斥锁（基于futex）</li>
<li>顺序锁和屏障</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>内核同步是需要防范死锁，死锁也是个重要知识点</p>
<ul>
<li>死锁概念</li>
<li>死锁的条件</li>
<li>如何防范死锁</li>
</ul>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>最后，我们来学习一下内核中的时间概念</p>
<ul>
<li>节拍率</li>
<li>硬时钟与定时器</li>
<li>时钟中断程序</li>
<li>使用定时器</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《现代操作系统》</li>
<li>《Linux内核设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理</title>
    <url>/posts/852cfab6/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章主要讲述的是操作系统的进程管理部分。进程管理部分包括进程的数据结构，进程状态与创建终止过程，进程之间的通信，进程调度方法，线程和内核同步等知识点。</p>
</blockquote>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h4><ul>
<li>进程概念：<strong>进程是处于执行期的程序以及相关的资源总称。</strong></li>
<li>相关资源：打开的文件，挂起的信号，内核内部数据，处理器状态，内存地址空间和执行线程，以及用来存放全局变量的段。</li>
<li>进程通过fork系统调用创建，exec函数创建新的地址空间，并把新的程序载入其中。 （<strong>fork实际上是由clone系统调用实现的</strong>） 最后程序通过exit系统调用终结进程并将其占用的资源释放掉。 <ul>
<li><strong>子进程退出执行后被设置为僵尸状态，直到父进程调用wait获取子进程的终止状态</strong>（如果不获取，那么父进程的进程表项一直有这个子进程的信息。）</li>
<li>子进程退出执行前父进程已经退出了，这样<strong>子进程变为孤儿进程</strong>，其父进程会变成init进程，而init进程会循环地wait已经退出的子进程，负责善后工作。</li>
<li>如何解决僵尸进程？只要将其父进程kill掉，那么他们变成孤儿进程，再让init进程处理后事。</li>
</ul>
</li>
</ul>
<h4 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h4><ul>
<li>进程描述符（数据类型为 <code>task_struct</code>) 包含了一个具体进程的所有信息。</li>
<li>内核将进程描述符存放在一个双向循环链表中，这个链表叫做<strong>任务队列</strong>。</li>
<li><code>task_struct</code>相对比较大，大约有1.7KB(32 bit机器上)，<strong>Linux通过slab分配器动态生成<code>task_struct</code>,<code>task_struct</code>存放在该进程的内核栈尾端的<code>thread_info</code>结构中。</strong></li>
<li>要想提取<code>task_struct</code>， 直接在栈上调用<code>current_thread_info()-&gt;task</code>即可。</li>
</ul>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>​    在进程fork之后，直到进程停止。进程总共有三种状态：<strong>就绪态、运行态、阻塞态。</strong></p>
<ul>
<li><p>进程的状态值存放在<code>task_struct</code>中的<code>state</code>域，如果想设置状态则执行<code>task-&gt;state = State</code></p>
<p>state的值可以是<code>TASK_RUNNING</code>（运行态和就绪态）, <code>TASK_INTERRUPTIBLE</code>（可中断阻塞）,<code>TASK_UNINTERRUPTIBLE</code>（不可中断，如创建进程时）,<code>TASK_TRACED</code>（被其他进程追踪的进程）, <code>TASK_STOPPED</code>（进程停止执行）。</p>
</li>
<li><p>运行态：进程正在执行，即该进程正在占据CPU。（这是进程在用户空间执行的唯一可能状态，其他两个状态只能在内核空间存在）</p>
</li>
<li><p>就绪态：进程是可执行的，但是CPU被其他进程所占据着，这个时候进程在运行队列等待执行。</p>
</li>
<li><p>阻塞态：<strong>进程正在发生睡眠，等待某些条件的达成才能唤醒该进程。唤醒的进程转换到运行态</strong>。（但是也有在睡眠中的进程不可中断，不被其他因素影响。这种进程用得很少）</p>
</li>
</ul>
<h4 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h4><p>​    程序是运行在进程上下文（context）中。上下文是指程序正常运行所需要的环境。抢占指的是在发生中断或者系统调用之后，在该进程还没有结束时就进行上下文切换执行另外一个进程。</p>
<p><strong>上下文切换指的是进程的调度</strong>，大概分为三步：</p>
<ol>
<li><p>保存当前进程的上下文</p>
</li>
<li><p>恢复先前被抢占进程的已保存的上下文</p>
</li>
<li><p>将控制转移到新进程</p>
</li>
</ol>
<p>至于进程调度的具体行为和算法<code>schedule()</code>，后文再说。</p>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>Unix的进程创建分为两步： fork() , exec()</p>
<ul>
<li><p>fork 通过拷贝当前进程生成一个子进程。父子进程的区别仅仅在于PID和PPID，某些资源和统计量（如挂起的信号，子进程没有必要继承）</p>
</li>
<li><p>exec 负责读取可执行文件并将其载入地址空间开始运行。</p>
</li>
<li><p>写时拷贝（copy on write）： 这是在fork函数中使用的一种可以推迟甚至免除拷贝的技术。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。但是如果该页没有被写入的情况下，不会拷贝。</p>
<p><strong>（如果fork之后直接接exec，那就不会复制）</strong></p>
</li>
<li><p>fork的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。</p>
</li>
</ul>
<p>Linux通过clone系统调用来实现fork的，clone再去调用<code>do_fork()</code></p>
<ul>
<li><p>do_fork 完成了创建中的大部分工作。该函数调用copy_process()函数，然后让进程开始运行。</p>
<p>copy_process() 流程：</p>
<ul>
<li>调用<code>dup_task_strcut()</code>为<strong>新进程创建一个内核栈，thread_info结构和task_struct</strong>，这些值与当前进程相同。此时两个进程描述符是相同的。</li>
<li>检查并确保新创建这个子进程后，用户拥有进程的数量没有超过给它分配的资源限制。</li>
<li>子进程开始使自己与父进程区别开来，将进程描述符内的一些成员初始化。但是大部分成员依旧未修改。</li>
<li>子进程状态被设置为 <code>TASK_UNINTERRUPTIBLE</code>（不可中断），保证其不会运行。</li>
<li>调用copy_flags()更新task_struct中的flags成员。</li>
<li>调用alloc_pid()为新进程分配一个pid</li>
<li>根据传递给clone()的参数标志，copy_process()<strong>拷贝或共享</strong>打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。（一般来说，进程中的所有线程共享资源，但是不同进程就只能拷贝资源）</li>
<li>最后扫尾工作并返回一个指向子进程的指针。</li>
</ul>
</li>
</ul>
<h4 id="Linux中线程实现"><a href="#Linux中线程实现" class="headerlink" title="Linux中线程实现"></a>Linux中线程实现</h4><p>​    线程机制同样是现代编程技术中常用的一种抽象概念。该机制提供了再同一程序内共享内存地址空间运行的一组线程。线程机制支持并发程序设计技术，在多核中，实现了真正的并行处理。</p>
<p>​    从Linux内核来看，没有线程这个概念。所有的线程都是当做进程来实现的，<strong>线程只是一个被视为与其他进程共享某些资源的进程</strong>。每个线程也有一个task_struct。</p>
<p>创建线程：线程的创建和普通进程的创建类似。只不过调用clone()的时候需要传递一些额外的参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进程的创建：fork</span></span><br><span class="line">clone(SIGCHLD, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 线程的创建：</span></span><br><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>);</span><br><span class="line">这些标志决定了新创建进程的行为方式和父子进程之间共享的资源种类</span><br></pre></td></tr></table></figure>

<p>内核线程：独立运行在内核空间的标准进程。 内核线程和普通进程间的区别在于<strong>内核线程没有独立的地址空间。只能在内核中运行，不能切换到用户空间中</strong>。只能被内核线程创建。但是和普通进程一样，可以被调度，也可以被抢占。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef // 可以查看内核线程</span><br></pre></td></tr></table></figure>



<h4 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h4><p>当进程终结时，内核必须释放它所占用的资源并且将此消息告知给父进程。</p>
<p>进程主动或者被动调用exit时，进程会调用do_exit()函数，该函数执行完将进程相关联的所有资源都被释放掉，进程不可运行并且处于EXIT_ZOMBIE状态。<strong>它所占有的内存就是内核栈、thread_info结构和task_struct结构</strong>。此时这个进程存在的唯一目的就是向它的父进程提供信息。（这是僵死状态）</p>
<p>父进程执行wait函数之后，等待子进程退出。子进程执行完exit，父进程检索到信息后，然后释放进程描述符，进程的所有内存都被释放，归还给系统使用。</p>
<p>​    </p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在本章中，我们介绍了操作系统的核心概念——进程。</p>
<p>首先我们讨论了进程的一般特性，进程与线程之间的区别，如何创建进程(clone)，如何把新的执行映像装入到地址空间(exec)，如何表示进程的层次关系，父进程优势如何收集其后代的信息(wait)，以及进程如何消亡(exit)。</p>
<p>下一章进程调度。内核以何种方式决定那个进程运行，何时运行，以何种顺序执行？</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>当系统中可运行的进程数量大于处理器的个数时，我们要进行进程调度。</p>
<p>进程调度是指将合适的进程运行，并在一定时间内占用CPU。合理的调度程序，能够使系统资源发挥更大的作用，多进程才会有并发执行的效果。<strong>什么是合适的进程？一定的时间是多少时间？</strong>这些都是进程调度考虑的因素。</p>
<h4 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h4><p>多任务操作系统是能同时并发地交互执行多个进程的操作系统。如果是单处理器，不管进程有多少个，正在运行的数量最多只有1个。</p>
<p>多任务系统可以划分为两类：非抢占式多任务和抢占式多任务。</p>
<p>在非抢占式多任务模式下，进程一旦运行。占据CPU之后，其他进程一定得等该进程结束，<strong>主动让出CPU之后才能运行。</strong></p>
<p>抢占式多任务模式下，由调度程序来决定什么时候停止一个进程的运行，以便其他进程能够得到执行的机会。<strong>这个强制挂起的动作就叫做抢占。</strong>进程在被抢占之前能够运行在CPU的时间叫做进程的时间片，是<strong>预先设定好的</strong>。现代操作系统对程序运行都采用动态时间片计算的方式，并且引入了可配置的计算策略。</p>
<h4 id="Linux的进程调度"><a href="#Linux的进程调度" class="headerlink" title="Linux的进程调度"></a>Linux的进程调度</h4><p>linux系统在内核2.5之后引入了一个新的O(1)调度程序，并在此程序下优化，得到了一个新的调度器：<strong>完全公平调度器(CFS)</strong></p>
<p>接下来我们主要是在讲CFS算法。</p>
<h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><p>讲调度算法之前，我们先来了解调度器的策略。策略决定调度程序在何时让什么进程运行。针对不同的进程，其调度策略也不一样。</p>
<ul>
<li><p>I/O消耗型进程：此类进程在大部分时间用来提交I/O请求或者等待I/O请求。因此，这样的进程<strong>常常处于运行状态，但是运行的时间很短</strong>。因为它在等待更多的I/O请求时最后总是会阻塞。</p>
<p>针对此类进程的调度策略是增加进程调度频率，但是减少进程时间片时间。</p>
</li>
<li><p>CPU消耗型进程：此类进程把时间大多用在执行代码上。除非被强占，这样的进程一般都是一直在运行。<strong>所以从响应速度考虑，调度器不能让经常一直运行</strong>。</p>
<p>针对此类进程的调度策略是降低进程调度频率，但是增加进程时间片时间。</p>
</li>
<li><p>当然实际上有两者都具备的进程，这样的话调度策略似乎更难一点。调度策略通常要在两个矛盾的目标中寻找平衡：<strong>进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）。</strong> 因此调度程序通常采用一套很复杂的算法来实现调度策略。不过我们大概把握住这点，linux为了保证交互式应用和桌面系统的性能，对进程的响应做了优化，<strong>更倾向于优先调度I/O消耗型的进程。</strong></p>
</li>
</ul>
<p>下面再介绍一些专业词汇</p>
<ul>
<li><p>进程优先级：调度算法最基本的一类就是基于进程优先级来调度。通常做法（Linux未采用）优先级高的先执行，优先级低的后执行；优先级相同的轮询执行。</p>
<p>Linux采用两种方式来设置优先级</p>
<ul>
<li>第一种是nice值(-20~ +19)：默认值为0，<strong>nice值越大优先级越低</strong></li>
<li>第二种是实时优先级，其值是可配置的：默认情况下是[0-99]，<strong>数值越大优先级越高</strong>。</li>
</ul>
</li>
<li><p>时间片：时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。时间片需要提前设置。一般来说I/O消耗型希望时间片短，CPU消耗希望时间片长。</p>
</li>
</ul>
<h4 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h4><p>Linux调度器是通过模块的方式提供的，这样做为了是允许不同类型的进程可以有针对性的选择调度算法。</p>
<p><strong>进程可以分为普通进程和实时进程。普通进程使用的调度算法就是CFS；实时进程由于其需要实时响应，因此优先级高，之后在讨论。</strong></p>
<p>在Unix系统中用到的调度算法还是基于时间片和优先级的。但是这种算法有个本质的问题：<strong>分配绝对的时间片引发的固定的切换频率，给公平性造成了很大的变数。</strong>在这里CFS完全摒弃了时间片而是<strong>分配给进程一个处理器使用比重。</strong></p>
<p>CFS做法：<strong>允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程。CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是给一个绝对的时间片。</strong></p>
<p>其实这里还是用到了nice值，但是不是像之前的那样使用绝对的nice值，而是使用<strong>nice差值（进程A nice = 0， 进程B nice = 5 和 进程A nice = 15 进程B nice = 20</strong>二者的CPU时间分配是一样的。nice值对时间片的作用不再是算数加权，而是<strong>几何加权</strong>。</p>
<blockquote>
<p>总结下CFS调度算法特点：（相对的时间片概念）</p>
<ul>
<li>不是给一个绝对的时间片，而是给一个相对的nice值。</li>
<li>这个nice值是进程之间的nice差值，对时间片的作用是几何加权。</li>
</ul>
</blockquote>
<h4 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h4><p>调度器实体的数据结构是进程描述符 <code>task_struct</code>中的<code>struct sched_entity</code></p>
<p>完全公平调度（CFS）算法的实现可以分为四个组成部分</p>
<ul>
<li><p><strong>时间记账</strong>：所有调度器都必须对进程运行时间做记账，这个记账相当于时间片，当记账值为0，则可以被抢占。</p>
<ul>
<li>虚拟实时：<code>sched_entity</code>中的<code>vruntime</code>变量存放进程的虚拟运行时间，<strong>该运行时间的计算是经过了所有可运行进程数的标准化。</strong>该事件是以ns为单位的，与定时器节拍不再相关。CFS使用该变量来记录一个程序到底运行了多长时间以及它还能运行多久。</li>
<li><code>update_curr()</code>:该函数是由<strong>系统定时器周期性调用</strong>的，该函数计算了当前进程的执行时间，并将其放入<code>delta_exec</code>变量中。这样通过这两个变量，不过是进程处于那种状态，都能够准确测量出给定进程运行时间，而且可知道谁应是下一个运行的进程。</li>
</ul>
</li>
<li><p><strong>进程选择</strong>：CFS调度算法的核心：<strong>当CFS需要选择下一个运行进程时，它会挑一个具有最小<code>vruntime</code>的进程</strong>。那么如何选择这个进程呢？</p>
<p><strong>CFS使用红黑树来组织可运行进程队列，这样可以迅速找到最小<code>vruntime</code>的进程</strong>。</p>
<ul>
<li><p>挑选下一个任务： 运行红黑树中最左边叶子节点所代表的进程。 使用 <code>__pick_next_entity()</code></p>
</li>
<li><p>向树中加入进程：进程变为可运行状态时，加入红黑树。使用<code>__enqueue_entity()</code></p>
</li>
<li><p>从树中删除进程：进程变为阻塞或终止时，从红黑树删除。使用<code>__dequeue_entity()</code></p>
</li>
</ul>
<p>这些操作都要熟悉红黑树才能理解。</p>
</li>
<li><p>调度器入口： <code>schedule()</code>，该函数是找到可运行的最高优先级进程，然后调度它。</p>
</li>
<li><p>休眠和唤醒：进程处于休眠状态需要将其从可执行红黑树中移除，然后加入<strong>等待队列</strong>。然后调用<code>schedule()</code>选择和执行一个其他进程。唤醒操作语气相反。</p>
<p>等待队列是一个简单链表。休眠和唤醒操作记得要考虑<strong>竞争条件</strong>。</p>
</li>
</ul>
<h4 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h4><p>上下文切换就是从一个可执行进程切换到另一个可执行进程。由函数<code>context_switch()</code>执行。该函数完成了以下两项基本工作。</p>
<ul>
<li><p>调用声明在<code>&lt;asm/mmu_context.h&gt;</code>中的<code>switch_mm()</code>,该函数负责把<strong>虚拟内存</strong>从上一个进程映射切换到新进程中。</p>
</li>
<li><p>调用声明在<code>&lt;asm/system&gt;</code>中的<code>switch_to()</code>,该函数负责从上一个进程的<strong>处理器状态</strong>切换到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息，还有一些与体系结构相关的状态信息。</p>
</li>
</ul>
<p>内核必须知道在什么时候调用<code>schedule()</code>。内核提供了一个<code>need_resched</code>标志来表明是否需要重新执行一次调度。当某个进程应该被抢占时，一些函数会设置这个标志，然后内核检查该标志被设置，调用<code>schedule()</code>来切换到新的进程。</p>
<p>抢占：</p>
<ul>
<li><p><strong>用户抢占</strong>：这个可以理解为在用户空间中进程对CPU进行抢占。在内核即将返回用户空间时，<code>need_resched</code>标志被设置，这个时候会调用<code>schedule()</code>.（这个时候内核会选择一个其他更合适的进程投入运行）</p>
<p>简而言之：用户抢占发生在以下情况：</p>
<ul>
<li>从系统调用返回用户空间时</li>
<li>从中断处理程序返回用户空间时</li>
</ul>
</li>
<li><p><strong>内核抢占</strong>：指一个在内核态运行的进程，可能在执行内核函数期间被另一个进程取代。（这要求重新调度室安全的，即正在执行的进程代码<strong>是没有持有锁的</strong>。）</p>
<p>简而言之：内核抢占会发生在：</p>
<ul>
<li>中断处理程序正在执行，且返回用户空间之前</li>
<li>内核代码再一次具有抢占性的时候</li>
<li>如果内核中的进程显示调用<code>schedule()</code></li>
<li>如果内核中进程阻塞（也会调用<code>schedule()</code>）</li>
</ul>
</li>
</ul>
<h4 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h4><p>​    实时调度策略是针对实时进程的。<strong>实时进程因为优先级都较高，所以采用的是静态优先级。内核不为实时进程计算动态优先级。这样能保证给定优先级别的实时进程总能抢占优先级比它低的进程。</strong></p>
<p>​    如果是普通进程，其调度策略是<code>SCHED_NORMAL</code>,就是上面提到的那种。</p>
<p>采用的两种实时策略：</p>
<ul>
<li><code>SCHED_FIFO</code>:这个是简单的先入先出调度算法：<strong>它不使用时间片</strong>。处于可运行状态的<code>SCHED_FIFO</code>一定比<code>SCHED_NORMAL</code>更优先执行。<strong>由于不使用时间片，是非抢占的。只有优先级高的执行完，优先级低的才能执行。</strong></li>
<li><code>SCHED_RR</code>: 这个和上面那个大体相同，但是这个是有时间片的。时间片耗完就得重新调度。<strong>时间片只用来重新调度同一优先级的进程。</strong></li>
<li>两者优先级调度都采用的是高优先级先调度，同一优先级的轮流调度。</li>
</ul>
<h4 id="调度相关系统调用"><a href="#调度相关系统调用" class="headerlink" title="调度相关系统调用"></a>调度相关系统调用</h4><p>​    Linux提供一个系统调用族，用于管理与调度程序相关的参数。这些系统调用可以用来操作、处理进程优先级、调度策略及处理器绑定。这些都在下一章会讲。</p>
<p>​    不过这里有个<code>sched_yield()</code>系统调用，能够让该进程自动放弃CPU，放弃的进程加入过期队列中，这样该进程在一段时间内都不会再被执行了。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>​    进程调度程序是内核的重要组成部分。Linux新的CFS调度算法要掌握。</p>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程经常需要与其他进程通信。进程通信中一般伴有三个需要处理的问题：</p>
<ul>
<li>一个进程如何把信息传递给另一个</li>
<li>确保两个或多个进程在关键活动中不会交叉</li>
<li>进程执行的正常顺序</li>
</ul>
<p>这三个问题中的第二第三个问题对于线程也同样适用。第一个问题线程很简单，因为线程共享一个地址空间和拥有全局变量。但另外两个问题同样适用于线程。</p>
<p>本小节只注意第一个问题，至于二三个问题放在内核同步中去讲。</p>
<p>进程间的通信方式有以下几种</p>
<ul>
<li>匿名管道</li>
<li>命名管道</li>
<li>消息队列</li>
<li>信号量</li>
<li>信号</li>
<li>共享内存</li>
<li>套接字</li>
</ul>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道分为匿名管道和命名管道，二者的区别如下</p>
<ul>
<li>匿名管道只能在具有亲子关系的进程间进行通信</li>
<li>命名管道可以在无亲子关系的进程间进行通信</li>
</ul>
<p>这里来简单描述下匿名管道的步骤。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过pipe()函数来创建匿名管道</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">// fd参数返回两个文件描述符</span></span><br><span class="line"><span class="comment">// fd[0]指向管道的读端，fd[1]指向管道的写端</span></span><br><span class="line"><span class="comment">// fd[1]的输出是fd[0]的输入。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>父进程创建管道，得到<strong>两个⽂件描述符</strong>指向管道的两端</li>
<li>父进程fork出子进程，⼦进程也有<strong>两个⽂件描述符</strong>指向同⼀管道。</li>
<li><strong>父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。</strong></li>
</ul>
<p><strong>总结来说，管道是一种简单的进程通信方式。它是一种半双工的通信方式，数据只能单向流动</strong>。而且流动二字意味着管道其实是个字节流方法。</p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列，<strong>就是一个消息的链表，是一系列保存在内核中消息的列表</strong>。<strong>用户进程可以向消息队列添加消息，也可以向消息队列读取消息</strong>。</p>
<p>消息队列与管道通信相比，其优势是对<strong>每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息</strong>。</p>
<p>可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p>
<p>进程通过消息队列通信，主要是：</p>
<ul>
<li>创建或打开消息队列</li>
<li>添加消息</li>
<li>读取消息</li>
<li>控制消息队列</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>msgget</code></td>
<td>创建或打开消息队列</td>
</tr>
<tr>
<td><code>msgsnd</code></td>
<td>添加消息</td>
</tr>
<tr>
<td><code>msgrcv</code></td>
<td>读取消息</td>
</tr>
<tr>
<td><code>msgctl</code></td>
<td>控制消息队列</td>
</tr>
</tbody></table>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>信号其实是进程向内核发生一个系统调用，然后该系统调用再让内核去和另外一个进程进行通信。</p>
<p>信号是一个非常重要的处理异步事件的方法。一般来说信号是通过信号处理函数来实现的。信号处理函数在内核中注册，信号发送给内核之后，内核执行相对应的信号处理函数。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量的话放在内核同步中去讲。</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存允许两个或多个进程共享一个给定的存储区，<strong>这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取错做读出，从而实现了进程间的通信。</strong></p>
<p>采用共享内存进行通信的一个主要好处是<strong>效率高</strong>，因为进程可以直接读写内存，而不需要任何数据的拷贝，<strong>对于像管道和消息队里等通信方式，则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。</strong>因为管道这些都借助了内核，需要内核和用户态之间进行数据拷贝，这样一来就多了两次。</p>
<p>一般而言，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时在重新建立共享内存区域；而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件，因此，采用共享内存的通信方式效率非常高。</p>
<p>共享内存的两种实现方式：</p>
<ul>
<li>内存映射</li>
<li>共享内存机制</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>mmap</code></td>
<td>建立共享内存映射</td>
</tr>
<tr>
<td><code>munmap</code></td>
<td>解除共享内存映射</td>
</tr>
<tr>
<td><code>shmget</code></td>
<td>获取共享内存区域的ID</td>
</tr>
<tr>
<td><code>shmat</code></td>
<td>建立映射共享内存</td>
</tr>
<tr>
<td><code>shmdt</code></td>
<td>解除共享内存映射</td>
</tr>
</tbody></table>
<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p>套接字也是一种信号通信方式，这种方法一般用于不同主机之间的进程通信。因此套接字编程又称为网络编程，这个会在网络编程分类中详细的讲，这里便省略。</p>
<h3 id="内核同步介绍"><a href="#内核同步介绍" class="headerlink" title="内核同步介绍"></a>内核同步介绍</h3><p>总所周知，多个线程在访问和操作共享资源的时候，叫做并发访问。并发访问很有可能发生各个线程之间相互覆盖共享数据的状态，这样导致被访问数据不一致的状态。要想防止并发访问带来的问题，我们要学会同步。这一章我们来介绍内核同步。</p>
<h4 id="单处理器并发"><a href="#单处理器并发" class="headerlink" title="单处理器并发"></a>单处理器并发</h4><p>​    在只有单处理器的时候，<strong>只有在中断发生的时候，或者在内核明确请求重新调度、执行另一个任务的时候，数据才可能并发访问</strong>，这样一来其实防止并发非常简单。只需要注意重新调度和中断即可。</p>
<p>​    这种并发称之为<strong>伪并发执行</strong>。以下是一些单CPU下的伪并发</p>
<ul>
<li><p>中断：中断能够随时打断当前的代码。</p>
</li>
<li><p>软中断和tasklet：内核能在任何时候唤醒或调度软中断和tasklet</p>
</li>
<li><p>内核抢占：内核具有抢占性</p>
</li>
<li><p>睡眠及用户空间的同步：进程睡眠之后的重新调度。</p>
<p>上面这四种如果在多处理器上的话可能还是真正的并发。</p>
</li>
<li><p>堆成多处理：多处理器下同时访问相同一段代码。</p>
</li>
</ul>
<h4 id="临界区和竞争条件"><a href="#临界区和竞争条件" class="headerlink" title="临界区和竞争条件"></a>临界区和竞争条件</h4><ul>
<li>临界区：访问和操作共享数据的代码段</li>
<li>竞争条件：<strong>多个执行线程（进程/线程/中断处理程序）并发（并行）访问共享资源</strong>，因为执行顺序不一样造成结果不一样的情况，称为竞争条件</li>
<li>同步：避免并发和防止竞争条件称为同步。</li>
</ul>
<h4 id="原子性的理解"><a href="#原子性的理解" class="headerlink" title="原子性的理解"></a>原子性的理解</h4><p>原子变量：在硬件方面是使用<strong>锁总线</strong>的方式（最新的可能会有变化）来实现指令连续执行而不被打断。</p>
<p><strong>锁总线的效果非常低效，现在是通过阻塞其它CPU核对相关内存的缓存块访问来实现原子操作。</strong></p>
<p>这里可以看<a href="https://zhuanlan.zhihu.com/p/33445834%E8%BF%99%E4%B8%AA%E5%9B%9E%E7%AD%94%E3%80%82">https://zhuanlan.zhihu.com/p/33445834这个回答。</a></p>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>​    为了让临界区不被多线程并发访问，内核实现了锁的机制。这种机制确保A线程标记访问临界区时，其它线程禁止访问该临界区。加锁能够实现以串行方式对资源进行访问，不过这样同时会降低系统的性能。</p>
<p>​    锁有各种各样的实现形式，锁的各种机制的区别主要在于：当锁已经被其他线程持有，因而不可用时的表现：</p>
<ul>
<li>一些锁被争用时会简单的<strong>执行忙等待</strong>（自旋锁）</li>
<li>一些锁被争用时会使<strong>当前任务睡眠</strong>知道锁可用为止（信号量）</li>
</ul>
<p>加锁这个问题要在设计代码的时候就要考虑。这个问题特别难。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁就是<strong>一个或多个线程和一个或多个资源，每个线程都在等待一个资源，但是所有资源都被占用了。这样导致所有线程都在相互等待，而且不会释放已经占有的资源。</strong></p>
<p>最简单的死锁：自死锁（递归调用非递归锁）</p>
<p>如何避免死锁：</p>
<ul>
<li>按顺序加锁</li>
<li>防止发生饥饿，即最好不要出现线程一直等待的现象。</li>
<li>不要重复请求同一个锁</li>
<li>设计方案尽可能简单。</li>
</ul>
<h4 id="争用和扩展性"><a href="#争用和扩展性" class="headerlink" title="争用和扩展性"></a>争用和扩展性</h4><p>​    争用是指当锁正在被占用时，有其他线程试图获得该锁。如果有多个线程都在试图获得这个锁，那就说明该锁正在被高度争用。这样的话会极大的降低系统的性能。</p>
<p>​    当锁的争用问题变得严重的时候，设计就向更加惊喜的加锁方向进化。加锁从全局锁精化到了每个处理器都有自己的锁，这样的话扩展性大大的增强了。</p>
<p>​    扩展性是指系统在扩展的时候能够使性能尽可能的高。内核加锁的粒度很细，这样的话扩展性也会更好。CFS调度器也进一步提升了锁的可扩展性。</p>
<h3 id="内核同步方法"><a href="#内核同步方法" class="headerlink" title="内核同步方法"></a>内核同步方法</h3><p>​    上一章讨论了竞争条件的产生以及如何去解决。这一章我们来介绍Linux内核提供的同步方法。</p>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>​    原子操作是其他同步操作的基石。原子操作保证指令在执行过程中不被打断。</p>
<p>​    原子操作的本来意思是指在一个时钟周期内完成的操作，这样就不可能被打断。</p>
<ul>
<li>实现原子操作原理：（使用<strong>Volatile</strong>关键字）<ul>
<li>最早是通过汇编指令LOCK，CPU锁总线，直到该指令完成之后在释放总线。</li>
<li>上一种效率很低，现在的话是<strong>LOCK只会阻塞其他cpu核对相关内存的缓存块的访问。</strong></li>
</ul>
</li>
</ul>
<p>（这里 Volatile 的作用是确保指令不会优化写入寄存器中，这样就防止了指令重排）</p>
<ul>
<li><p>原子操作对象</p>
<ul>
<li><p>原子整数操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 32 bits</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> counter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 64 bits</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic64_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> counter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>原子位操作：没有对象，只有一些接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span>* addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span>* addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span>* addr)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>为什么要有原子位操作？</p>
<p>因为对位进行操作不是原子的，而是有两个步骤</p>
<ul>
<li>先对某位置位，然后清0。（置位操作和清除操作顺序可能不一样）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>​    自旋锁是Linux中最常见的锁。</p>
<p>​    自旋锁只能被一个可执行线程持有。<strong>如果一个执行线程试图获得已经持有的自旋锁，那么该线程会一直进行忙循环——旋转——等待锁重新可用。</strong>这也是自旋锁的最大特点。</p>
<ul>
<li><p>自旋锁的特点：</p>
<ul>
<li>自旋锁只适用于短时间内的轻量级加锁（因为一旦自旋，处理器会一直循环等待）</li>
<li><strong>自旋锁是不可递归的！重复加同一个锁也会自旋！</strong></li>
<li>自旋锁可以在中断处理程序中。但是<strong>在中断处理程序中使用自旋锁一定要禁止本地中断（同一CPU上的中断）</strong></li>
</ul>
</li>
<li><p>自旋锁操作：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">spin_lock()</td>
<td align="center">获取指定的锁</td>
</tr>
<tr>
<td align="center">spin_lock_irq()</td>
<td align="center"><strong>禁止本地中断</strong>并获取指定的锁</td>
</tr>
<tr>
<td align="center">spin_lock_irqsave()</td>
<td align="center">保存本地中断的状态，然后<strong>禁止本地中断</strong>并获取指定的锁</td>
</tr>
<tr>
<td align="center">spin_unlock()</td>
<td align="center">释放指定的锁</td>
</tr>
<tr>
<td align="center">spin_unlock_irq()</td>
<td align="center">释放指定的锁并<strong>激活本地中断</strong></td>
</tr>
<tr>
<td align="center">spin_unlock_irqrestore()</td>
<td align="center">释放指定的锁并让本地中断恢复到之前的状态</td>
</tr>
<tr>
<td align="center">spin_lock_init()</td>
<td align="center">动态初始化指定的锁</td>
</tr>
<tr>
<td align="center">spin_trylock()</td>
<td align="center">试图获取指定的锁，如果未获取，返回非0</td>
</tr>
<tr>
<td align="center">spin_is_locked()</td>
<td align="center">如果指定的锁正在被获取，返回非0</td>
</tr>
</tbody></table>
</li>
<li><p>自旋锁和下半部</p>
<p>由于三者的抢占关系： 中断处理程序 &gt; 下半部 &gt; 进程上下文。</p>
<p>如果在进程上下文和下半部中共享数据，要<strong>禁止下半部</strong>，如果中断处理程序和下半部共享数据，要禁止中断。这些都要得到锁的保护。</p>
</li>
</ul>
<ul>
<li>读-写自旋锁</li>
</ul>
<p>​    Linux内核专门提供了读-写锁。不过在使用中如果对于读写分不太清还是用普通的自旋锁。</p>
<p>​    在读写锁中，当读锁被持有时，写操作只能自旋等待，而读操作可以继续占用锁，这样的话会让写操作无限延迟。</p>
<p>​    自旋锁提供的是一种快速简单的锁实现方法。<strong>适用于加锁时间不长并且代码不会睡眠（如中断处理程序），利用自旋锁是最佳选择。</strong>如果加锁时间长或者代码持有锁时可能会睡眠，那么用信号量。</p>
<h4 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h4><p>​    Linux中的信号量是一个睡眠锁。<strong>当一个任务试图获得一个已经被占用的信号量时，信号量会将其推进一个等待队列，然后让其睡眠，这样处理器会重获自由，去处理其他代码。</strong></p>
<ul>
<li><p>与自旋锁的对比</p>
<ul>
<li>更好的利用了CPU利用率</li>
<li><strong>开销比自旋锁大。</strong></li>
<li>不能既占用信号量又占用自旋锁。</li>
<li><strong>信号量可以同时允许任意数量的锁持有者</strong>，而自旋锁只能有一个。</li>
</ul>
</li>
<li><p>计数信号量</p>
<p>信号量可以同时允许任意数量的锁持有者这个特性是通过引用计数count来实现的。count是该信号量的使用数量。</p>
</li>
<li><p>二值信号量</p>
<p>该类信号量的count只有0和1，这个和mutex有点像。</p>
</li>
</ul>
<h4 id="互斥体Mutex"><a href="#互斥体Mutex" class="headerlink" title="互斥体Mutex"></a>互斥体Mutex</h4><p>​    <strong>Mutex是一个相对于信号量更为轻便的睡眠锁</strong>，这是个简化版信号量，<strong>没有引用计数。</strong></p>
<p>​    Mutex不仅仅只是没有引用计数，而且还使用了<code>futex</code>机制。(futex不只在mutex中实现了，基本上linux上所有的线程同步都能够使用这个)</p>
<ul>
<li><p><code>futex</code>机制</p>
<p><code>Futex</code>是一种用户态和内核态混合的同步机制。</p>
<p>首先，同步的进程间通过<code>mmap</code>共享一段内存，**<code>futex</code>变量就位于这段共享的内存中且操作是原子<strong>的，当</strong>进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的futex变量，如果没有竞争发生，则只修改<code>futex</code>,而不用再执行系统调用了。当通过访问<code>futex</code>变量告诉进程有竞争发生，则还是得执行系统调用去完成相应的处理(wait 或者 wake up)。**</p>
<p>简单的说，<code>futex</code>就是通过在<strong>用户态的检查，如果了解到没有竞争就不用陷入内核了</strong>，大大提高了low-contention时候的效率。</p>
</li>
<li><p>Mutex操作</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mutex_lock(struct mutex *)</td>
<td align="center">为指定的mutex上锁，如果锁不可用时则睡眠</td>
</tr>
<tr>
<td align="center">mutex_unlock(struct mutex *)</td>
<td align="center">为指定的mutex解锁</td>
</tr>
<tr>
<td align="center">mutex_trylock(struct mutex *)</td>
<td align="center">试图获取指定的mutex，成功返回1；如果锁被获取，返回0</td>
</tr>
<tr>
<td align="center">mutex_is_locked(struct mutex *)</td>
<td align="center">如果锁已被争用，则返回1，否则返回0</td>
</tr>
</tbody></table>
</li>
<li><p>Mutex使用特点</p>
<ul>
<li> 任何时刻最多只能有一个任务持有mutex。</li>
<li> <strong>当持有一个mutex时，进程不可以退出</strong>。</li>
<li> mutex不能在中断和下半部使用，即使使用mutex_trylock()也不行。</li>
<li> <strong>一般来说在同一进程上下文中加锁解锁。</strong></li>
</ul>
</li>
</ul>
<p><strong>对于互斥体和信号量，优先使用信号量</strong></p>
<h4 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h4><p>​    通常简称seq锁。用于<strong>读写共享数据</strong>。这种锁的实现是依靠一个序列计数器。如果有疑义的数据被写入时，会得到一个锁，并且序列值会增加。当序列值为偶数，那代表加的锁都是读操作。如果是奇数，那么有写操作，优先执行写操作。</p>
<p>该锁适用于</p>
<ul>
<li>数据读操作很多</li>
<li>数据写操作很少</li>
<li>写操作虽然很少但是优先读操作</li>
<li>数据很简单</li>
</ul>
<p>使用这种锁的情况下有jiffies,该变量存储了Linux机器启动到当前时间。</p>
<h4 id="禁止抢占"><a href="#禁止抢占" class="headerlink" title="禁止抢占"></a>禁止抢占</h4><p>​    内核是有抢占性的，内核中的进程在任何时候都可能停下来运行另外一个进程。这意味着一个任务和被强占的任务可能在同一临界区内运行。为了避免这种情况下，<strong>内核抢占代码使用自旋锁为非抢占区域，即禁止抢占</strong>。</p>
<h4 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h4><p>​    barrier，保证了顺序性。因为编译器和处理器为了提高效率，可能对读和写重新排序，有些机器指令能够确保顺序要求（volatile），同时也可以指示编译器不要对指定点周围的指令序列进行重新排列。这些确保顺序的指令称作屏障。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程管理</tag>
        <tag>进程通信</tag>
        <tag>线程</tag>
        <tag>进程调度</tag>
        <tag>内核同步</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis对象</title>
    <url>/posts/404ab54a/</url>
    <content><![CDATA[<blockquote>
<p>上篇文章介绍了Redis的所有底层数据结构，但是Redis并没有直接使用这些底层数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，每种对象至少用到了一个底层数据结构，本章我们就来了解Redis的对象。</p>
</blockquote>
<span id="more"></span>



<h3 id="对象简介"><a href="#对象简介" class="headerlink" title="对象简介"></a>对象简介</h3><p>Redis对象系统包含 <strong>字符串对象， 列表对象， 哈希对象， 集合对象和有序集合对象</strong>这五种类型的对象。</p>
<p>使用对象的好处：</p>
<ul>
<li>Redis在执行命令之前，可以通过对象的类型来直接判断执行命令的合法性。</li>
<li>针对不同的使用场景，可以为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</li>
<li>Redis对象实现基于<strong>引用计数技术的内存回收机制</strong>。通过该机制可以实现对象共享机制。</li>
<li>Redis的对象带有<strong>访问时间记录信息</strong>，该信息可以用于计算数据库键的空转时长，在服务器启用了<code>maxmemory</code>功能情况下，空转时长较大的键会优先被服务器删除。</li>
</ul>
<h3 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h3><p>​    Redis通过对象来表示数据库中的键和值，因此每当我们创建一个键值对时，至少创建两个对象，一个是键对象，一个是值对象。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> example</span><br><span class="line">redis &gt; <span class="built_in">set</span> msg <span class="string">&quot;hello world&quot;</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">--&gt; key : msg （字符串对象)</span><br><span class="line">--&gt; value: <span class="string">&quot;hello wordl&quot;</span> (字符串对象)</span><br></pre></td></tr></table></figure>

<p>Redis中的每个对象都有一个<code>redisObject</code>结构表示，该结构中和保存数据有关的三个属性分别是type属性，encoding属性和ptr属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">	<span class="comment">// type</span></span><br><span class="line">    <span class="keyword">unsigned</span> type : <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// encode</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding : <span class="number">4</span>; </span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>类型：type类型常量有五种，type为其中一种。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">REDIS_STRING | <span class="type">REDIS_LIST</span> | <span class="type">REDIS_HASH</span> | <span class="type">REEDIS_SET</span> | <span class="type">REDIS_ZSET</span></span><br><span class="line">字符串对象		列表对象		哈希对象	 集合对象		有序集合对象</span><br></pre></td></tr></table></figure>

<p>因此当我们称呼一个<strong>数据库键为“字符串”键</strong>时，我们指的是“<strong>这个数据库键所对应的值为字符串对象</strong>”</p>
</li>
<li><p>编码和底层实现</p>
<p><strong>对象的ptr指针指向对象的底层数据结构，这些数据结构由对象的encoding属性决定。encoding属性记录了对象使用的编码</strong>。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">编码常量				<span class="string">|			编码所对应的底层数据结构</span></span><br><span class="line">REDIS_ENCODING_INT				long类型的整数</span><br><span class="line">REDIS_ENCODING_EMBSTR			embstr编码的的简单动态字符串</span><br><span class="line">REDIS_ENCODING_RAW				简单动态字符串（sds）</span><br><span class="line">REDIS_ENCODING_HT				字典</span><br><span class="line">REDIS_ENCODING_LIKNEDLIST		双端链表</span><br><span class="line">REDIS_ENCODING_ZIPLIST			压缩列表</span><br><span class="line">REDIS_ENCODING_INTSET			整数集合</span><br><span class="line">REDIS_ENCODING_SKIPLIST			跳跃表和字典</span><br></pre></td></tr></table></figure>

<p>每种类型的对象都至少使用了两种不同的编码作为其底层数据结构。即 类型， 编码， 和对象三者有着不同的对应关系</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">类型					|  				编码					|			对象</span><br><span class="line"></span><br><span class="line">REDIS<span class="emphasis">_STRING			REDIS_ENCODING_INT						使用整数值实现的字符串对象</span></span><br><span class="line"><span class="emphasis">REDIS_STRING			REDIS_ENCODING_EMBSTR					使用embstr编码的SDS实现的字符串对象</span></span><br><span class="line"><span class="emphasis">REDIS_STRING			REDIS_ENCODING_RAW						使用SDS实现的字符串对象</span></span><br><span class="line"><span class="emphasis">	</span></span><br><span class="line"><span class="emphasis">REDIS_LIST				REDIS_ENCODING_ZIPLIST					使用压缩列表实现的列表对象</span></span><br><span class="line"><span class="emphasis">REDIS_LIST				REDIS_ENCODING_</span>LIKNEDLIST				使用双端链表实现的列表对象</span><br><span class="line"></span><br><span class="line">REDIS<span class="emphasis">_HASH				REDIS_ENCODING_ZIPLIST					使用压缩列表实现的哈希对象</span></span><br><span class="line"><span class="emphasis">REDIS_HASH				REDIS_ENCODING_</span>HT						使用字典实现的哈希列表</span><br><span class="line"></span><br><span class="line">REEDIS<span class="emphasis">_SET				REDIS_ENCODING_INTSET					使用整数集合实现的集合对象</span></span><br><span class="line"><span class="emphasis">REEDIS_SET				REDIS_ENCODING_</span>HT						使用字典实现的集合对象</span><br><span class="line"></span><br><span class="line">REDIS<span class="emphasis">_ZSET				REDIS_ENCODING_ZIPLIST					使用压缩列表实现的有序集合列表</span></span><br><span class="line"><span class="emphasis">REDIS_ZSET				REDIS_ENCODING_</span>SKIPLIST					使用跳跃表和字典实现的有序集合对象</span><br></pre></td></tr></table></figure>

<p>通过encoding来设定对象所使用的的编码，而不是为特定类型的对象关联一种固定的编码，极大提升了Redis的灵活性和效率，因为Redis可以根据不同的场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。（数据少用一个编码，数据多转换编码）</p>
</li>
</ul>
<p><em>这里介绍下embstr，这个编码方式是专门用于保存的是一个字符串值，并且这个字符串值的长度小于等于39字节。即专门用于保存短字符串的优化编码模式</em></p>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象可以是 <code>int, raw , embstr</code>。 </p>
<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象将整数型保存在ptr中（将void* 设置为long），并将字符串对象的编码设置为int。</p>
<p>至于raw和embstr的选取。embstr我们都知道是一种专门用于保存短字符串的优化编码。</p>
<p>优化原因：</p>
<ul>
<li><p>raw编码会调用两次内存分配函数来分别创建<code>redisObject</code>结构和<code>sdshdr</code>结构，而在embstr只会调用一次内存分配函数，连续空间包括<code>redisObject</code>结构和<code>sdshdr</code>结构。</p>
</li>
<li><p>同样的，释放embstr编码字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次。</p>
</li>
<li><p>因为embstr编码的字符串对象的所有数据都保存在一块连续内存中，<strong>使用缓存会更高效</strong></p>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">		字符串对象保存各类型值得编码方式</span><br><span class="line">	值									|				编码</span><br><span class="line">可以用<span class="keyword">long</span>类型保存的整数							<span class="keyword">int</span></span><br><span class="line">可以用<span class="keyword">long</span> <span class="keyword">double</span>类型保存的浮点数					embstr或者raw</span><br><span class="line">字符串值，或者长度太大的<span class="keyword">long</span>， <span class="keyword">long</span> <span class="keyword">double</span> 		   embstr或者raw</span><br></pre></td></tr></table></figure>

<p>编码的转换：</p>
<p>​    字符串在条件满足的时候，会对编码进行转换。这个很好的理解，但是注意一点： </p>
<p>由于Redis没有为embstr编码的字符串对象编写任何相应的修改程序，所以<strong>embstr编码字符串时只读</strong>的。要想<strong>修改embstr，那么它会先变成Raw编码的字符串对象</strong></p>
<ul>
<li><p>字符串命令的实现</p>
<p>字符串键的值为字符串对象，所以用于字符串键的所有命令都是针对字符串对象来构建的。</p>
<p>字符串命令有： </p>
<ul>
<li><p>SET</p>
</li>
<li><p>GET</p>
</li>
<li><p>APPEND</p>
</li>
<li><p>INCRBYFLOAT</p>
</li>
<li><p>INCRBY</p>
</li>
<li><p>DECRBY</p>
</li>
<li><p>STRLEN</p>
</li>
<li><p>SETRANGE</p>
</li>
<li><p>GETRANGE.</p>
</li>
</ul>
</li>
</ul>
<p>这些命令具体意思和用法都可以参见原书P68页（实在太多了）</p>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码可以是<code>ziplist</code> 或者<code>linkedlist</code>。</p>
<p>用<code>ziplist</code>编码底层数据结构为压缩列表，每个压缩列表节点保存了一个列表元素。</p>
<p>用<code>linkedlist</code>编码的列表对象使用双端链表作为底层实现，<strong>每个双端链表节点保存着一个字符串对象，每个字符串对象里面保存了一个列表元素</strong>。（二者需要区分）</p>
<p>​    <strong>另外，需要注意的是：字符串对象是Redis中五种类型对象中唯一一个能被其他四个对象嵌套的对象。</strong></p>
<ul>
<li><p>编码转换：</p>
<p>当列表对象可以同时满足以下两个条件时，列表对象用<code>ziplist</code>编码。</p>
<ul>
<li>列表对象保存的所有字符串元素长度都小于64字节</li>
<li>列表对象保存的元素数量小于512个</li>
</ul>
<p>如果不满足，那么就会使用<code>linkedlist</code>编码（全部元素都使用）</p>
<p>（注：以上两个条件的上限值是可以修改的，具体请看配置文件说明）</p>
</li>
<li><p>列表命令的实现</p>
<p>因为列表键的值为列表对象，所以用于列表键的所有命令都是针对列表对象构建的。</p>
<p>以下为部分列表建命令</p>
<ul>
<li>LPUSH</li>
<li>RPUSH</li>
<li>LPOP</li>
<li>RPOP</li>
<li>LINDEX</li>
<li>LLEN</li>
<li>LINSERT</li>
<li>LREM</li>
<li>LTRIM</li>
<li>LSET</li>
</ul>
<p>具体的实现方法以后补充</p>
</li>
</ul>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>​    哈希对象的编码可以是<code>ziplist</code>或者 <code>hashtable</code></p>
<p>​    <code>ziplist</code>编码的哈希对象使用<strong>压缩列表</strong>作为底层实现，当有新键值对要加入哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。</p>
<p>​    因此，哈希表在压缩列表中<strong>存储键和值总是挨着的</strong>，并且先添加的键值对离表头更近。</p>
<p>​    <code>hashtable</code>编码的哈希对象使用<strong>字典</strong>作为底层实现，哈希对象的每个键值对都使用一个字典键值对来保存：</p>
<p>字典中的键和值都是字符串对象，对象分别保存了键值对的键和值。</p>
<ul>
<li><p>编码转换</p>
<p>当哈希对象可以同时满足以下两个条件时，哈希对象用<code>ziplist</code>编码。</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节</li>
<li>哈希对象保存的键值对数量小于512个</li>
</ul>
</li>
</ul>
<p>如果不满足，那么就会使用<code>hashtable</code>编码（全部元素）</p>
<p>（注：以上两个条件的上限值是可以修改的，具体请看配置文件说明）</p>
<ul>
<li><p>哈希命令的实现</p>
<p>因为哈希建的值为哈希对象，所以用于哈西家你的所有命令都是针对哈希对象和来构建的</p>
<p>哈希命令：</p>
<ul>
<li>HSET</li>
<li>HGET</li>
<li>HEXISTS</li>
<li>HDEL</li>
<li>HLEN</li>
<li>HGETALL</li>
</ul>
</li>
</ul>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>​    集合对象的编码可以使<code>intset</code> 或者<code>hashtable</code></p>
<p><code>intset</code>编码的集合对象使用<strong>整数集合</strong>作为底层实现，集合对象的所有元素都保存在整数集合里面。</p>
<p><code>hashtable</code>编码的集合对象使用<strong>字典</strong>作为底层实现，字典的每个键都是一个字符串，每个字符串包含了一个集合元素，而字典的值全部设置为NULL。</p>
<ul>
<li><p>编码转换</p>
<p>当列表对象可以同时满足以下两个条件时，列表对象用<code>intset</code>编码。</p>
<ul>
<li>集合对象保存的所有元素都是整数值</li>
<li>结合对象保存的元素数量小于512个</li>
</ul>
<p>如果不满足，那么就会使用<code>hashtable</code>编码（全部元素都使用）</p>
<p>（注：以上第二个条件的上限值是可以修改的，具体请看配置文件说明）</p>
</li>
<li><p>集合命令的实现</p>
<p>因为集合键的值为集合对象，所有用于集合间的所有命令都是针对集合对象构建的。</p>
<p>集合命令的实现方法</p>
<ul>
<li>SADD</li>
<li>SCARD</li>
<li>SISMEMBER</li>
<li>SMEMBERS</li>
<li>SRANDMEMBER</li>
<li>SPOP</li>
<li>SREM</li>
</ul>
</li>
</ul>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>​    有序集合的编码可以是<code>ziplist</code>或者<code>skiplist</code></p>
<p>​    <code>ziplist</code>编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值。</p>
<p>​    压缩列表的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的位置，而分值较大的元素则被放置在靠近表尾的位置。</p>
<p>​    <code>skiplist</code>编码的有序集合对象使用<code>zset</code>结构作为底层实现，一个<code>zset</code>结构同时包含<strong>一个字典和一个跳跃表</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    <span class="comment">// 跳跃表部分</span></span><br><span class="line">    <span class="comment">// zsl跳跃表按分值从小到大保存了所以集合元素，每个跳跃表节点都保存了一个集合元素：</span></span><br><span class="line">    <span class="comment">// 跳跃表节点的object属性保存了元素成员，score属性保存了元素的分值。</span></span><br><span class="line">    zskiplist* zsl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字典部分</span></span><br><span class="line">    <span class="comment">// dict字典为有序集合创建了一个从成员到分值的映射，每个键值对都保存着集合元素，这保证O（1）复杂度找到</span></span><br><span class="line">    <span class="comment">// 给定成员的分值</span></span><br><span class="line">    dict* dict;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><code>zset</code>结构同时使用跳跃表和字典来保存有序集合</strong>，这两种数据结构都会通过指针来共享相同的成员和分值，所以同时使用<strong>两个结构保存集合元素不会产生任何重复成员或分值，也不会因此浪费额外内存</strong>。</p>
<p>为何要同时使用两种结构？ 是为了我们将两种优点集齐。字典能够O(1)复杂度查找成员分值，而字典是无序的，<code>skiplist</code>能够实现有序集合。</p>
<ul>
<li><p>编码转换</p>
<p>当有序集合对象可以同时满足以下两个条件时，列表对象用<code>ziplist</code>编码。</p>
<ul>
<li>有序集合对象保存的所有元素长度都小于64字节</li>
<li>有序集合保存的元素数量小于128个</li>
</ul>
<p>如果不满足，那么就会使用<code>skiplist</code>编码（全部元素都使用）</p>
<p>（注：以上两个条件的上限值是可以修改的，具体请看配置文件说明）</p>
</li>
</ul>
<ul>
<li><p>有序集合命令的实现</p>
<p>因为有序集合键的值为有序集合对象，所有用于有序集合键的所有命令都是针对有序集合对象来构建。</p>
<p>有序集合命令：</p>
<ul>
<li>ZADD</li>
<li>ZCARD</li>
<li>ZCOUNT</li>
<li>ZRANGE</li>
<li>ZREVRANGE</li>
<li>ZRANK</li>
<li>ZREVRANK</li>
<li>ZREM</li>
<li>ZSCORE</li>
</ul>
</li>
</ul>
<h3 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h3><p>Redis用于操作间的命令基本上可以分为两种类型。</p>
<p>其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令。</p>
<p>另一种命令只能对特定类型的键执行。就相当于前面的一些命令。</p>
<ul>
<li><p>类型检查的实现</p>
<p>类型特定命令所进行的类型检查是通过<code>redisObject</code>结构的<code>type</code>属性来实现的：</p>
<ul>
<li>执行命令前，服务器检查输入数据库键的值对象是否为执行命令所需的类型，是的话，服务器执行指定命令</li>
<li>否则，拒绝执行命令，并向客户端返回一个类型错误。</li>
</ul>
</li>
<li><p>多态命令的实现</p>
<p>多态命令分为两种，一种是DEL这种，基于类型多态——一个命令可以同时用于处理多种不同类型的<strong>键</strong>。而LLEN这种是基于编码的多态——一个命令可以同时用于处理多种不同的<strong>编码</strong>。</p>
</li>
</ul>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>​    C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个<strong>引用计数</strong>（这里的引用计数就是shared_ptr 所实现的技术),这里就不赘述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>除了实现引用计数内存回收机制之外，引用计数属性还能带来对象共享作用。</p>
<p>在Redis中，让多个键共享同一个值对象需要执行一下两个步骤：</p>
<ul>
<li><strong>将数据库键的值指针指向一个现有的值对象</strong></li>
<li><strong>将被共享的值对象引用计数增一</strong></li>
</ul>
<p>共享对象机制对于节约内存非常有用，数据库中保存的相同值对象越多，对象共享机制就能节约越多的内存。</p>
<p>但是，Redis只能共享<strong>整数值对象</strong>，字符串的对象不共享。因为验证共享对象和目标对象是否相同是需要复杂度的，在整数值对象中复杂度是O(1), 在字符串对象就是O(N),因此为了CPU的考虑，所有只对整数值的字符串对象进行共享。</p>
<h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru : <span class="number">22</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空转时长是通过将<strong>当前时间减去键的值对象的LRU时间计算得出的</strong>。</p>
<h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul>
<li>Redis数据库每个键值对的键和值都是一个对象</li>
<li>Redis共有字符串，列表，哈希，集合，有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型</li>
<li>Redis的对象系统带有引用计数实现内存回收机制，当一个对象不在被使用时，该对象所占用的内存就会被自动释放。</li>
<li>Redis会共享值为0-9999的字符串对象</li>
<li>对象会记录自己最后一次被访问的时间，这个时间可以用于计算对象的空转时间。</li>
</ul>
<p>这些也是Redis为何不直接用底层结构而是用一层对象进行包装的原因——能够在各个方面更好的管理数据。这些方面有</p>
<ul>
<li>命令判定</li>
<li>内存回收</li>
<li>引用计数</li>
<li>时间记录</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《Redis设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>计网层次模型</title>
    <url>/posts/7e9a112b/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章简要介绍了一下计算机网络的分层模型以及两个分层之间的</p>
</blockquote>
<h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>计算机网络的体系结构是通过分层来展示的，目前来说一般有两种分层模型</p>
<ul>
<li>OSI七层模型</li>
<li>TCP/IP四层模型</li>
</ul>
<img src="/posts/7e9a112b/%E5%B1%82%E6%AC%A1%E5%8D%8F%E8%AE%AE.png" class title="层次模型">



<h4 id="OSI层次"><a href="#OSI层次" class="headerlink" title="OSI层次"></a>OSI层次</h4><p>① 应用层</p>
<p>应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用。该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。在应用层交互的数据单元我们称之为<strong>报文</strong>。</p>
<p>② 表示层</p>
<p>表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。<strong>该层提供的服务主要包括数据压缩，数据加密以及数据描述。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异</strong>。</p>
<p>③ 会话层</p>
<p><strong>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法</strong>。</p>
<p>④ 传输层</p>
<p>传输层的主要任务是为<strong>两台主机进程之间的通信提供服务。应用程序利用该服务传送应用层报文。</strong>该服务并不针对某一特定的应用，多种应用可以使用同一个传输层服务。由于一台主机可同时运行多个线程，因此传输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面传输层的服务，分用和复用相反，是传输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p>⑤ 网络层</p>
<p>两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。<strong>网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送</strong>。在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。</p>
<p>⑥ 数据链路层</p>
<p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。</p>
<p>⑦ 物理层</p>
<p>作为 OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。</p>
<h4 id="TCP-IP层次"><a href="#TCP-IP层次" class="headerlink" title="TCP/IP层次"></a>TCP/IP层次</h4><p>① 应用层</p>
<p>TCP/IP 模型将 <strong>OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现</strong>，通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP 等。</p>
<p>② 传输层</p>
<p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。<strong>传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）</strong>。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p>
<p>③ 网际互联层</p>
<p>网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。<strong>除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP</strong>）。（ICMP用在ping上，IGMP用在多播广播上）</p>
<p>④ 网络接入层</p>
<p>网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p>
<p>一般来说，作为一个编写代码的普通程序员，最低层次了解到网络层就可以了，本文的重点是在传输层。</p>
<h4 id="二者异同"><a href="#二者异同" class="headerlink" title="二者异同"></a>二者异同</h4><ul>
<li>相同点：<ul>
<li>都是分层模型</li>
<li>都能提供无连接和有链接两种通信服务机制</li>
</ul>
</li>
<li>不同点：<ul>
<li>前者是七层模型，后者是五层模型</li>
<li>OSI先有模型后有规范，TCP是先有的协议族，在有的模型。</li>
<li>前者看起来虽好，但是难以实现，后者实现起来比较方便。</li>
</ul>
</li>
</ul>
<h4 id="为什么表示层和传输层在TCP被去掉了"><a href="#为什么表示层和传输层在TCP被去掉了" class="headerlink" title="为什么表示层和传输层在TCP被去掉了"></a>为什么表示层和传输层在TCP被去掉了</h4><ul>
<li>TCP是基于协议的，表示层的功能是对数据进行压缩处理，会话层是维持会话建立，这些都太抽象了，不好封装成协议</li>
<li>其实表示层和会话层的功能都是在应用程序里面的，应用程序之中几乎无法实现代码抽象，因此不容易被分层。</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><p><a href="https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/">https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/</a></p>
</li>
<li><p>《TCP/IP详解》 卷一</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>层次模型</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程基础</title>
    <url>/posts/adcb768c/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍一些网络编程的基础知识，如socket介绍，一个完整的ECHO服务器该如何写？至于之后的项目提升，会在之后的文档中再做总结。</p>
</blockquote>
<span id="more"></span>



<h3 id="Socket地址API"><a href="#Socket地址API" class="headerlink" title="Socket地址API"></a>Socket地址API</h3><h4 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h4><p>字节序就是字节在内存中排列的顺序，在计算机中主机上的字节序和网络中的字节序是不一样的，<strong>字节序分为大端和小端，指的是低地址存储的是高位字节还是低位字节</strong>。</p>
<ul>
<li>主机字节序：小端字节序，低位地址存储的是低位字节。</li>
<li>网络字节序：大端字节序，低位地址存储的是高位字节。</li>
</ul>
<p>这样的话，在网络编程中，接收和发送这两个过程都需要将字节序转换。</p>
<p>linux中提供以下四个函数来完成主机字节序和网络字节序之间的转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	这组函数命名就能看出来，特别简单明了。 </span></span><br><span class="line"><span class="comment">*	在发送的时候需要调用hton,在接收的时候需要调用ntol。</span></span><br><span class="line"><span class="comment">*	至于long和short </span></span><br><span class="line"><span class="comment">*		一般来说转换IP地址使用long</span></span><br><span class="line"><span class="comment">*		转换端口使用short</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="通用Socket地址"><a href="#通用Socket地址" class="headerlink" title="通用Socket地址"></a>通用Socket地址</h4><p>socket网络编程接口中表示socket地址结构体为<code>sockaddr</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">  	<span class="keyword">sa_family_t</span> sa_family;	<span class="comment">// 地址族，一般和协议族相对应——UNIX,IPV4,IPV6</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];		<span class="comment">// socket地址值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个通用的socket地址一般来说不好用，比如设置与获取IP地址和端口号就需要执行繁琐的位操作，所以Linux提供了一组socket结构体。称之为Linux专用Socket地址。</p>
<h4 id="Linux专用Socket地址"><a href="#Linux专用Socket地址" class="headerlink" title="Linux专用Socket地址"></a>Linux专用Socket地址</h4><p>专用地址将Unix，IPv4和IPv6三个分开来了，在这里我们只介绍一下IPv4</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">  	<span class="keyword">sa_family_t</span> sin_family;		<span class="comment">// 地址族：AF_INET</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin_port;			<span class="comment">// 端口号，需要网络字节序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>	<span class="comment">// IPv4地址结构体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">    <span class="keyword">u_int34_t</span> s_addr;			<span class="comment">// IPv4地址，要用网络字节序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个专用地址的各字段含义已经足够明确。只不过需要注意的是，使用这个专用的地址仍需要转变成通用地址<code>sockaddr</code>, 因为所有socket编程接口使用的地址参数的类型都是<code>sockaddr</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 项目中的代码 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Address.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">sockaddr* <span class="title">getAddr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;sockaddr_);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sockaddr_in sockaddr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h4><p>一般人们习惯使用可读性好的字符串来表示IP地址，比如使用点十分制来表示IPv4的地址。而编程中我们必须将其转换成整数（二进制）才能使用。因次这里有几个函数能够将点十分字符数组和网络字节序整数相转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strptr)</span></span>;			<span class="comment">// 将字符数组转化成 网络字节序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp, struct in_addr* inp)</span></span>;	</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;					<span class="comment">// 将 in_addr 地址转变成字符数组</span></span><br></pre></td></tr></table></figure>



<h3 id="Socket基础API"><a href="#Socket基础API" class="headerlink" title="Socket基础API"></a>Socket基础API</h3><p>上一单元介绍Socket地址相关的API，之后就要正式使用socket了。</p>
<p>在Linux中一切皆文件，socket也不例外，因此<strong>socket就是一个可读可写可关闭可控制的文件描述符</strong>。</p>
<h4 id="创建Socket"><a href="#创建Socket" class="headerlink" title="创建Socket"></a>创建Socket</h4><p>Linux通过<code>socket</code>系统调用来创建一个套接字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">*	domain : 使用哪个底层协议族 </span></span><br><span class="line"><span class="comment">*	type: 指定服务类型，一般有两种服务类型 stream 和 ugram （对应着TCP的字节流和UDP的数据包）</span></span><br><span class="line"><span class="comment">*	protocol： 在两个参数下，再选择具体的协议，一般默认为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in Socket.cpp :IPv4 ，字节流 | 非阻塞 | 调用fork关闭socket</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> res = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h4 id="命名Socket"><a href="#命名Socket" class="headerlink" title="命名Socket"></a>命名Socket</h4><p>创建socket之后，我们需要将一个socket和socket地址绑定，这称为socket命名。命名采用的是以下的系统调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">*	feature：该函数将my_addr所指的socket地址分配给未命名的sockfd文件描述符，addrlen参数指的是该socket地址的长度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// in Socket.cpp : 将socket地址与监听描述符绑定，之后这个监听描述符就代表socket</span></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">bind</span>(listenfd, addr.<span class="built_in">getAddr</span>(), addr.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>

<p>在bind的时候容易遇到一个error：98（被绑定的地址正在使用），这是因为处于Time_wait状态，还没有完全释放该地址。</p>
<h4 id="监听Socket"><a href="#监听Socket" class="headerlink" title="监听Socket"></a>监听Socket</h4><p>socket被命名之后，还不能马上接收客户连接，我们需要<strong>使用<code>listen</code>系统调用来创建监听队列以存放待处理的客户连接</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> socketfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// socketfd = listenfd 套接字的文件描述符，backlog为创建的监听队列长度。</span></span><br><span class="line"><span class="comment">// in Socket.cpp </span></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">listen</span>(listenfd, maxLength);</span><br></pre></td></tr></table></figure>

<p><strong>backlog是参数提示内核监听队列的最大长度。如果监听队列的长度超过backlog，那么服务器将不再受理新的客户连接，客户端也将收到<code>ECONNREFUSED</code>的错误信息。注意这个客户连接是处于<code>ESTABLISHED</code>状态的。</strong></p>
<p>再通俗易懂的解释一下，就是在这个服务器上总共最多只能有backlog个连接处于ESTABLISHED状态。</p>
<h4 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h4><p>下面系统调用从listen监听队列中接收一个连接，这个函数是socket基础API中的重头戏。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* feature： 其参数唯一表示一个socket，返回的int是该连接的文件描述符，之后会对该文件描述符进行操作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> connfd = <span class="built_in">accept</span>(sockfd, addr.<span class="built_in">getAddr</span>(), &amp;addrlen);</span><br></pre></td></tr></table></figure>

<p><strong>accept的功能只是通过socket从监听队列中取出连接，而不论连接处于何种状态（如established和close_wait），也不关心任何网络情况。</strong></p>
<p>这个功能有两层意义</p>
<ul>
<li>一般来说从监听队列中取出的连接，其状态为established，但是如果这个时候突然断开连接，成为close_wait，accept也依旧能取出来，它只是做一个取的动作，而不检查其状态是否正常。</li>
<li>不关心任何网络情况：一般来说很多人会以为accept是接收一个连接，完成三次握手，这是错误的！在进入监听队列的时候三次握手已经完成了，不然状态怎么可能为established，三次握手是内核自发完成的，用户系统调用无法干涉，因此accept只是个系统调用——在用户态进入内核，将内核中的连接取出，返回用户态时将连接文件描述符一并带出。</li>
</ul>
<h4 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h4><p>如果说服务器通过listen调用来被动接受连接，那么客户端需要使用<code>connect</code>主动与服务器建立连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// feature: 通过sockfd和sockaddr唯一标识一个socket，然后通过这个socket主动建立连接。</span></span><br><span class="line"><span class="comment">// 			一旦建立链接，那么sockfd唯一标识该连接并返回0，如果失败返回-1并设置errno</span></span><br></pre></td></tr></table></figure>

<p>发起连接是客户端的事情，如果做服务器开发其实只是了解即可。</p>
<h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><p>关闭连接实际上就是关闭该连接对应的socket，一般有两种关闭方式</p>
<p>第一种方式就是使用close像关闭文字描述符的时候直接关闭它，不过fd是有引用计数的，close只不过是将fd的引用计数减1，当减为0才会关闭。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注意默认情况下close是立即关闭，如果关闭时还有数据要传送该怎么办？有一个SO_LINGER选项，能够延迟关闭时间。</p>
<p>第二种方式是一种优雅关闭连接，使用shutdown系统调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br><span class="line"><span class="comment">// howto :  SHUT_RD, SHUT_WR, SHUT_RDWR</span></span><br></pre></td></tr></table></figure>

<p>该系统调用能够分别关闭socket上的读或写，或者都关闭，但是这个关闭只是关闭了通道，并没有释放文件描述符。</p>
<h4 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h4><p>数据读写直接使用read和write。这里就不再赘述。</p>
<h3 id="Socket选项"><a href="#Socket选项" class="headerlink" title="Socket选项"></a>Socket选项</h3><p>socket选项有很多，值得注意的是为socket设置选项的时间一般是有要求的。</p>
<ul>
<li>服务端设置选项需要在<code>listen</code>之前</li>
<li>客户端设置选项需要再<code>connect</code>之前</li>
</ul>
<p>原因是这两个函数启动之后就直接进行三次握手了，设置选项需要在这之前，以下是设置选项的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">const</span> <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span>* option_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sockfd表明指定的socket</span></span><br><span class="line"><span class="comment">// level指定要操作哪个协议的选项（即属性） -&gt; SOL_SOCKET, IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP</span></span><br><span class="line"><span class="comment">// option_xxx 所选选项的信息</span></span><br></pre></td></tr></table></figure>

<p>接下来我们来看看常见的选项。</p>
<h4 id="SO-REUSEADDR选项"><a href="#SO-REUSEADDR选项" class="headerlink" title="SO_REUSEADDR选项"></a><code>SO_REUSEADDR</code>选项</h4><p>之前我们讨论过TIME_WAIT状态，如果关闭服务器重启的话，可能会出现errno 98。这是因为socket地址还没有释放。使用这个选项的话能够让强制使用这个socket地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSERADDR, &amp;reuse, <span class="built_in"><span class="keyword">sizeof</span></span>(reuse));</span><br></pre></td></tr></table></figure>

<h4 id="SO-RCVBUF和SO-SNDBUF选项"><a href="#SO-RCVBUF和SO-SNDBUF选项" class="headerlink" title="SO_RCVBUF和SO_SNDBUF选项"></a><code>SO_RCVBUF</code>和<code>SO_SNDBUF</code>选项</h4><p>​    两个选项分别表示TCP接收缓冲区和发送缓冲区的大小，一般来说接收缓冲期的最小值为256字节，而发送期的最小值为2048个字节。这两个选项的目的是想扩大内核中的接收/发送缓冲区，这样确保TCP连接用于足够的空闲缓冲区来处理拥塞。</p>
<h4 id="SO-RCVLOWAY和SO-SNDLOWAT选项"><a href="#SO-RCVLOWAY和SO-SNDLOWAT选项" class="headerlink" title="SO_RCVLOWAY和SO_SNDLOWAT选项"></a><code>SO_RCVLOWAY</code>和<code>SO_SNDLOWAT</code>选项</h4><p>​    两个选项分表表示接收缓冲区和发送缓冲区的低水位标记。低水位标记是被用于I/O多路复用中判断该socket是否可读或可写，如果缓冲区内可读/可写数据超过了低水位，那么I/O复用系统就会将该事件通知给应用程序说明该socket已经有数据可读/可写了。</p>
<p>​    一般默认的话，低水位标记都为1字节</p>
<h4 id="SO-LINGER选项"><a href="#SO-LINGER选项" class="headerlink" title="SO_LINGER选项"></a><code>SO_LINGER</code>选项</h4><p>​    该选项是用于控制close系统调用在关闭TCP连接时的行为。</p>
<p>​    默认情况下，当我们使用close关闭一个socket时，close会立即返回，<strong>TCP模块负责把该socket对应的TCP缓冲区中残留的数据发送给对方。</strong></p>
<p>​    设置该选项时我们需要为socket传递以下结构体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l_onoff;		<span class="comment">// 0 - 关闭该选项，非0 - 开启该选项</span></span><br><span class="line">    <span class="keyword">int</span> l_linger;		<span class="comment">// 滞留时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据这两个成员变量不同值，close能产生以下行为。</p>
<ul>
<li><code>l_onoff</code>等于0。close使用默认情况关闭socket</li>
<li><code>l_onoff</code>非0，<code>l_linger</code>等于0。 close调用依旧立即返回，不过此时是直接丢弃socket对应的TCP发送缓冲区中的残留数据，同时给对方发送一个RST。这为服务器提供了异常终止一个连接的方法。</li>
<li><code>l_onoff</code>非0，<code>l_linger</code>大于0。此时如果是阻塞的，那么必须等待<code>l_linger</code>时间才能发送并确认，如果不阻塞，将TCP发送完收到确认即可。</li>
</ul>
<h3 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h3><p>socket地址的两大要素：端口和IP地址都是用数值表示，这里有些能够直接记录网络信息的API,这些不是重点，在需要的时候查就行了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本文记录了一些网络编程的基础知识，在最开始看的时候也觉得全是一些API，这些API都要使用过才能体会到它们的用处和原理。做笔记的时候已经将webserver做完了，这个时候来看这些东西确实很基础，但是在回顾的时候也可以借此机会进行code reveiw，这样能够对套接字编程会有进一步的了解。</p>
<p>​    下一篇相关文章就开始对整个web服务器进行介绍，来探讨一下reactor模型。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《UNP》</li>
<li>《APUE》</li>
<li>《Linux高性能服务器编程》</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/posts/24cb124c/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章主要介绍一下传输层的常见知识点，比如UDP的基本介绍，TCP的重点介绍。</p>
</blockquote>
<span id="more"></span>

<p>[TOC]</p>
<hr>
<h3 id="UDP相关"><a href="#UDP相关" class="headerlink" title="UDP相关"></a>UDP相关</h3><h4 id="UDP定义"><a href="#UDP定义" class="headerlink" title="UDP定义"></a>UDP定义</h4><p>UDP是一个保留消息边界的<strong>尽力而为的无连接的数据报协议</strong>，协议号为17。其基本特点有三个：</p>
<ul>
<li><p><strong>尽力而为，不可靠</strong>：UDP是一种尽力而为的协议，不保证可靠性，毕竟没有连接的约束，也没有差错纠正。</p>
</li>
<li><p><strong>无连接</strong>：在传输数据之前两端不需要建立链接</p>
</li>
<li><p><strong>数据报</strong>：UDP发送的是数据单元叫做数据报，数据报就是应用程序生成的报文加一个只有<strong>八字节的报文头。</strong>数据报不拆分也不合并，应用程序怎么给我，对方收到的也是同样的。</p>
</li>
</ul>
<p>由于这两个基本特点，衍生出了一些常见的特点：</p>
<ul>
<li><strong>开销小，传输快</strong>：头部只有八字节，又不需要连接和拆分，因此开销和传输都有优势。</li>
<li><strong>传输内容不长</strong>：因为UDP是完整的数据报，那么其传输的内容会被限制在这个数据报中，所以传输有限。</li>
<li><strong>只提供差错检测，不提供差错纠正</strong>：因为头部只有8bytes，只会简单CRC校验，如果出错直接扔。</li>
<li><strong>吞吐量不受传输层的拥塞控制算法影响</strong>：其传输速度在传输层仅仅是受应用程序生成数据的速度，计算机的能力和传输带宽的限制，在接收端只是受应用程序从队列中读取消息段的速度限制。</li>
</ul>
<h4 id="UDP应用场景"><a href="#UDP应用场景" class="headerlink" title="UDP应用场景"></a>UDP应用场景</h4><p>UDP的应用场景很简单，完全取决于其两个特点。</p>
<ul>
<li><strong>多播广播</strong>：由于传输数据不建立连接，因此不需要维护连接状态，这样一来可以轻松在同一台服务器上对多个客户机传输相同的信息。</li>
<li><strong>DHCP，DNS，视频语音等应用</strong>：这些应用（协议）都使用了UDP，因为它们都对<strong>传输速度有要求</strong>。不过后面两个还是用到了TCP，这个是为了对传输内容长度和可靠性而考虑，毕竟TCP传输的东西更多，也更可靠。</li>
</ul>
<p>注意</p>
<ul>
<li>ping是使用ICMP协议，他和上层的TCP和UDP都无任何关系。</li>
</ul>
<h4 id="UDP优缺点"><a href="#UDP优缺点" class="headerlink" title="UDP优缺点"></a>UDP优缺点</h4><p>UDP的优缺点都很明显，全部在上面的特点中展现出来了。</p>
<p>优点：</p>
<ul>
<li>简单，开销小，速度快，适用于多播广播。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不可靠，传输内容少，没有差错检测，而且如果链路复杂丢包率会很高。</li>
</ul>
<h3 id="TCP相关"><a href="#TCP相关" class="headerlink" title="TCP相关"></a>TCP相关</h3><h4 id="TCP与UDP的差别"><a href="#TCP与UDP的差别" class="headerlink" title="TCP与UDP的差别"></a>TCP与UDP的差别</h4><p>好，又到了我最喜欢的差别环节，通过这个差别完全可以理解TCP是什么。</p>
<p>TCP是<strong>可靠的面向连接的字节流</strong>协议，协议号为6。同样的，其基本特点有三个：</p>
<ul>
<li><p><strong>可靠性</strong>：TCP是可靠的，它能够保证数据一定能够传输到对面，可靠性的基础是<strong>ACK重传机制</strong>。</p>
</li>
<li><p><strong>面向连接</strong>：TCP在传输数据之前需要建立端到端的连接，建立链接时需要进行三次握手，释放链接时需要四次挥手。不过因为其面向连接，因此在连接建立和解除的时候需要注意大量的细节，这些细节放在后面讲。</p>
</li>
<li><p><strong>字节流</strong>：TCP传输的是可分割的字节流数据，而不是像UDP一样直接发送整个数据报过去，这样可以保证其发送的应用数据长度不受限制。但是TCP必须在发送端进行切片，在接收端进行重组，如果处理不当，就可能产生“粘包”问题。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否面向连接</th>
<th>传输可靠性</th>
<th>传输形式</th>
<th>传输效率</th>
<th>所需资源</th>
<th>应用场景</th>
<th>首部字节</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>是</td>
<td>可靠</td>
<td>字节流</td>
<td>慢</td>
<td>多</td>
<td>文件传输，邮件传输</td>
<td>20-60</td>
</tr>
<tr>
<td>UDP</td>
<td>否</td>
<td>不可靠</td>
<td>数据报</td>
<td>快</td>
<td>少</td>
<td>即时通讯，域名转换</td>
<td>8</td>
</tr>
</tbody></table>
<h4 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h4><p>TCP报文头部是<strong>20个字节固定头部再加至多40个字节的TCP选项</strong>。</p>
<img src="/posts/24cb124c/TCP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" class title="TCP报文格式">

<p><strong>固定头部：</strong></p>
<p>​    从上图中，可以看出来TCP头部的组成部分。</p>
<ul>
<li><p>端口：源端口和目的端口，再加上IP头部的源IP和目的IP，唯一地标识着一个连接。</p>
</li>
<li><p>序列号和确认号：</p>
<ul>
<li><strong>序列号标识着这个字节流的序列，也是该报文段的第一个字节。</strong></li>
<li><strong>确认号是最后成功被标识的序列号，也是期待收到的下一个序列号。</strong></li>
</ul>
</li>
<li><p>头部长度：因为长度是在20-60之间，所以要有个头部长度进行标识。</p>
</li>
<li><p>位字段：</p>
<ul>
<li>SYN: <strong>当一个连接启动时，发的第一个报文段叫做SYN报文段。</strong></li>
<li>ACK: 确认字段，一般连接开启都是启用状态</li>
<li>RST：充值连接（连接取消，经常是因为错误）</li>
<li>URG：紧急字段，用于传输带外数据</li>
<li>FIN：该报文的发送方不会再给对方发送数据，但是可能会发送ACK，参见四次挥手第一次和第三次会发送FIN。</li>
</ul>
</li>
<li><p>窗口大小：主要用于 <strong>TCP 流量控制</strong>。该字段用来告诉发送方其窗口（缓冲区）大小，以此控制发送速率，从而达到流量控制的目的。</p>
</li>
<li><p>校验和：进行TCP校验，如果出现差错，那么接收方会丢弃该报文。</p>
</li>
</ul>
<p><strong>选项：</strong></p>
<p>​    一般为空，但是在下面的情况下有用：</p>
<ul>
<li><p><strong>TCP 连接初始化时，通信双方确认最大报文长度。</strong>（这个也能完美解决粘包问题）</p>
</li>
<li><p>在高速数据传输时，可使用该选项协商<strong>窗口扩大因子</strong>。</p>
</li>
<li><p><strong>作为时间戳时，提供一个较为精准的RTT</strong>，主要为了更好的实现 TCP拥塞控制协议。</p>
</li>
<li><p>修改MSS，最大保温段长度。</p>
</li>
<li><p>认证选项，生成通信密钥加强连接安全性</p>
</li>
</ul>
<p><strong>总结</strong>：</p>
<p>​    直接看一个TCP报文是记不住任何东西的，必须得让TCP报文中的各个部分和实际的功能结合在一起，这样就能够理解TCP报文为何如此设计了。</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>三次握手流程：</p>
<img src="/posts/24cb124c/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" class title="三次握手">

<p>三次握手相关问题：</p>
<ul>
<li><p>为什么要进行三次握手，两次握手可以吗？</p>
<ul>
<li>不可以，三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。<strong>若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。</strong>这样的话，如果第二次握手失败的话，服务器是不知道的，客户机想重新建立连接的话，服务器这边始终以为是新的连接，会极大浪费资源。</li>
</ul>
</li>
<li><p>三次握手最开始有SYN，了解SYN攻击么？</p>
<ul>
<li>SYN Flood是一种最常见的DDos攻击。</li>
<li>其攻击原理为伪造地址向服务器发送SYN请求，然后服务器会回应一个ACK+SYN。而真实的IP认为自己没有发送请求，不予以回应，这样服务器会重试3-5次等待一个SYN时间，再丢弃这个连接。这样的话如果短时间内很多这个连接出现，那就可能会导致服务器消耗大量资源去处理这些连接。</li>
</ul>
</li>
<li><p>SYN_Flood防御：</p>
<ul>
<li>使用Cookie认证。<strong>原理是syn报文首先由DDOS防护系统来响应syn_ack。带上特定的序列号（记为cookie）。真实的客户端会返回一个ack 并且确认号为cookie+1。 而伪造的客户端，将不会作出响应。这样我们就可以知道那些IP对应的客户端是真实的，将真实客户端IP加入白名单。</strong>这样的话就丧失了超时重传的能力，毕竟如果不在白名单直接丢弃了。</li>
<li>使用代理服务器：先在代理服务器上进行甄别，然后再将合法的链接请求发送给服务器，这样的缺点是链接次数从三次握手变成6次握手了。</li>
</ul>
</li>
</ul>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>四次挥手流程：</p>
<img src="/posts/24cb124c/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" class title="四次挥手">

<p>了解了流程，可以直接看看书上的有限状态机。</p>
<img src="/posts/24cb124c/TCP%E7%8A%B6%E6%80%81.JPG" class title="TCP状态转移">

<p>四次挥手相关问题：</p>
<ul>
<li><p>为什么要进行四次挥手，三次挥手可以吗？</p>
<ul>
<li>不可以。释放 TCP 连接时之所以需要四次挥手，是因为 <strong>FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的</strong>。 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。</li>
<li>简而言之<strong>TCP是全双工的，两个方向的连接需要单独关闭。</strong></li>
</ul>
</li>
<li><p>Close-Wait和Time-Wait的状态和意义</p>
<ul>
<li>Close-Wait是在服务器在四次挥手中服务器端发送确认报文和结束连接的FIN报文之间的状态。这个时候服务器已经收到了关闭请求并告诉客户端自己已经成功收到该请求了，不过这个时候服务器还有一些数据没有传输完成，因此不能立即关闭连接，而 <strong>CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。</strong></li>
<li>Time-Wait发生在客户端收到服务器的FIN报文并发送ACK确认报文之后，知道客户端关闭连接的状态。这是为了保证<strong>客户端发送的最后一个确认报文能够到达服务器端，如果没有成功到达，则服务器超时重传FIN报文段，客户端再重传ACK报文段并重新计时</strong>。Time_Wait的时间一般为2MSL。</li>
</ul>
</li>
<li><p>Time-Wait为什么是2MSL,如果没有设置会出现什么？</p>
<ul>
<li>MSL是TCP报文最大生命周期，2MSL是服务端发出FIN报文和客户端能够发送ACK能保持的最大有效时间。</li>
<li>如果在1MSL时服务器没有收到ACK确认，那么就会重新给客户机发送FIN报文，这样客户端再重传的时间限制也是1MSL，相加就是2MSL。</li>
<li>如果没有设置的话，那就意味着收到FIN就会直接关闭，这样的话如果确认报文对方没收到，对方会重新发送FIN而不会一起关闭。下次再启用这个这个端口对方就不会认为是新连接了，会出现数据异常。</li>
</ul>
</li>
<li><p>服务器中处于Close_Wait的连接过多会怎么办？</p>
<ul>
<li><p>其实这个问题在做web服务器的时候遇到过，太多Close_Wait主要原因是某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接。说明服务器没有给客户端发送FIN报文，这样的话会导致（errno 24：Too many files）因为连接还在继续。这样在短连接时很容易达到文件描述符上限。</p>
</li>
<li><p>解决方法：检测出对方已经关闭的socket，然后关闭它，或者设置定时器，定期检查socket，要么从短连接设置为长连接，开启keepALive选项。</p>
</li>
</ul>
</li>
<li><p>TIME-WAIT会导致什么？</p>
<ul>
<li>这个也遇到过，如果关闭一个服务器重新启动的时候，会发生（errno 98：端口地址被占用），这个就是因为关闭只是发送一个FIN操作，还没有完全关闭，得等最多3MSL（1MSL发送报文，2MSL的time_wait）才能close。</li>
<li>大量情况下如何解决，这种解决方法一般都能从套接字选项本身寻找答案，将端口设置为可重用。</li>
</ul>
</li>
</ul>
<h4 id="TCP可靠性"><a href="#TCP可靠性" class="headerlink" title="TCP可靠性"></a>TCP可靠性</h4><p>TCP是通过以下的基础来保证可靠性</p>
<ul>
<li><strong>数据分块</strong>：应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li><strong>序列号和确认应答</strong>：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</li>
<li><strong>校验和</strong>： TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</li>
<li><strong>流量控制</strong>： TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</li>
<li><strong>拥塞控制</strong>： 当网络某个节点发生拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议</strong>： 也是为了实现可靠传输的，它的基本原理就是<strong>每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组</strong>。（停止等待协议）</li>
<li><strong>超时重传</strong>： 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</li>
</ul>
<h4 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h4><p>超时重传的原理： 发送方在发送一次数据后就开启一个<strong>定时器</strong>，在一定时间内如果没有得到发送数据包的 ACK 报文，那么就重新发送数据，在达到一定次数还没有成功的话就放弃重传并发送一个复位信号。其中<strong>超时时间的计算是超时的核心，而定时时间的确定往往需要进行适当的权衡，因为当定时时间过长会造成网络利用率不高，定时太短会造成多次重传，使得网络阻塞。在 TCP 连接过程中，会参考当前的网络状况从而找到一个合适的超时时间。</strong></p>
<h4 id="流量控制与拥塞控制"><a href="#流量控制与拥塞控制" class="headerlink" title="流量控制与拥塞控制"></a>流量控制与拥塞控制</h4><p><strong>流量控制</strong>：</p>
<ul>
<li>所谓流量控制就是让<strong>发送方的发送速率不要太快，让接收方来得及接收</strong>。如果接收方来不及接收发送方发送的数据，那么就会有分组丢失。<strong>在 TCP 中利用可边长的滑动窗口机制可以很方便的在 TCP 连接上实现对发送方的流量控制</strong>。主要的方式是<strong>接收方返回的 ACK 中会包含自己的接收窗口大小，以控制发送方此次发送的数据量大小（发送窗口大小）</strong>。</li>
</ul>
<p><strong>拥塞控制</strong>：</p>
<ul>
<li>拥塞控制和流量控制不同，<strong>拥塞控制是作用于整个网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。</strong></li>
</ul>
<p><strong>拥塞控制的算法：</strong></p>
<p>​    拥塞控制的算法有慢启动，拥塞避免，快重传和快恢复四种方法。一般来说在TCP建立连接的时候会使用慢启动算法，然后知道丢包之后，才会执行拥塞避免算法</p>
<img src="/posts/24cb124c/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95.png" class title="拥塞控制算法">

<ul>
<li><p>慢启动：当一个<strong>新的TCP连接建立或检测到由重传超时（RTO）导致的丢包时，需要执行慢启动。</strong></p>
<ul>
<li>算法：<strong>以指数增长的方法扩大发送窗口。</strong>如果探到阈值（即发生丢包），那么在上一次成功发送包的基础上使用拥塞避免。</li>
<li>目的：由于是指数增长，这会使得TCP在拥塞避免探寻更多可用带宽之前得到cwnd的值，以及帮助建立ACK时钟。</li>
</ul>
</li>
<li><p>拥塞避免：拥塞避免一般在一次丢包后执行。</p>
<ul>
<li>算法：由于是丢包之后再执行，这样的话必须谨慎的增长cwnd，<strong>以线性增长的方法扩大发送窗口。</strong></li>
<li>目的：由于是线性增长，就希望能够保持高发送窗口（发送窗口大于阈值的一半）的速度发送数据。</li>
</ul>
</li>
<li><p>快重传：快重传一般使用在接收到失序的报文时，立即想对方发送重复确认。</p>
<ul>
<li>算法：假设发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。</li>
<li>目的：在报文失序的时候能够准确的知道未接收的报文是哪一个，这样能够很好的提高网络的吞吐量。</li>
<li>为何有失序情况：因为IP层不能保证包传输是有序的，可能后发的包走的链路更快一点。</li>
</ul>
</li>
<li><p>快恢复：快恢复是和快重传搭配使用的。</p>
<ul>
<li><p>算法：</p>
<p>① 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限 ssthresh 值减半；</p>
<p>② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把 cwnd 值设置为 ssthresh 减半之后的值，然后执行拥塞避免算法，线性增大 cwnd。</p>
</li>
</ul>
</li>
</ul>
<h4 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h4><p>试想一下在一个空闲的TCP连接中双方都不发送数据，那如何能知道连接的情况，什么时候可以和对方断开连接？TCP的保活机制就是为了解决这类情况而设计的。</p>
<ul>
<li>定义：保活机制是一种在不影响数据流内容情况下探测对方的方式。它是由一个<strong>保活计时器</strong>实现的，当计时器被激发，<strong>连接一端将发送一个保活探测报文</strong>，另一端接收报文的同时会发送一个ACK作为响应。</li>
<li>发送保活报文对方的状态：<ol>
<li>对方仍在正常工作，那么回复一个ACK报文，重置计时器时间。</li>
<li>对方主机已经崩溃，那么收不到ACK报文，那请求端会持续发送探测报文，直到保活计时器时间超时，如果还没有收到回复，那么认为对方已经关机，断开连接。</li>
<li>自己主机崩溃且重启，那么请求端会收到保活探测报文的响应，不过这个确认报文带有RST字段，即希望请求端重新建立连接。</li>
<li>对方主机没事但是请求端依旧无法正确收到ACK响应报文，这时处理同2。</li>
</ol>
</li>
</ul>
<h4 id="使用TCP的问题"><a href="#使用TCP的问题" class="headerlink" title="使用TCP的问题"></a>使用TCP的问题</h4><p>一般来说使用TCP的问题在上面都基本提到了，现在再次总结一下：</p>
<ul>
<li><p>三次握手问题</p>
<ul>
<li>为什么三次？</li>
<li>SYN_Flood攻击以及解决办法</li>
</ul>
</li>
<li><p>四次挥手问题</p>
<ul>
<li>为什么四次？</li>
<li>Close_Wait和Time_Wait的状态意义，为什么会发生，如果服务器太多连接处于这个状态会出现什么问题？</li>
</ul>
</li>
<li><p>可靠性</p>
<ul>
<li>可靠性的基础——ACK重传</li>
<li>ARQ协议</li>
<li>超时重传</li>
</ul>
</li>
<li><p>拥塞控制</p>
<ul>
<li>四大算法以及使用条件和用法</li>
</ul>
</li>
<li><p>保活机制</p>
<ul>
<li>定义</li>
<li>分析状态以及处理手段</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>TCP“粘包”</li>
<li>TCP选项</li>
<li>待补充</li>
</ul>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《TCP/IP详解》 卷一</li>
<li><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/">https://leetcode-cn.com/leetbook/read/networks-interview-highlights/</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>拥塞控制</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/posts/a1ede006/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章介绍一下HTTP的基础知识。主要涉及方面有HTTP报文，HTTPS，HTTP2.0的改进等</p>
</blockquote>
<span id="more"></span>



<h3 id="HTTP协议介绍"><a href="#HTTP协议介绍" class="headerlink" title="HTTP协议介绍"></a>HTTP协议介绍</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>HTTP协议叫做超文本传输协议，广泛应用Web间的客户端与服务器之间的通信。现在一般介绍都是HTTP1.1。</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>是一个<strong>无状态的协议</strong>，无状态是指自身不对请求和响应的状态进行保存，这样的话协议对发送过的请求和响应都没有记录，不做持久化处理。这样能够使HTTP更简单。</p>
</li>
<li><p><strong>使用Cookie技术</strong>，虽然是无状态协议，但是依据可能要保证用户的状态，比如进入一个网页要保持登录状态。使用cookie的话能够很好的管理用户的状态。</p>
<ul>
<li>Cookie技术通过在请求和响应报文中写入Cookie信息来控制<strong>客户端</strong>的状态。</li>
<li><strong>服务器生成响应报文</strong>中的<code>Set-Cookie</code>首部字段，通知<strong>客户端保存Cookie</strong>。</li>
</ul>
</li>
<li><p>使用URI定位互联网上的资源，支持多种方法请求，如GET、POST等，请求方法和URI均在请求报文中的请求行中。</p>
</li>
<li><p>采用管线化持久连接： 1.1默认支持管线化和持久连接，这样的话能够减少重复建立和断开锁造成的额外开销，减轻了服务器的负载。管线化指的是可以发送多个请求，不用等待响应再发送，这样请求数多的话，时间差就越明显。</p>
</li>
</ul>
<h3 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h3><h4 id><a href="#" class="headerlink" title></a></h4><p>// todo 图</p>
<ul>
<li>请求行：包括请求方法，请求URI和HTTP版本</li>
<li>状态行：包含状态码，原因短语和HTTP版本</li>
<li>头部</li>
<li>报文主体</li>
</ul>
<p>HTTP在传输中可以使用<strong>分块传输编码</strong>的方法，能够提升HTTP传输的效率</p>
<h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>

<p>请求行最重要的就是请求方法，请求方法有以下几种：</p>
<ul>
<li>GET：获取URI的资源，请求报文主体为空。</li>
<li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。<strong>数据被包含在请求体中</strong>。可能会导致<strong>新的资源的建立或已有资源的更改。</strong></li>
<li>PUT：用于传输文件，报文主体是文件内容，保存到指定的URI中</li>
<li>DELET：删除文件，与PUT相反的操作，一般都不适用</li>
<li>HEAD：和get类似，无报文主体，只是确认一下URI的有效性，验证通信状态。</li>
</ul>
<p>GET和POST的区别：</p>
<ul>
<li><p><strong>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源</strong>。</p>
</li>
<li><p><strong>get 请求只支持 URL 编码，post 请求支持多种编码格式。</strong></p>
</li>
<li><p><strong>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</strong></p>
</li>
<li><p>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制</p>
</li>
<li><p>get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。</p>
</li>
<li><p>get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）。这个是因为POST首先发header过去，和服务器说之后要来东西了，然后再将主体发过去。</p>
</li>
</ul>
<h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure>

<p>状态行主要是告知从服务器端返回的请求结果。</p>
<p>状态码类别</p>
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>信息性状态码</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>成功状态码</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向状态码</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误状态码</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>服务器错误状态码</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<p>重要状态码：</p>
<ul>
<li><p>100 继续，服务器正在处理请求</p>
</li>
<li><p>200 请求成功</p>
</li>
<li><p>204 请求成功但无内容返回</p>
</li>
<li><p>206 范围请求成功</p>
</li>
<li><p>301 <strong>永久重定向</strong>； <strong>30(2|3|7)临时重定向，语义和实现有略微区别</strong>；（指定资源路径最后忘记加斜杠“/“,就会产生301状态码）</p>
</li>
<li><p>304 带if-modified-since 请求首部的条件请求，条件没有满足</p>
</li>
<li><p>400 <strong>语法错误</strong>（前端挨打）</p>
</li>
<li><p>401 需要认证信息</p>
</li>
<li><p>403 拒绝访问</p>
</li>
<li><p>404 找不到资源</p>
</li>
<li><p>412 除if-modified-since 以外的条件请求，条件未满足</p>
</li>
<li><p>500 <strong>服务器错误</strong>（后端挨打）</p>
</li>
<li><p>503 服务器宕机了（DevOps or IT 挨打）</p>
</li>
</ul>
<p>3开头的重定向，如果服务器返回有重定向之后的URL，那么会<strong>强制</strong>客户机再次发送正确的请求报文，毕竟只有2开头算是成功的响应。</p>
<h4 id="HTTP头部"><a href="#HTTP头部" class="headerlink" title="HTTP头部"></a>HTTP头部</h4><p>HTTP头部本质上是一个传送额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部。</p>
<ul>
<li><p>通用头部：请求报文和响应报文都有的头部，主要是提供一些通用的功能</p>
<ul>
<li>Connection：是否是长连接，连接是否关闭</li>
<li>Date：报文创建时间</li>
</ul>
</li>
<li><p>请求头部：请求报文特有的头部，<strong>用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容</strong>。</p>
<ul>
<li>Accept：告诉服务器自己允许哪些媒体类型</li>
<li>Accept-Charset: 浏览器可申明的字符集</li>
<li>Accept-Encoding： 浏览器可接受的响应内容语言列表</li>
<li>HOST：服务器的域名以及服务器所监听的端口号</li>
<li>RANGE：<strong>表示请求某个实体的一部分</strong></li>
<li>Authorization：用于表示 HTTP 协议中需要认证资源的认证信息</li>
</ul>
</li>
<li><p>响应头部：响应报文特有的头部，用于告知服务器上的一些信息</p>
<ul>
<li>Age：创建响应时间</li>
<li>Location： 重定向之后的URL，这个专门为3XX打造</li>
<li>Server：服务器的信息</li>
<li>Vary：缓存控制</li>
</ul>
</li>
<li><p>实体头部：是对实体内容的一些约束和补充说明</p>
<ul>
<li>ALLOW：允许的请求信息，如ALLOW： GET, HEAD</li>
<li>Content-xxx：返回内容的信息<ul>
<li>encoding：编码信息</li>
<li>length：长度，这个对于分块传送很重要</li>
<li>Range： 整个返回体本部分的字节位置</li>
<li>MD5：MD5校验值</li>
</ul>
</li>
<li>Expire：响应的过期时间</li>
<li>Last-Modified：请求资源最后修改的时间</li>
</ul>
</li>
</ul>
<p>其他问题：</p>
<p>HTTP长连接和短连接的区别：</p>
<ul>
<li><p>长连接：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</p>
</li>
<li><p>短连接：用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</p>
</li>
</ul>
<h3 id="HTTPS相关"><a href="#HTTPS相关" class="headerlink" title="HTTPS相关"></a>HTTPS相关</h3><p>HTTP是一个很简单好用的协议，但是对安全性几乎没有保障，其不足点如下：</p>
<ul>
<li>通信使用明文（不加密），内容可能被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以可能已遭到篡改</li>
</ul>
<p>针对以上的不足，HTTPS对其有以下的改进：</p>
<ul>
<li>对通信使用加密技术：通过和SSL或TLS的组合使用，加密HTTP的通信内容。</li>
<li>使用证书来确定通信方的身份：SSL不但提供加密处理，而且还使用一种被称为证书的手段，证书是一个由第三方发布的，伪造起来很难。</li>
<li>HTTP虽然使用<strong>MD5散列值校验和确定文件的数字签名方法</strong>，但是还是不能保证报文完整性，这里使用的依旧是证书的功能，这样传输过程中就不会被破解了。</li>
</ul>
<p>因此由上可得HTTP = HTTP over SSL，SSL能把这些安全性问题都解决。</p>
<h4 id="HTTP和HTTPS的差别："><a href="#HTTP和HTTPS的差别：" class="headerlink" title="HTTP和HTTPS的差别："></a>HTTP和HTTPS的差别：</h4><ul>
<li><p>HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。</p>
</li>
<li><p>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。</p>
</li>
<li><p>HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。</p>
</li>
<li><p>HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。</p>
</li>
</ul>
<h4 id="SSL协商："><a href="#SSL协商：" class="headerlink" title="SSL协商："></a>SSL协商：</h4><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：</p>
<p>① 客户端发起一个 HTTPS 请求，并连接到服务器的 443 端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；</p>
<p>② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。</p>
<p>③ 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。</p>
<p>④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。</p>
<p>⑤ SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secre，并且该报文是经过证书中的公钥加密过的。</p>
<p>⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre 加密的。</p>
<p>⑦ 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。</p>
<p>⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。</p>
<p>当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。</p>
<h4 id="HTTPS加密方式："><a href="#HTTPS加密方式：" class="headerlink" title="HTTPS加密方式："></a>HTTPS加密方式：</h4><p>采取对称加密和非对称加密相结合的方式，首先使用SSL协议协议进行加密传输，为了弥补费对称加密的缺点，采用证书进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端<strong>协商</strong>好之后进行通信传输的<strong>对称加密</strong>，后续的所有信息都通过该对称秘钥进行加密解密。</p>
<p>证书：</p>
<p>在HTTPS中证书一定是值得信任的，证书是由第三方机构颁发的，用户给公共密钥和一些个人身份信息给认证中心，认证中心返还给用户一个数字证书。</p>
<p>对称加密：</p>
<p>对称加密就是双方协商之后的共享秘钥加密。因为其加密解密的秘钥相同，而且是经历过协商，在通信中使用的。</p>
<p>非对称加密：</p>
<p>非对称加密就是公开秘钥加密。因为其有一把公钥和私钥，公开加密处理复杂，因此不适用于通信，但是很适合用于帮助对称加密交换密钥。</p>
<table>
<thead>
<tr>
<th></th>
<th>对称加密（共享加密）</th>
<th>非对称加密（公开加密）</th>
</tr>
</thead>
<tbody><tr>
<td>加密处理</td>
<td>双方使用同一个密钥</td>
<td>使用公钥和私钥，公钥进行加密，私钥进行解密</td>
</tr>
<tr>
<td>特点</td>
<td>处理简单，方便</td>
<td>处理困难，但是安全性高，不会被窃听</td>
</tr>
<tr>
<td>用法</td>
<td>用于通信传输，一般配合证书搭配使用</td>
<td>用于共享密钥的传送，保证共享密钥的安全性</td>
</tr>
</tbody></table>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><table>
<thead>
<tr>
<th></th>
<th>HTTP1.0</th>
<th>HTTP1.1</th>
<th>HTTP2.0</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td>默认无连接</td>
<td><strong>默认长连接，支持管线化</strong></td>
<td><strong>二进制传送，封装成帧</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td>使用缓存处理</td>
<td><strong>多路复用</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td>节约带宽</td>
<td>头部压缩</td>
</tr>
<tr>
<td></td>
<td></td>
<td>使用请求头</td>
<td>服务端推送</td>
</tr>
</tbody></table>
<p>HTTP1.0没什么讲的。</p>
<p>HTTP1.1中的几大特点都是根据头部信息有关：</p>
<ul>
<li>长连接，管线化： Connection字段的Keep-alive</li>
<li>缓存处理：if-modified-since字段负责</li>
<li>节约带宽：通过range只请求部分资源，不需要请求全部资源。</li>
<li>请求头：使用HOST能够声明主机。</li>
</ul>
<p>HTTP2.0的提升就特别大了</p>
<ul>
<li><p>二进制传送：HTTP1.X的传输单位为报文，而2.0将其封装成帧，帧组成数据流，能够实现二进制传送。</p>
</li>
<li><p>多路复用：在封装成帧的概念下，帧里面有流ID和优先级，可以实现多个请求同时传输多个结果同时处理，而且可以ABA（先发A的上半部，再发B，再发B的下半部）这样发请求报文。再加上优先级的概念，这样处理请求可以完全实现多路复用。</p>
</li>
<li><p>头部压缩：HTTP/2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 HTTP 传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。</p>
</li>
<li><p>服务器推送。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送。</p>
</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>这里来个经典问题</p>
<p>网页解析全过程【用户输入网址到显示对应页面的全过程】</p>
<img src="/posts/a1ede006/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class title="流程图">

<p>从上图可以看出一般分为以下几个部分</p>
<ol>
<li><p><strong>解析域名</strong>：当用户输入一个网址并按下回车键的时候，浏览器会获得一个域名，而通信首先需要通过域名去找到服务器的IP地址。一般是根据DNS协议去查找IP地址。</p>
</li>
<li><p><strong>DNS原理</strong>：DNS是一个基于UDP的应用层协议，端口号为53，一般来说DNS采取分布式的设计方案，其域名空间采取一种树形的层次。从根到叶总共三层：根服务器，顶级服务器，权威服务器。除此之外还有本地服务器。一般来说DNS请求首先是在本地寻找缓存，如果有缓存的话那就直接用，如果没有就像本地DNS服务器发送一个DNS查询报文，本地DNS服务器中的缓存没有，那就直接将该报文转发到根服务器，然后进行递归迭代查询。</p>
</li>
<li><p><strong>TCP连接</strong>：当查询到了服务器的IP地址，那么就可以通过TCP协议去建立一个连接了，建立连接就是三次握手，这个不再赘述。</p>
</li>
<li><p><strong>发送HTTP请求</strong>：浏览器向Web服务器发起一个HTTP请求，然后服务器处理后浏览器收到响应报文，如果是HTTPS还要进行SSL协商。这个也不再赘述。</p>
</li>
<li><p><strong>浏览器渲染</strong>： 浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这些是前端的知识了。</p>
</li>
<li><p>断开连接：四次挥手，断开连接。</p>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p>《图解HTTP》</p>
</li>
<li><p>《TCP/IP详解》卷一</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>STL空间配置器</title>
    <url>/posts/1cc2fcbf/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章简单记录一下STL中的空间配置器(allocator)</p>
</blockquote>
<span id="more"></span>



<h4 id="空间配置"><a href="#空间配置" class="headerlink" title="空间配置"></a>空间配置</h4><p>​    STL中的空间配置器是实现STL的第一个部件，因为整个STL的操作对象都放在容器中，而容器一定需要配置空间。如果没有了解到STL的空间配置原理的话，在之后学习STL其它组件时会遇到困难。</p>
<p>​    而为什么叫空间配置器而非常见的内存配置器呢？因为这个空间不一定是内存，你也可以写个allocator直接像硬盘中取空间。不过在SGI STL中提供的配置器，配置对象是内存。</p>
<p>​    内存空间的配置和释放在C++语法部分就已经了解到，是通过<code>::operator new</code>和<code>::operator delete</code>来实现的。 这两者通过调用malloc/free来对内存进行操作。这里不再赘述。</p>
<h4 id="SGI中的std-allocator"><a href="#SGI中的std-allocator" class="headerlink" title="SGI中的std::allocator"></a>SGI中的<code>std::allocator</code></h4><p>​    SGI标准的空间配置器为<code>std::allocator</code>，该配置器只是把C++中的<code>::operator new</code>和<code>::operator delete</code>做了一层薄薄的包装而已。这样的话<strong>效率不高</strong>，因此不建议使用。</p>
<h4 id="SGI中的std-alloc"><a href="#SGI中的std-alloc" class="headerlink" title="SGI中的std::alloc"></a>SGI中的<code>std::alloc</code></h4><h5 id="alloc介绍"><a href="#alloc介绍" class="headerlink" title="alloc介绍"></a><code>alloc</code>介绍</h5><p>​    由于标准的空间配置器<code>std::allocator</code>不管用，那么SGI又实现了另外一个空间配置器<code>std::alloc</code>。</p>
<p>​    众所周知，C++内存配置和释放操作一般如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> ... &#125;;</span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="keyword">delete</span> pf;</span><br></pre></td></tr></table></figure>

<p>其中new算式内含有两个操作：</p>
<ol>
<li>调用<code>::operator new</code>配置内存；</li>
<li>调用<code>Foo::Foo()</code>构造对象。</li>
</ol>
<p>而delete算式内含有两个操作</p>
<ol>
<li>调用<code>Foo:~Foo()</code>析构对象；</li>
<li>调用<code>::operator delete</code>释放内存。</li>
</ol>
<p>因此该配置器将两阶段操作区分开来。内存配置操作由<code>alloc::allocate()</code>负责，对象构造由<code>alloc::construct()</code>负责，内存释放操作同理。</p>
<p>配置器定义域<code>&lt;memory&gt;</code>之内</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in &lt;memory&gt; </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_alloc.h&gt;</span>					<span class="comment">// 负责内存空间的配置与释放</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_construct.h&gt;</span>				<span class="comment">// 负责对象内容的构造与析构</span></span></span><br></pre></td></tr></table></figure>



<h5 id="alloc对象构造和析构工具"><a href="#alloc对象构造和析构工具" class="headerlink" title="alloc对象构造和析构工具"></a><code>alloc</code>对象构造和析构工具</h5><p><code>alloc</code>中的构造和析构工具是使用<code>::placement new</code>和<code>::placement delete</code>，然后使用模板编程进行<code>type_traits</code>来对特定元素进行构造和析构。</p>
<h5 id="alloc内存配置和释放工具"><a href="#alloc内存配置和释放工具" class="headerlink" title="alloc内存配置和释放工具"></a><code>alloc</code>内存配置和释放工具</h5><p>这个才是有意思的地方：<code>alloc</code>没有像之前的<code>std::allocator</code>一样只是对<code>operator new</code>进行一层薄薄的封装，而是通过<strong>双层级配置器</strong>来提升效率。</p>
<ul>
<li>第一级配置器：<ul>
<li>使用情况：<strong>当配置区块大于128bytes时</strong>，使用它</li>
<li>使用方法：直接使用malloc和free</li>
</ul>
</li>
<li>第二级配置器：<ul>
<li>使用情况：当配置区块小于128bytes时，使用它</li>
<li>使用方法：使用复杂的<strong>内存池整理</strong>方式</li>
</ul>
</li>
</ul>
<p>第一级配置器无须赘言，直接看第二级配置器吧</p>
<ul>
<li><p>为什么要进行二级配置？</p>
<ul>
<li>为了避免出现太多小额区块造成内存的碎片。小额区块带来的不仅仅是内存碎片，还会带来额外的管理负担。</li>
<li>这样的话，对于小额区块的利用是有价值的。</li>
</ul>
</li>
<li><p>二级配置原理</p>
<ul>
<li><p><strong>使用内存池管理：每次配置一大块内存，并维护对应的自由链表。</strong></p>
</li>
<li><p>自由链表一般是8的倍数，因此一般配置16个自由链表，分别配置8~128bytes</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自由链表 free-lists的节点结果如下</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">obj</span> * <span class="title">free_list_link</span>;</span></span><br><span class="line">    <span class="keyword">char</span> client_data[<span class="number">1</span>];				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用union结构，obj指针不会造成内存浪费。</p>
</li>
<li><p>配置内存时与自由链表空间进行匹配，匹配成功则将该链表的内存空间配置出去，当回收内存时，这块内存区域又会回收到自由链表中。</p>
</li>
</ul>
</li>
<li><p>函数调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    obj * result;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="keyword">size_t</span> __MAX_NYTES)&#123;</span><br><span class="line">        <span class="keyword">return</span> (malloc_alloc::<span class="built_in">allocate</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找16个free lists中适当的一个</span></span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">    result = *my_free_list;</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果没有合适的自由链表，则重新填充free_list</span></span><br><span class="line">        <span class="keyword">void</span> *r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n));</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整free list</span></span><br><span class="line">    *my_free_list = result-&gt;free-&gt;list-&gt;link;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dellocate</span><span class="params">(<span class="keyword">void</span>* p,<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    obj * q = (obj *) p;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="keyword">size_t</span> __MAX_NYTES)&#123;</span><br><span class="line">        malloc_alloc::<span class="built_in">dellocate</span>(p,n);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找对应的free list</span></span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 调整free list，回收区块</span></span><br><span class="line">    q-&gt;free-&gt;list-&gt;link = *my_free_list;</span><br><span class="line">    *my_free_list = q;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果free_list中没有可以区块时，就调用refill()，准备为free_list重新填充空间。新的空间将取自内存池（经由<code>chunk_alloc()</code>完成）</p>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​    STL的空间配置并不难，但是提前了解的话，对于后面容器创建的行为都会很好地理解了。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>《STL源码剖析》——侯捷</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>allocator</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/posts/f1601c3e/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章来介绍线程安全的单例模式怎么写。不仅有传统意义的DLC单例和静态成员变量的单例，还有着C++11的pthread_once如何实现单例模式。</p>
</blockquote>
<span id="more"></span>

<h4 id="传统的单例模式："><a href="#传统的单例模式：" class="headerlink" title="传统的单例模式："></a>传统的单例模式：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 单例模式 1：  在该空间中针对该对象只能创建一个instance，因此该对象的构造函数必须delete。</span></span><br><span class="line"><span class="comment">			那么如何创建那个实例呢？直接用static关键词修饰这个实例，如果该实例已经被创建了，</span></span><br><span class="line"><span class="comment">			那这个实例就一直存在。</span></span><br><span class="line"><span class="comment">			但是多线程中，这个创建过程是安全的吗？</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> T&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(value_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			value_ = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value_;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> T* value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> T* value_ = <span class="literal">nullptr</span>; <span class="comment">// static对象初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="加上锁的单例模式："><a href="#加上锁的单例模式：" class="headerlink" title="加上锁的单例模式："></a>加上锁的单例模式：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 单例模式 2：  在上面的代码加上锁，那么就可以解决多线程下的condition race问题，</span></span><br><span class="line"><span class="comment">			但是每次访问它都要进行加锁，锁也是一种资源，这样会大量耗费资源。</span></span><br><span class="line"><span class="comment">			因此这样性能消耗很大，不提倡。</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> T&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">       	Lock lock;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span>(value_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			value_ = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value_;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> T* value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> T* value_ = <span class="literal">nullptr</span>; <span class="comment">// static对象初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="double-checked-locking的单例模式"><a href="#double-checked-locking的单例模式" class="headerlink" title="double checked locking的单例模式"></a>double checked locking的单例模式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 单例模式 3：  2的性能消耗大的原因是加锁，那么如何让其性能提升呢？</span></span><br><span class="line"><span class="comment">			再通过一次判断，如果满足的话，加锁，不然的话，就不加。	</span></span><br><span class="line"><span class="comment">			因此double checked locking 是为了减少竞争和加锁载荷。</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> T&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二次确认</span></span><br><span class="line">        <span class="keyword">if</span>(value_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// 获取锁</span></span><br><span class="line">            Lock lock;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(value_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                value_ = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> value_;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> T* value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> T* value_ = <span class="literal">nullptr</span>; <span class="comment">// static对象初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="静态局部变量实现单例（C-11"><a href="#静态局部变量实现单例（C-11" class="headerlink" title="静态局部变量实现单例（C++11)"></a>静态局部变量实现单例（C++11)</h4><p>​    上面的单例模式真的对嘛？由于编译器的指令重排，上面的单例模式或多或少都有点问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 单例模式 4：  new函数分为三步：</span></span><br><span class="line"><span class="comment">                    1：分配空间： 调用 operator new 来实现。（底层是用malloc）</span></span><br><span class="line"><span class="comment">                    2：在分配空间中构造对象：调用构造函数实现 placement new</span></span><br><span class="line"><span class="comment">                    2：使得实例value_指向分配的空间。</span></span><br><span class="line"><span class="comment">             由于编译器有指令优化，因此这三个步骤不是严格按照顺序执行的。</span></span><br><span class="line"><span class="comment">             所以可能出现线程A进入了临界区，执行了step1和step3，然后挂起。</span></span><br><span class="line"><span class="comment">             这个时候指针已经指向了一个分配空间，但是分配空间中没有构造对象。(即指针不为nullptr，但是内存里面还是空的)</span></span><br><span class="line"><span class="comment">             这个时候B进入临界区，发现value_ != nullptr,直接出错</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             总之就是指令重排会导致DLC方式的单例不好写。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             因此这里有个使用局部静态变量实现的单例模式——————Meyers Singleton</span></span><br><span class="line"><span class="comment">				局部静态变量智慧初始化一次，因此这个调用这个instance调用的永远是这个value</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> T&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> T value;	<span class="comment">// 局部静态变量</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="C-11的call-once实现单例模式"><a href="#C-11的call-once实现单例模式" class="headerlink" title="C++11的call_once实现单例模式"></a>C++11的call_once实现单例模式</h4><p>​    在多线程编程中，有时某个任务只需要执行一次，此时可以用C++11中的<code>std::call_once</code>函数配合<code>std::once_flag</code>来实现。如果多个线程需要同时调用某个函数，<code>std::call_once</code>可以保证多个线程对该函数只调用一次。也可用在解决线程安全的单例模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class Callable, class... Args &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_once</span><span class="params">(std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> std::once_flag s_flag;</span><br><span class="line">    std::<span class="built_in">call_once</span>(s_flag, [&amp;]() &#123;</span><br><span class="line">      instance_.<span class="built_in">reset</span>(<span class="keyword">new</span> Singleton);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *instance_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> std::unique_ptr&lt;Singleton&gt; instance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;Singleton&gt; Singleton::instance_;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>STL介绍</title>
    <url>/posts/171e944c/</url>
    <content><![CDATA[<blockquote>
<p>STL向来是C++中的一个重要组成部分。STL是一个包罗算法与数据结构的软件框架，本篇文章用于为STL做一个简要介绍，至于具体的内容看STL分类的后续文章。</p>
</blockquote>
<h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>STL有六大组件，彼此可以组合套用：</p>
<ul>
<li><p>容器：各种数据结构</p>
<ul>
<li>顺序容器： vector, list, deque</li>
<li>关联容器： set, map</li>
</ul>
</li>
<li><p>算法：各种模板算法（template function: 在各种容器都有适配性）</p>
<ul>
<li><code>#include &lt;algorithm&gt;</code>: sort, search, copy, erase等</li>
</ul>
</li>
<li><p>迭代器：本质是<strong>泛型指针</strong>，算法与容器之间的胶合剂。</p>
<ul>
<li>共有五种类型：（之后待补充）</li>
<li>实际上是将一些operator进行重载的class template</li>
<li>所有STL容器都有自己专属的迭代器。</li>
<li>原生指针也是一种迭代器</li>
</ul>
</li>
<li><p>仿函数：行为类似函数，可作为算法的某种策略</p>
<ul>
<li>可以被视为一种重载了operator()的class 或 class template</li>
<li>一般的函数指针为狭义的仿函数</li>
</ul>
</li>
<li><p>配接器：一种用来修饰容器或仿函数或迭代器接口的东西。比如stack和queue，因为它们的底层是由deque实现的，所有操作也都是deque操作。</p>
<ul>
<li>改变functor接口者，称为function adapter</li>
<li>改变container接口者，称为container adapter</li>
<li>改变iterator接口者，称为iterator adapter</li>
</ul>
</li>
<li><p>配置器：负责空间配置与管理</p>
<ul>
<li>从实现角度来看，配置器是实现了动态空间配置、空间管理、空间释放的class template</li>
</ul>
</li>
</ul>
<p>六大主件之间的关系：</p>
<p>​    Container通过Allocator取得数据储存空间，Algorithm通过Iterator存取Container内容，Functor可以协助Algorithm完成不同策略变化，Adapter可以修饰或套接Functor。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>编译内存相关</title>
    <url>/posts/3e94d9ed/</url>
    <content><![CDATA[<blockquote>
<p>C/C++文件如何从一个源文件{.c/.cpp}变成一个可执行文件？在这过程中，其内存管理又是怎么样的？</p>
<p>本篇文章就来讲一讲这些内容。</p>
</blockquote>
<span id="more"></span>



<h3 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h3><p>程序编译分为四个过程： 预处理，编译（编译，优化）， 汇编， 链接。</p>
<ul>
<li><p>预处理：处理以#开头的指令，如果是头文件则将头文件插入到源文件中，如果是宏，则将宏展开，删除注释。（不过#pragma指令会保留，因为编译器要用到它）</p>
</li>
<li><p>编译、优化： 将源文件(.cpp)翻译为汇编代码(.s)。</p>
</li>
<li><p>汇编：将汇编代码翻译成机器指令文件(.o)。</p>
</li>
<li><p>链接：汇编程序生成的目标文件，不会立即执行。因为可能会出现.cpp文件函数引用了另一个.cpp文件中定义的符号或者调用某个库文件中的函数，这样的话需要将这些文件链接成一个整体，生成(.exe)可执行文件。</p>
</li>
</ul>
<img src="/posts/3e94d9ed/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" class title="编译过程">

<img src="/posts/3e94d9ed/%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B.png" class title="链接过程">



<h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h3><p>C++内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。</p>
<ul>
<li>栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。</li>
<li>堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</li>
<li>全局区/静态存储区（.bss 段和 .data 段）：<strong>存放全局变量和静态变量</strong>，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</li>
<li>常量存储区（.data 段）：<strong>存放的是常量，不允许修改</strong>，程序运行结束自动释放。</li>
<li>代码区（.text 段）：<strong>存放代码，不允许修改，但可以执行</strong>。编译后的二进制文件存放在这里。</li>
</ul>
<img src="/posts/3e94d9ed/%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5.png" class title="内存分段">

<p>从图中可以看出，32bitCPU可寻址<strong>4G线性空间</strong>，每个进程都有各自对的4G逻辑地址，其中0<del>3G是用户态，3</del>4G是内核态空间。</p>
<p>各个段说明如下：</p>
<p>3G用户空间和1G内核空间</p>
<ul>
<li><p>静态区域：</p>
<ul>
<li>text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</li>
<li>data segment(数据段)：存储程序中已初始化的全局变量和静态变量</li>
<li>bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0</li>
</ul>
</li>
<li><p>动态区域：</p>
<ul>
<li>heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。</li>
<li>memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）</li>
<li>stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。</li>
</ul>
<p>栈地址是由高到低扩展的，堆地址是由低到高扩展的。</p>
</li>
</ul>
<h3 id="编译器做了什么"><a href="#编译器做了什么" class="headerlink" title="编译器做了什么"></a>编译器做了什么</h3><p>从最直观的角度来讲，编译器就是将<strong>高级语言翻译成机器语言</strong>的一个工具。</p>
<p>编译过程一般分为6步： 扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化。</p>
<img src="/posts/3e94d9ed/%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.jpg" class title="编译流程">

<p>实际上就是三步：分析代码，优化代码，生成代码。</p>
<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>​    首先将源代码程序输入到扫描器（Scanner），然后在其中进行词法分析。词法分析是简单借助有限状态机将源代码的字符序列分割成一系列的记<strong>号</strong>，然后逐个去判断是否有<strong>词法错误</strong>。</p>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>​    进行词法分析之后，接下来语法分析器会对之前产生的记号进行语法分析，从而产生<strong>语法树</strong>。整个分析过程采用了上下文无关语法。在语法分析的同时，<strong>运算符的优先级和含义</strong>被确定了下来（如*是乘法还是对指针取内容的表达式）。如果出现了表达式不合法现象，编译器会报告语法分析阶段的错误。</p>
<p>​    语法分析仅仅是完成了对表达式的语法层面的分析。</p>
<h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>​    接下来，语义分析器来分析语句的真正含义，是否有意义。语义分为两种，静态语义和动态语义。编译阶段只能分析其<strong>静态语义</strong>，动态语义只能在运行期才能确定。</p>
<p>​    静态语义通常包括<strong>声明和类型的匹配，类型的转换</strong>。（其实就是分析和类型相关的合法性，比如将一个浮点数赋值给一个指针，如果类型不匹配会报错）。语义的分析是语法树上进行的，在语法分析阶段，语法树上只有运算符的优先级和含义，在语义分析阶段中，<strong>语法树上的表达式都被表示了类型</strong>。</p>
<h4 id="源代码优化"><a href="#源代码优化" class="headerlink" title="源代码优化"></a>源代码优化</h4><p>​    进行了以上三个分析之后，源代码会进行响应的优化。 现代的编译器有着很多层次的优化，源代码级优化是必不可少的。</p>
<p>举个例子：(2+6)在这一步就被优化成了8.（<strong>其它与临时变量相关的代码都是在这一步优化的</strong>）</p>
<p>在语法树上直接优化比较困难，因此<strong>源代码优化器一般将整个语法树转换成中间代码</strong>（中间代码即为语法树的顺序表示）。转换的中间代码是机器无关的，优化之后将中间代码转换成目标机器代码，这样就能够在相应的机器上运行。</p>
<h4 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h4><p>​    在编译器中生成的目标代码是汇编代码，汇编代码是非常依赖机器的，因此中间代码转换成目标机器代码是有必要的。</p>
<p>​    最后，在汇编阶段对代码进行优化：</p>
<ul>
<li><p>为什么要在汇编阶段再次优化呢？源代码阶段不是已经优化过了么？</p>
<ul>
<li><p>汇编代码优化是<strong>为了选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。</strong></p>
</li>
<li><p>举个例子：乘法是由一条相对复杂的基址变址寻址的lea完成的。</p>
</li>
</ul>
</li>
</ul>
<p>至此，一个完整的编译过程就这样结束了。不过，在该过程中，编译器似乎没有考虑到内存地址，假如有个变量**<code>int index = 0;</code>定义在和源代码同一单元内，那么编译器直接可以为<code>index</code>分配空间并确定地址<strong>，那如果</strong><code>index</code>定义在其他模块呢**？这该怎么办？</p>
<p>这样，就引入了下一个话题——链接。所以再次总结一下：</p>
<p><strong>现代编译器可以将一个源文件变异成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。</strong></p>
<h3 id="链接器做了什么"><a href="#链接器做了什么" class="headerlink" title="链接器做了什么"></a>链接器做了什么</h3><p>链接器是将编译器或汇编器生成的若干个目标模块，整合成一个被称为载入模块或可执行文件的实体。</p>
<h4 id="链接分类"><a href="#链接分类" class="headerlink" title="链接分类"></a>链接分类</h4><p>链接分为两种：</p>
<ul>
<li>静态链接：代码从其所在的静态链接库中<strong>拷贝</strong>到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li>
<li>动态链接：代码被放到动态链接库或共享对象的某个目标文件中，<strong>链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息</strong>。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li>
</ul>
<p>二者优缺点对比：</p>
<ul>
<li><p>静态链接：将程序调用的库一起打包到可执行文件中，这样执行时就不需要调用别的库了，<strong>速度快</strong>，但是<strong>链接的时候可能同一个库链接了好几次，导致空间浪费，而且如果该库更新了的话，整个程序需要重新编译</strong>（更新困难）；</p>
<img src="/posts/3e94d9ed/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5.png" class title="静态链接"></li>
<li><p>动态链接：在程序执行时才载入引用的库，因此<strong>方便更新</strong>。而且只需要一次拷贝，<strong>节省内存</strong>。但是每次执行都需要链接，相比静态链接会有一定的性能损失。</p>
<img src="/posts/3e94d9ed/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png" class title="动态链接"></li>
</ul>
<p>明确了链接的分类之后，想必都明白在编译过程中的链接一般都指的是静态链接。</p>
<p>下面我们介绍链接器做了什么。</p>
<h4 id="静态链接器的工作"><a href="#静态链接器的工作" class="headerlink" title="静态链接器的工作"></a>静态链接器的工作</h4><p>​    链接器如何将输入文件中的各个段合并到输出文件？如果只是单纯的按照目标文件次序叠加，那这样在目标文件中会有很多零散的段，这样会造成内存空间大量的内部碎片，所以这并不是一个很好的方案。</p>
<ul>
<li><p>相似段合并：该方法顾名思义，将输入文件中相似的段合并成到统一的区域中，这样的话目标文件中就依然还是正常的内存分区，不过，如何将输入文件正确映射到输出文件相应的段？ 在这里采用<strong>两步链接</strong>的方法。</p>
</li>
<li><p>两步链接：</p>
<ul>
<li>第一步，空间与地址分配：扫描所有的输入目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个<strong>全局符号表</strong>。在这一步，链接器能够获得所有输入文件段的长度，并将其合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。</li>
<li>第二步，符号解析与重定位：利用第一步收集到的所有信息，读取输入文件段的数据，重定位信息，惊醒符号分析和重定位，调整代码中的地址等。事实上第二步才是链接过程的核心。</li>
</ul>
</li>
</ul>
<h4 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h4><p>​    空间与地址分配该步骤做了以下两件事：（当然，这种地址空间都是虚拟地址）</p>
<ul>
<li><p>根据输入文件的段长、属性等给输<strong>出文件分配一个内存地址空间</strong>，而且还在内存地址空间中划分了各个段的地址。</p>
</li>
<li><p>生成一个<strong>全局符号表</strong>，全局符号表中有着输入文件中符号表中华所有的符号定义和符号引用。为第二步的符号解析和重定位做准备。</p>
<p>（符号——函数和变量的统称）</p>
</li>
</ul>
<h4 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h4><ol>
<li><p><strong>为什么需要重定位？</strong></p>
<p>在重定位之前，输入文件的取址地址都在其原来的文件中，现在那些文件合成一个输出文件，其符号的地址可能会发生变化（尤其是绝对地址，一般都会改变），如何此时还是按照原来的地址进行寻址，会找不到符号的定义，从而产生链接的错误。因此需要进行重定位。</p>
<p>在生成全局符号表之后，链接器已经确认了所有符号的虚拟地址了，那么此时链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。</p>
</li>
<li><p><strong>如何知道什么指令需要重定位？</strong></p>
<p>在ELF目标文件中，有一个重定位表，记录这与重定位相关的信息，用来描述如何修改相应的段里的内容。因此每个<strong>要被重定位的ELF段都有一个重定位表</strong>。</p>
<p>举个例子：如果该文件的代码段<code>.text</code>需要重定位，那么ELF会生成一个重定位表，放在<code>.rel.text</code>中，如果是<code>.data</code>,那也会有<code>.rel.data</code>出现。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -r a.o   						<span class="comment"># 假设有个a.o的目标文件</span></span></span><br><span class="line">a.o: 	file formate elf32-i386</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]			# .text段需要重定位</span><br><span class="line">OFFSET		TYPE			VALUE		# 这表明有两个重定位入口，以下两行展示了其偏移地址，类型和符号名称的信息</span><br><span class="line">0000001c	R_386_32	 	shared</span><br><span class="line">00000027	R_386_PC32		swap	</span><br></pre></td></tr></table></figure></li>
<li><p>重定位地址</p>
<ul>
<li>重定位入口：每个要被重定位的地方，在上面的代码中两行代表两个入口。</li>
<li>偏移： 重定位入口在该段的偏移地址，即该段中需要被调整的位置。</li>
</ul>
</li>
<li><p><strong>符号解析</strong></p>
<p>还是按照上面那个例子，如果直接汇编执行<code>a.o</code>的话，会出现<code>shared</code>和<code>swap</code>两个符号没有被定义，从而链接错误。</p>
<p>通过在重定位中对符号进行解析，对需要重定位的符号查询全局符号表，找到相应的符号和符号地址进行重定位。</p>
</li>
</ol>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><ul>
<li><p>申请方式：栈是系统自动分配，堆是程序员主动申请。</p>
</li>
<li><p>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，<strong>堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除</strong>，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</p>
</li>
<li><p>栈在内存中是<strong>连续</strong>的一块空间（向低地址扩展）<strong>最大容量是系统预定好的</strong>，<strong>堆在内存中的空间（向高地址扩展）是不连续的</strong>。</p>
</li>
<li><p>申请效率：栈是有<strong>系统自动分配，申请效率高，但程序员无法控制</strong>；堆是由<strong>程序员主动申请，效率低，使用起来方便但是容易产生碎片</strong>。</p>
</li>
<li><p>存放的内容：<strong>栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制</strong>。</p>
</li>
</ul>
<h4 id="对象创建限制在堆或栈上"><a href="#对象创建限制在堆或栈上" class="headerlink" title="对象创建限制在堆或栈上"></a>对象创建限制在堆或栈上</h4><p>说明：C++ 中的类的对象的建立分为两种：静态建立、动态建立。</p>
<ul>
<li>静态建立：<strong>由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象</strong>。例如：A a;</li>
<li>动态建立：<strong>使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配</strong>；然后，调用类的构造函数创建对象。</li>
</ul>
<p>限制对象在堆上：</p>
<ul>
<li>将构造函数和析构函数设置为<code>protected</code>（对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。）</li>
<li>使用一个静态函数完成构造，（因为该对象还没有被创建，所以想使用类内的方法必须得是<code>static</code>函数，这点和单例模式一样）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> A *<span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>限制对象在栈上：</p>
<ul>
<li>直接将<code>operator new</code> 和 <code>operator delete</code>给<code>=delete</code>标识。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span> </span>= <span class="keyword">delete</span>;  	<span class="comment">// 注意函数的第一个参数和返回值都是固定的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>= <span class="keyword">delete</span>; 	<span class="comment">// 重载了 new 就需要重载 delete</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="malloc的底层实现"><a href="#malloc的底层实现" class="headerlink" title="malloc的底层实现"></a>malloc的底层实现</h4><p>先简单说一说，malloc底层是使用了brk和mmap系统调用。</p>
<p>brk系统调用是通过进程向内核申请一个小数据堆，使得进程地址空间内堆空间扩展，然后再通过mmap系统调用创建一个新的线性地址区间。</p>
<p>malloc是在堆上进行内存分配的函数。进程可以通过<strong>增加堆的大小来分配内存，堆是一段长度可变的连续虚拟内存，始于进程的未初始化数据段末尾，随着内存的分配和释放而增减（见下图)。通常将堆的当前内存边界称为“program break”。</strong></p>
<ul>
<li><p>brk：</p>
<p>改变堆的大小（即分配或释放内存），其实就是命令内核改变进程的program break位置。最初，program break正好位于未初始化数据段末尾之后（如下图所示，与&amp;end位置相同）。</p>
<p>在program break的位置抬升后，<strong>程序可以访问新分配区域内的任何内存地址，而此时物理内存页尚未分配。内核会在进程首次试图访问这些虚拟内存地址时自动分配新的物理内存页。</strong></p>
<p>（实际上就是将堆的头指针往高地址延伸，从而能够获得新的虚拟地址）</p>
<img src="/posts/3e94d9ed/brk.jpg" class title="brk"></li>
<li><p>mmap： 创建一个新的线性地址区间，如果两个地址区间访问权限相同，那么会合并为一个区间。</p>
</li>
</ul>
<p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p>《C陷阱与缺陷》</p>
</li>
<li><p>《程序员的自我修养——链接、装载与库》</p>
</li>
<li><p>《Linux内核设计与实现》</p>
</li>
<li><p><a href="https://www.zhihu.com/question/21098367">知乎回答：brk和sbrk所指的program break到底是什么？</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/posts/16518a5d/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章来介绍一种在栈的应用——单调栈，单调栈本质还是栈，只不过是在每次新元素入栈后，栈内的元素都保持单调（单调递增或者递减）。</p>
<p>单调栈的用途并不广泛，只是用来处理一种情况——Next Greater Element，不过在处理这种典型问题上还是很有效率的，因此特来记录一下。</p>
</blockquote>
<span id="more"></span>



<h3 id="解题模板"><a href="#解题模板" class="headerlink" title="解题模板"></a>解题模板</h3><p>单调栈，就是栈内元素都是单调呈现的，如果新加入的节点不符合单调性的话，则将栈内的节点弹出，直到最后形成单调区间。</p>
<h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4><p>首先来看下这道题目。这类题目是使用单调栈的最常使用情况——下一个更大/小问题。</p>
<p>我们可以将数组抽象成正在排队的人，下一个更大的元素就是往后看看到的比自己高的第一个人。</p>
<p>这样的话可以通过题目，写出代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(num.size())</span></span>;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt;= nums[i])&#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是单调队列解决问题的模板。由于是找下一个最大的，然后用的又是栈，因此for循环要从后往前扫描元素，倒着入栈，正着出栈。</p>
<h4 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h4><p>这个题目是延伸：处理循环数组——倍增数组。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LFU</title>
    <url>/posts/3be3e04e/</url>
    <content><![CDATA[<blockquote>
<p>LFU全程Least Frequently Used, 每次淘汰那些使用次数最少的数据。LFU相较于LRU，实现较难，考虑因素也更多。不过这些经典算法套路都是固定的，关键在于逻辑较复杂，不太容易一次就能写出漂亮且没有bug的代码。</p>
</blockquote>
<span id="more"></span>

<h4 id><a href="#" class="headerlink" title></a></h4><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>首先写出一个类，接受<code>capacity</code>参数，实现<code>get()</code>和<code>put()</code>方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="keyword">int</span> capacity):<span class="built_in">cap_</span>(capacity) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个接口和LRU一致，get方法会去缓存中查询键key，如果key存在，则返回key对应的val,否则返回-1；put方法则插入或修改缓存。如果key已存在，则将它对应的值改为val，如果不存在，则插入键值对(key, val)。</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>LFU的一些逻辑要求</p>
<ul>
<li><p>LFU加入了一个<code>freq</code>频率参数，缓存中的数据是靠freq进行排序的。</p>
</li>
<li><p>如果是调用get和put，该key的freq就要加1。</p>
</li>
<li><p>如果容量满了进行插入，则需要将freq最小的key删除，如果最小的freq对应多个key，则删除其中最旧的那个。</p>
</li>
</ul>
<p>要想在O(1)时间内解决这些问题，需要逐个击破：</p>
<ul>
<li><p>关于最基本的get和put，那么需要和LRU一样拥有一个<code>HashMap</code>存储<code>key</code>到<code>value</code>的映射，这样就可以快速操作<code>get(key)</code></p>
</li>
<li><p>加入freq，而且缓存中数据靠freq排序，这就说明一定要有个 <strong><code>freq</code>到<code>key</code>的映射</strong></p>
</li>
<li><p>要想在容量满的时候快速删除freq最小的key，这需要使用一个变量来指明最小freq，使用变量<code>minFreq</code></p>
</li>
<li><p>如果最小的freq对应多个key，而且要删除最旧的，我们可以用<strong>双向链表</strong>结构来存放一个freq对应的多个key</p>
</li>
<li><p>如果最小的freq只对应一个key，删除完之后需要minFreq++</p>
</li>
</ul>
<p>总结一下：我们可以用Node节点来存储{key, value, freq},这样 LFU所用到的数据结构有一个以key为索引的哈希映射和一个以freq为索引的哈希链表。</p>
<h3 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><p>这样接口如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">int</span> freq;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> value, <span class="keyword">int</span> freq) : <span class="built_in">key</span>(key), <span class="built_in">value</span>(value), <span class="built_in">freq</span>(freq) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LFUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">cap_</span>(capacity), <span class="built_in">minFreq_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		keyToNode.<span class="built_in">clear</span>();</span><br><span class="line">		freqToNode.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cap_ == <span class="number">0</span>) <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = keyToNode.<span class="built_in">find</span>(key);</span><br><span class="line">		<span class="keyword">if</span> (it == keyToNode.<span class="built_in">end</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">increaseFreq</span>(key);</span><br><span class="line">		<span class="keyword">return</span> keyToNode[key]-&gt;value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(keyToNode.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">			keyToNode[key]-&gt;value = value;</span><br><span class="line">			<span class="built_in">increaseFreq</span>(key);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(keyToNode.<span class="built_in">size</span>() == cap_) &#123;</span><br><span class="line">				<span class="comment">// 容量已经满了,删除频率最小时序最差的node</span></span><br><span class="line">				<span class="built_in">deleteMinFreq</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 插入新值</span></span><br><span class="line">			freqToNode[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">			keyToNode[key] = freqToNode[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">            minFreq_ = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteMinFreq</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> cap_;</span><br><span class="line">	<span class="keyword">int</span> minFreq_;</span><br><span class="line">	<span class="comment">// 由于key和node是一对一的关系，因此是 unordered_map&lt;int, list&lt;Node&gt;::iterator&gt;</span></span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;::iterator&gt; keyToNode;</span><br><span class="line">	<span class="comment">// 由于freq和node是一对多的关系，因此是 unordered_map&lt;int, list&lt;Node&gt;&gt;</span></span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;&gt; freqToNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>上面的接口基本上把流程全部写出来了。</p>
<p>数据结构</p>
<ul>
<li>Node：存储{key，value，freq}。一个Node相当于是一个信息的最小单元，每个信息都拥有这三个信息。（该数据结构和LRU中的pair&lt;int,int&gt;对应）</li>
<li>keyToNode：以key为索引的哈希映射，由于每个key对应一条信息，因此只需要存储一个Node节点就行。这里还是和LRU一样，借助了iterator的优势，其映射值存储的只是一个迭代器，而无需将整个Node存储进该映射 ，因此其数据结构为<code>unordered_map&lt;int, list&lt;Node&gt;::iterator&gt;</code></li>
<li>freqToNode: 以freq为索引的哈希映射，由于每个freq会对应多个节点，而且是删除最低频率的最旧节点，因此和LRU一样依旧带有时序性，这样的话依旧使用一个双向链表来该哈希映射的值部分，因此其数据结构为<code>unordered_map&lt;int, list&lt;Node&gt;&gt;</code></li>
</ul>
<p>方法流程</p>
<ul>
<li><p><code>get()</code>：该方法依旧和LRU一样，如果链表中没有该<code>key</code>,则返回-1。如果有，<strong>将其频率提升，</strong>返回其value</p>
</li>
<li><p><code>put()</code>：该方法的主要思想也依旧和LRU相似，如下图所示</p>
<p><img src="/posts/3be3e04e/put%E6%B5%81%E7%A8%8B.jpg" class title="put()大致逻辑 }&lt;&#x2F;p&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;h3 id&#x3D;代码细节&gt;&lt;a href&#x3D;#代码细节 class&#x3D;headerlink title&#x3D;代码细节&gt;&lt;&#x2F;a&gt;代码细节&lt;&#x2F;h3&gt;&lt;p&gt;get和put方法调用了两个函数方法，一个是&lt;code&gt;increaseFreq(int key)&lt;&#x2F;code&gt; ，一个是&lt;code&gt;deleteMinFreq();&lt;&#x2F;code&gt;&lt;&#x2F;p&gt; &lt;p&gt;下面来实现他们的细节&lt;&#x2F;p&gt; <figure class=" highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 首先处理freqToNode</span></span><br><span class="line">		<span class="keyword">auto</span> node = keyToNode[key];</span><br><span class="line">		<span class="keyword">int</span> freq = node-&gt;freq;</span><br><span class="line">		<span class="keyword">int</span> val = node-&gt;value;</span><br><span class="line">		freqToNode[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">		<span class="comment">// 如果freq是一对一，则整个freq都要删掉</span></span><br><span class="line">		<span class="keyword">if</span>(freqToNode[freq].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			freqToNode.<span class="built_in">erase</span>(freq);</span><br><span class="line">			<span class="keyword">if</span> (minFreq_ == freq)</span><br><span class="line">				minFreq_++;</span><br><span class="line">		&#125;</span><br><span class="line">		freqToNode[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, val, freq + <span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 然后再处理keyToNode</span></span><br><span class="line">		keyToNode[key] = freqToNode[freq+<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteMinFreq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 删除MinFreq最旧的Node</span></span><br><span class="line">		<span class="keyword">auto</span> node = freqToNode[minFreq_].<span class="built_in">back</span>();</span><br><span class="line">		keyToNode.<span class="built_in">erase</span>(node.key);</span><br><span class="line">		freqToNode[minFreq_].<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">if</span>(freqToNode[minFreq_].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			freqToNode.<span class="built_in">erase</span>(minFreq_);</span><br><span class="line">			minFreq_++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table> &lt;p&gt;至此，一个完整的LFU实现了&lt;&#x2F;p&gt; <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">int</span> freq;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> value, <span class="keyword">int</span> freq) : <span class="built_in">key</span>(key), <span class="built_in">value</span>(value), <span class="built_in">freq</span>(freq) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LFUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">cap_</span>(capacity), <span class="built_in">minFreq_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		keyToNode.<span class="built_in">clear</span>();</span><br><span class="line">		freqToNode.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cap_ == <span class="number">0</span>) <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = keyToNode.<span class="built_in">find</span>(key);</span><br><span class="line">		<span class="keyword">if</span> (it == keyToNode.<span class="built_in">end</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">increaseFreq</span>(key);</span><br><span class="line">		<span class="keyword">return</span> keyToNode[key]-&gt;value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(keyToNode.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">			keyToNode[key]-&gt;value = value;</span><br><span class="line">			<span class="built_in">increaseFreq</span>(key);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(keyToNode.<span class="built_in">size</span>() == cap_) &#123;</span><br><span class="line">				<span class="comment">// 容量已经满了,删除频率最小时序最差的node</span></span><br><span class="line">				<span class="built_in">deleteMinFreq</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 插入新值</span></span><br><span class="line">			freqToNode[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">			keyToNode[key] = freqToNode[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">			<span class="comment">// 设置最小频率</span></span><br><span class="line">			minFreq_ = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 首先处理freqToNode</span></span><br><span class="line">		<span class="keyword">auto</span> node = keyToNode[key];</span><br><span class="line">		<span class="keyword">int</span> freq = node-&gt;freq;</span><br><span class="line">		<span class="keyword">int</span> val = node-&gt;value;</span><br><span class="line">		freqToNode[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">		<span class="comment">// 如果freq是一对一，则整个freq都要删掉</span></span><br><span class="line">		<span class="keyword">if</span>(freqToNode[freq].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			freqToNode.<span class="built_in">erase</span>(freq);</span><br><span class="line">			<span class="keyword">if</span> (minFreq_ == freq)</span><br><span class="line">				minFreq_++;</span><br><span class="line">		&#125;</span><br><span class="line">		freqToNode[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, val, freq + <span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 然后再处理keyToNode</span></span><br><span class="line">		keyToNode[key] = freqToNode[freq+<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteMinFreq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 删除MinFreq最旧的Node</span></span><br><span class="line">		<span class="keyword">auto</span> node = freqToNode[minFreq_].<span class="built_in">back</span>();</span><br><span class="line">		keyToNode.<span class="built_in">erase</span>(node.key);</span><br><span class="line">		freqToNode[minFreq_].<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">if</span>(freqToNode[minFreq_].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			freqToNode.<span class="built_in">erase</span>(minFreq_);</span><br><span class="line">			minFreq_++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> cap_;</span><br><span class="line">	<span class="keyword">int</span> minFreq_;</span><br><span class="line">	<span class="comment">// 由于key和node是一对一的关系，因此是 unordered_map&lt;int, list&lt;Node&gt;::iterator&gt;</span></span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;::iterator&gt; keyToNode;</span><br><span class="line">	<span class="comment">// 由于freq和node是一对多的关系，因此是 unordered_map&lt;int, list&lt;Node&gt;&gt;</span></span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;&gt; freqToNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> &lt;h3 id&#x3D;与LRU比较&gt;&lt;a href&#x3D;#与LRU比较 class&#x3D;headerlink title&#x3D;与LRU比较&gt;&lt;&#x2F;a&gt;与LRU比较&lt;&#x2F;h3&gt;&lt;ul&gt; &lt;li&gt;&lt;p&gt;概念上，LFU比LRU增加了一个频率的概念，相对复杂了不少。&lt;&#x2F;p&gt; &lt;&#x2F;li&gt; &lt;li&gt;&lt;p&gt;数据结构上：&lt;&#x2F;p&gt; &lt;ul&gt; &lt;li&gt;LRU：由于LRU只需要考虑时序性和O(1)的get和put，因此其使用的数据结构就是一个双向链表&lt;code&gt;list&lt;pair(int,int)&gt;&lt;&#x2F;code&gt;（&lt;code&gt;pair&lt;int,int&gt;&lt;&#x2F;code&gt;作为一个node）和一个{key: node}的哈希映射，node的话可以使用迭代器进行优化成&lt;code&gt;unordered_map&lt;int, list&lt;pair(int,int)&gt;::iterator&gt;&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt; &lt;li&gt;LFU：&lt;ul&gt; &lt;li&gt;首先LFU增加了一个频率&lt;code&gt;freq&lt;&#x2F;code&gt;变量，因此不使用pair&lt;int,int&gt;存储{key，value}；而是使用Node(key, value, freq)存储节点信息。&lt;&#x2F;li&gt; &lt;li&gt;关于主要的哈希映射{key：node}，由于都是一对一的映射，因此和LRU一样使用&lt;code&gt;unordered_map&lt;int, list&lt;Node&gt;::iterator&gt;&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt; &lt;li&gt;LFU的特点是&lt;strong&gt;增加了一个以频率为索引的哈希映射&lt;&#x2F;strong&gt;，由于频率映射可能有一对多的情况，就不能是{freq : node}了，而必须使用{freq : list&lt;Node&gt;}，因此LFU新增了一个哈希映射&lt;code&gt;unordered_map&lt;int, list&lt;Node&gt;&gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;li&gt;&lt;p&gt;接口实现上：&lt;&#x2F;p&gt; &lt;p&gt;两个接口的流程和逻辑基本相同，不过LFU中&lt;strong&gt;调用函数接口相应freq也会增加&lt;&#x2F;strong&gt;，相应所需的功能封装在&lt;code&gt;void increaseFreq(int key)&lt;&#x2F;code&gt;中。&lt;&#x2F;p&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;h3 id&#x3D;参考资料&gt;&lt;a href&#x3D;#参考资料 class&#x3D;headerlink title&#x3D;参考资料&gt;&lt;&#x2F;a&gt;参考资料&lt;&#x2F;h3&gt;&lt;p&gt;《labuladong的算法小抄》&lt;&#x2F;p&gt;"></p></li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LFU</tag>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/posts/28239a8d/</url>
    <content><![CDATA[<h4 id="对OOP的理解"><a href="#对OOP的理解" class="headerlink" title="对OOP的理解"></a>对OOP的理解</h4><p>​    面向对象是一种将数据封装成类，针对类进行操作的方法。其核心思想是数据抽象、继承和动态绑定。（这也是oop的三大特性）</p>
<ul>
<li>封装：通过数据抽象，可以将类的接口与实现分离，同时对外界隐蔽类内的实现细节，只提供接口；</li>
<li>继承：可以定义相似的类型并对其相似关系进行建模，将相似类联系在一起构成一种层次关系，层次关系根部叫做基类，其他继承该类的叫做派生类；</li>
<li>多态：使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一方式使用它们的对象。</li>
</ul>
<h4 id="explict-显示-关键字"><a href="#explict-显示-关键字" class="headerlink" title="explict(显示)关键字"></a>explict(显示)关键字</h4><ul>
<li>explicit 修饰构造函数时，可以<strong>防止隐式转换和复制初始化</strong>（一般来说是用来</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">按语境转换</a> 除外</li>
</ul>
<h4 id="重载、重写、隐藏的区别"><a href="#重载、重写、隐藏的区别" class="headerlink" title="重载、重写、隐藏的区别"></a>重载、重写、隐藏的区别</h4><ul>
<li><p>重载：是指同一访问去内被声明几个具有不同参数（有const和无const也算）的同名函数，根据参数列表来调用哪个函数，<strong>重载不关心函数返回类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span>)</span></span>;			<span class="comment">// 重载</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">A</span><span class="params">()</span> <span class="keyword">const</span>	<span class="comment">// 重载</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>;			<span class="comment">// 不是重载，因为重载不在意返回类型，这个函数声明会报错</span></span><br></pre></td></tr></table></figure>

<p>重载其实在编译器是有差别的，在编译器每个重载函数的函数名是独一无二的，根据参数能定位到具体的函数。<strong>函数签名包含了一个函数的信息</strong>，包括函数名、它的类型参数，它所在的类和名称空间及其他信息。</p>
</li>
<li><p>隐藏：是指<strong>派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏</strong>。（只要是同名函数，就会被隐藏）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp, <span class="keyword">float</span> tmp1)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp, float tmp1)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun(int tmp)&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 隐藏基类中的同名函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive ex;</span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>);       <span class="comment">// Derive::fun(int tmp)</span></span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>, <span class="number">0.01</span>); <span class="comment">// error: candidate expects 1 argument, 2 provided 基类函数被隐藏了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>重写（override）：是指<strong>派生类中存在重新定义的函数</strong>。<strong>函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。</strong>派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。（重写是动态多态）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125; <span class="comment">// 重写基类中的 fun 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    p-&gt;<span class="built_in">fun</span>(<span class="number">3</span>); <span class="comment">// Derived::fun(int) : 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>重写和重载的区别：</p>
<p>范围区别：对于类中函数的重载或者重写而言，<strong>重载发生在同一个类的内部，重写发生在不同的类之间</strong>（子类和父类之间）。<br>参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。<br>virtual 关键字：<strong>重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。</strong></p>
</li>
<li><p>隐藏和重写，重载的区别：</p>
<p>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。<br>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。</p>
</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态：多态其实是不同继承类的对象，对同一消息做出不同的响应。多态分为静态多态和动态多态。</p>
<ul>
<li>静态多态：是指在编译期发生的多态。编译期的多态有两种实现方法，一种上面的重载，对象调用相同的函数名执行的不同的函数体。这个不赘述；另外一种是通过泛型编程，不同类型的对象参数能够使用同一个泛型模板。</li>
<li>动态多态：是指在运行期发生的多态。运行期多态是我们日常生活中说的多态，指的是基类的函数通过<code>virtual</code>关键字修饰后，在派生类重写该函数，运行时会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，那就调用派生类的函数，否则就调用基类的函数。</li>
</ul>
<p>实现方法： 多态是通过虚函数实现的，虚函数的地址保存在<strong>虚函数表中</strong>，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p>
<p>实现过程：</p>
<ul>
<li>在类中用 virtual 关键字声明的函数叫做虚函数；</li>
<li>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，<strong>该对象</strong>有一个指向虚函数表的<strong>虚表指针</strong>（<strong>虚函数表和类对应的，虚表指针是和对象对应</strong>）；</li>
<li>当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">	p-&gt;<span class="built_in">fun</span>(); <span class="comment">// Derive::fun() 调用派生类中的虚函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基类的虚函数表如下</p>
<img src="/posts/28239a8d/%E8%99%9A%E5%87%BD%E6%95%B01.png" class title="基类虚函数表">

<p>派生类的虚函数表如下</p>
<img src="/posts/28239a8d/%E8%99%9A%E5%87%BD%E6%95%B02.png" class title="派生类虚函数表">

<p>简单解释：当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数 Derive::f() 进行调用。</p>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>​    上个回答我们已经知道了什么是虚函数，那么什么是纯虚函数呢？</p>
<p>纯虚函数：</p>
<ul>
<li><p>纯虚函数在类中声明时，加上 =0；</p>
</li>
<li><p><strong>含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法</strong>；</p>
</li>
<li><p>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。</p>
</li>
</ul>
<p>说明：</p>
<ul>
<li><strong>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型</strong>；</li>
<li>可以声明抽象类指针，可以声明抽象类的引用；</li>
<li><strong>子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。</strong></li>
</ul>
<p>与虚函数的区别：</p>
<ul>
<li>使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用</li>
<li>定义形式不同：纯虚函数得加个 <code>=0</code></li>
<li>虚函数必须实现，否则会报错。</li>
<li>析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</li>
</ul>
<p>虚函数的实现机制</p>
<p>虚函数通过<strong>虚函数表</strong>来实现。<strong>虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”）</strong>，通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。</p>
<p>虚函数表相关知识点：</p>
<p>虚函数表存放的内容：类的虚函数的地址。<br>虚函数表建立的时间：<strong>编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中</strong>。<br>虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</p>
<p>注：虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。</p>
<h4 id="构造函数和虚构函数是否定义为虚函数？"><a href="#构造函数和虚构函数是否定义为虚函数？" class="headerlink" title="构造函数和虚构函数是否定义为虚函数？"></a>构造函数和虚构函数是否定义为虚函数？</h4><p>构造函数不能定义为虚函数，原因如下：</p>
<ul>
<li>从存储空间角度来看，构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用，但是调用构造函数的时候该函数还未创建，因此无法进行虚函数的调用。</li>
<li>从实用角度来看，虚函数是基类的指针指向派生类的对象是，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。</li>
<li>从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。</li>
<li>从类型上考虑：在创建对象时必须明确其类型。</li>
</ul>
<p>析构函数一般必须得定义为虚函数，原因如下：</p>
<ul>
<li><strong>防止内存泄漏</strong>，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</li>
</ul>
<h4 id="拷贝构造函数的参数为什么必须加引用"><a href="#拷贝构造函数的参数为什么必须加引用" class="headerlink" title="拷贝构造函数的参数为什么必须加引用"></a>拷贝构造函数的参数为什么必须加引用</h4><p>拷贝构造函数一般如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">const</span> A&amp; tmp);				<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;tmp);		<span class="comment">// 赋值函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果其中的<code>A(const A&amp; tmp)</code> 变为<code>A(const A temp)</code>,那么<code>const A temp</code>这个形参和实参<code>A b(a)</code>相结合的时候是<strong>要调用本类的拷贝构造函数，这样的话就成了死循环！</strong></p>
<img src="/posts/28239a8d/cpctor.jpg" class title="复制构造循环引用">

<h4 id="为什么会使用初始化列表？"><a href="#为什么会使用初始化列表？" class="headerlink" title="为什么会使用初始化列表？"></a>为什么会使用初始化列表？</h4><ul>
<li><p>当没有初始化列表之前，对象的成员变量初始化动作是在调用默认构造函数的时候发生的，因此对成员变量初始化，最开始是必须得调用一次默认构造函数。</p>
</li>
<li><p>当有了初始化列表之后，能在变量初始化的过程中少使用一次默认构造函数，而是直接调用该成员变量的相应构造函数，调用相应构造函数之前首先调用默认的构造函数为成员变量设置初值，进入函数体后，再调用构造函数。</p>
</li>
<li><p>总而言之就是少了一次默认构造函数调用，提高了构造函数的效率。</p>
</li>
</ul>
<h4 id="实例化一个对象需要哪几个阶段？"><a href="#实例化一个对象需要哪几个阶段？" class="headerlink" title="实例化一个对象需要哪几个阶段？"></a>实例化一个对象需要哪几个阶段？</h4><ol>
<li><p>分配空间</p>
<p>创建类的对象首先要为该对象分配内存空间。当然，不同的对象为其分配空间的时机未必相同。但是分配空间是第一步。</p>
</li>
<li><p>初始化</p>
<p>初始化发生在赋值之前，初始化列表优先于构造函数体内的代码执行。</p>
</li>
<li><p>赋值</p>
<p>对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在累的构造函数的函数体中。当执行完该函数体，也就意味着实例化完成了。</p>
</li>
</ol>
<p>总结：<strong>实例化对象就是为该对象分配空间到该对象执行完相应的构造函数这一段时间。</strong></p>
<h4 id="友元函数的作用及使用场景"><a href="#友元函数的作用及使用场景" class="headerlink" title="友元函数的作用及使用场景"></a>友元函数的作用及使用场景</h4><p>作用：<strong>友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制</strong>。通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。</p>
<p>友元实际上是一个破除面向对象封装的手段。</p>
<p>使用场景：</p>
<ul>
<li>普通函数定义为友元函数，使普通函数能够访问类的私有成员。</li>
<li>友元类：类之间共享数据。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>Cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU</title>
    <url>/posts/154d371b/</url>
    <content><![CDATA[<blockquote>
<p>LRU全称Least Recently Used, 最少最近使用。该算法广泛应用在各个项目中，比如redis缓存，页面置换算法等。</p>
<p>本篇文章记录一下如何设计一个LRU数据结构。</p>
</blockquote>
<span id="more"></span>



<h3 id="算法介绍："><a href="#算法介绍：" class="headerlink" title="算法介绍："></a>算法介绍：</h3><p><strong>设计类的算法最大的困难点选取合适的数据结构</strong></p>
<ul>
<li><p>算法链接：<a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></p>
</li>
<li><p>算法介绍：Least Recently Used， 在O(1)时间复杂度内进行put和get两个操作。</p>
<p>put：将新数据放入LRU中； get：获得最近使用的数据。（放入的数据是一个键值对）</p>
</li>
<li><p>算法实现： 本题目就是为了设计一个LRU数据结构。这个数据结构首先需要接收一个capacity参数作为缓存最大容量。</p>
<p>这里的话我们可以用链表来存储数据，<code>list&lt;pair&lt;int,int&gt;&gt;</code>, 因为这里要实现O(1)的插入。 那要实现O(1)的查找该怎么办呢？用哈希表来实现。 总而言之，我们最后选用一个复合数据结构—–&gt; <strong>哈希链表</strong>（哈希表和链表组合）</p>
</li>
</ul>
<p>最终，经过分析，选取了哈希链表，但是如何利用C++的优势简化哈希双向链表的实现？ 我们可以采用迭代器<code>iterator</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap_;										<span class="comment">// cap_ save the capacity of lru</span></span><br><span class="line">    <span class="comment">// 传统双向链表</span></span><br><span class="line">    <span class="keyword">using</span> DoubleList = list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;; 		<span class="comment">// pair save (key, value);</span></span><br><span class="line">    DoubleList L;</span><br><span class="line">    <span class="comment">// 哈希表存储迭代器</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, DoubleList::iterator&gt; M; 	<span class="comment">// hashmap -&gt; &#123;key : iterator&#125;;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设计好了合适的数据结构，代码便只需要写接口就行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity):cap_(capacity) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 放入lru中的话，两种情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = M.find(key);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 1. 本身该key就在list中, 先把索引值删除</span></span><br><span class="line">        <span class="keyword">if</span>(it != M.end())</span><br><span class="line">            L.erase(it-&gt;second);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除完之后就转入第二种情况，链表中没有这个键值对。</span></span><br><span class="line">        <span class="comment">// 在链表最前面添加key,value 键值对</span></span><br><span class="line">        L.push_front(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并且将其在mp登记他</span></span><br><span class="line">        M[key] = L.begin();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果链表超过容量，那么删除最远的那组</span></span><br><span class="line">        <span class="keyword">if</span>(L.size() &gt; cap_)&#123;</span><br><span class="line">            <span class="keyword">int</span> key = L.back().first;</span><br><span class="line">            M.erase(key);</span><br><span class="line">            L.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 调用的话，记得调用完调用结果要放到首位去</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = M.find(key);</span><br><span class="line">        <span class="keyword">if</span>(it == M.end())   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = it-&gt;second-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除原先的位置并把其放到首位</span></span><br><span class="line">        L.erase(it-&gt;second);</span><br><span class="line">        L.push_front(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line"></span><br><span class="line">        M[key] = L.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap_;										<span class="comment">// cap_ save the capacity of lru</span></span><br><span class="line">    <span class="comment">// 传统双向链表</span></span><br><span class="line">    <span class="keyword">using</span> DoubleList = <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;; 		<span class="comment">// pair save (key, value);</span></span><br><span class="line">    DoubleList L;</span><br><span class="line">    <span class="comment">// 哈希表存储迭代器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DoubleList::iterator&gt; M; 	<span class="comment">// hashmap -&gt; &#123;key : iterator&#125;;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至此，一个简易版的LRU算法就写好了，这个LRU算法不算难，但是由于之前的算法题目一般都是函数式编程，只需要设计好一个函数，在函数内实现功能。而这种算法设计相当于是在设计一个类，不仅仅要考虑到函数内的实现，其难点还在于如何设计一个良好的数据结构以及如何去应用它。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构</title>
    <url>/posts/85682d75/</url>
    <content><![CDATA[<blockquote>
<p>redis除了有sds外，还使用了一些常见的数据结构如链表，字典，跳跃表，整数集合和压缩列表等作为其底层数据结构。在使用的同时，Redis也对这些数据结构进行了一些优化。</p>
</blockquote>
<!--*more*-->



<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。 由于C语言没有内置这种数据结构，所以Redis构建了自己的链表实现。</p>
<p>使用场景：<strong>当一个列表键包含了数量比较多的元素，又或者列表中的包含的元素都是比较长的字符串时</strong>，Redis就会使用链表作为列表键的底层实现。</p>
<h4 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h4><p>链表我们都很熟悉，一般可以用一个struct来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双端链表节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>* value; <span class="comment">// node 节点值</span></span><br><span class="line">    ListNode* prev;	<span class="comment">// 前驱</span></span><br><span class="line">    ListNode* next; <span class="comment">// 后置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然只要使用多个<code>ListNode</code>就能够组成链表。但是这个双端链表给的信息不是很多，Redis一般使用这个Struct来表示节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;adlist.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">	<span class="comment">// 表头结点</span></span><br><span class="line">    ListNode* head;</span><br><span class="line">    <span class="comment">// 表尾结点</span></span><br><span class="line">    ListNode* tail;</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// 节点复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Redis的链表特性可以总结如下：</p>
<ul>
<li>双端：链表节点有<code>prev</code>和<code>next</code>指针，可以O(1)时间获取节点的前驱和后置节点。</li>
<li>无环：不是环状链表</li>
<li>带表头指针和表尾指针：有着head和tail节点</li>
<li>带链表长度计数器：<code> len</code>属性对链表进行技术，程序获得链表种节点数量的复杂度为O(1)</li>
<li>多态：<code>void* value</code> 节点值的类型多态。并且可以通过三个节点函数来设置类型。链表可以用于保存各种不同类型的值。</li>
</ul>
<h4 id="链表和链表节点的API"><a href="#链表和链表节点的API" class="headerlink" title="链表和链表节点的API"></a>链表和链表节点的API</h4><p>详情请见《Redis设计与实现》 P22</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典又称符号表，映射。是一种用于保存键值对的抽象数据结构。(key-value)</p>
<p>在字典中，一个key和一个value进行关联。<strong>每个key是独一无二的</strong>，用户通过寻找键来得到与之关联的值。</p>
<p>字典也是哈希键的底层实现之一。</p>
<h4 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h4><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对</p>
<ul>
<li><p>哈希表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dict.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    <span class="comment">// table是一个数组， 数组中存放的元素是一个指向dicEntry结构的指针</span></span><br><span class="line">    <span class="comment">// dicEntry 结构保存着一个键值对</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>哈希表节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">  	<span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span>* key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向下一个哈希表节点，形成链表</span></span><br><span class="line">    <span class="comment">// 这个指针可以将多个 哈希值相同 的键值对链接在一起，一次来解决键冲突的问题</span></span><br><span class="line">    dicEntry *next;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure></li>
<li><p>字典</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dicType* type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> privdata;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="comment">// 字典只使用ht[0], h[1]哈希表会在对ht[0]哈希表进行rehash时使用。</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当rehash不在进行时，设置为-1</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx;      <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>type属性是一个指向<code>dicType</code>的指针，每个<code>dicType</code>结构保存了一簇用于操作特定类型键值对的函数，Redis会为<strong>用途不同的字典设置不同的类型特定函数。</strong></li>
<li>而<code>privdata</code>属性则保存了需要传给那些<strong>类型特定函数的可选参数</strong> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">	<span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* key)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*keyDup) (<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span>* key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span>* obj);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare) (<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span>* key1, <span class="keyword">const</span> <span class="keyword">void</span>* key2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor) (<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 销毁值得函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor) (<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>​    当需要将一个键值对添加到字典中，程序需要先根据键值对的KEY计算出哈希值和索引值，再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的制定索引上面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"><span class="comment">// ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemark;</span><br></pre></td></tr></table></figure>

<pre><code> Redis使用MurmurHash2算法来计算键的哈希值，这个算法的更多信息可以参考该算法的主页：[MurmurHash2算法](http://code.google.com/p/smhasher)
</code></pre>
<h4 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h4><p>​    <strong>键冲突是指当有两个或以上数量的键被分配到了哈希数组的同一索引上面。</strong>Redis使用<strong>链地址法</strong>来解决键冲突。Redis出于速度考虑，程序总是将新节点添加到链表的表头位置（复杂度为O(1)）。</p>
<h4 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h4><p>rehash实际上就是二次哈希</p>
<ul>
<li><p>rehash的目的：随着操作不断执行，哈希表保存的键值对会逐渐地增多或者减少，<strong>为了让哈希表的负载因子（load factor）维持在一个合理的范围之内</strong>，当<strong>哈希表保存的键值对数量太多或者太少</strong>时，程序需要对哈希表的大小进行相应的扩展或收缩，这个时候用到了rehash。</p>
</li>
<li><p>rehash的步骤：</p>
<ul>
<li>为字典ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）<ul>
<li>如果执行<strong>扩展</strong>操作， *<em>ht[1]的大小为第一个大于等于ht[0].used <em>2 的 2^n</em></em>(2的n次方幂)</li>
<li>如果执行<strong>收缩</strong>操作，<strong>ht[1]的大小为第一个大于等于ht[0].used 的 2^n</strong>（二者是除以2的关系）</li>
</ul>
</li>
<li>将保存在ht[0]中的所有键值对rehash到ht[1]上面：<strong>rehash指的是重新计算键的哈希值和索引值，然后将键值对房知道ht[1]的指定位置上。</strong></li>
<li><strong>当ht[0]上全部键值对都转移到ht[1]上之后，释放ht[0],将ht[1]设置为ht[0], ht[1]设置为空白哈希表，为下一次rehash做好准备。</strong>（相当于ht[1]是一个后备缓存）</li>
</ul>
</li>
<li><p>扩展收缩的条件</p>
<ul>
<li><p>扩展操作条件</p>
<ul>
<li>服务器目前<strong>没有</strong>执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，并且负载因子大于等于1</li>
<li>服务器目前<strong>正在</strong>执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，并且负载因子大于等于5</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面两个命令相当于服务器正在创建服务器进程的子进程，由于写时复制的问题，在子程序存在期间，服务器会提高执行扩展操作使用的负载因子。从而避免在子进程存在期间进行扩展操作，以此节约内存。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span></span><br><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure></li>
<li><p>收缩操作条件： 负载因子小于等于0.1</p>
</li>
</ul>
</li>
</ul>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>​    <strong>rehash动作不是一次性完成的，而是分多次、渐进式的完成。</strong>（如何渐进式完成，通过索引计数器）</p>
<ul>
<li><p>渐进式rehash步骤</p>
<ul>
<li>为ht[1]分配空间，让字典同时持有两个hash表</li>
<li>字典中维持的索引计数器变量<code>rehashidx</code>从-1变为0，表示rehash工作正式开始</li>
<li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定操作以外，还会<strong>顺带ht[0]哈希表在<code>rehashidx</code>索引上的所有键值对rehash到ht[1]</strong>,当rehash工作完成之后，程序将<code>rehashidx</code>属性自增1</li>
<li>随着字典不断执行，ht[0]所有键值对都会被rehash至ht[1],这时程序将<code>rehashidx</code>属性设置为-1</li>
</ul>
<p>索引计数器从-1到0开始，完成之后置为-1。</p>
</li>
</ul>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>​    <strong>跳跃表是一种有序数据结构，通过在每个节点维持多个指向其他节点的指针，从而达到快速访问节点的目的。</strong></p>
<p>​    跳跃表TC： 平均O(logN)，最坏 O(N)进行节点查找，可以通过顺序性操作来批量处理节点。（效率高，大部分和平衡树媲美，但是比平衡树简单）</p>
<p>​    <strong>一般用于有序集合键的底层实现</strong>，或者用于集群节点中作为内部数据结构。</p>
<p>(特点：通过每个节点维持指向其他节点的指针来维持有序行)</p>
<h4 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h4><p>redis的跳跃表有以下两个结构定义，其中一个结构用于表示跳跃表的节点，另外一个结构表示跳跃表的相关信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;redis.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳跃表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>* <span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>* <span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳跃表节点相关信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>* <span class="title">header</span>;</span>	<span class="comment">// 指向跳跃变的表头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>* <span class="title">tail</span>;</span>	<span class="comment">// 指向跳跃表的表尾节点</span></span><br><span class="line">    <span class="keyword">int</span> level;				<span class="comment">// 记录跳跃表内，层数最大的那个节点层数（表头节点不计算在内）O(1)</span></span><br><span class="line">    <span class="keyword">int</span> length;				<span class="comment">// 记录跳跃表的长度，即包含节点的数量（表头节点不计入在内） O(1)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>跳跃表节点：</p>
<ul>
<li><p>层： 跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，<strong>层的数量越多，访问其他节点速度越快。</strong> 每次创建一个新跳跃表节点，程序根据幂次定律（越大的数出现概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是<strong>层的高度</strong></p>
</li>
<li><p>前进指针：每个层都有指向表尾方向的前进指针(level[i].forward)，用于从表头向表尾方向访问节点。（前进指针有多个）</p>
</li>
<li><p>跨度： 用于记录两个节点之间的距离：</p>
<ul>
<li>两个节点之间跨度越大，相距越远。</li>
<li>指向nullptr的跨度都为0，因为没有连向任何节点。</li>
</ul>
</li>
<li><p>后退指针：用于表尾向表头访问的节点，<strong>每个节点只有一个后退指针，只能退一个节点</strong>，后退指针最多退到头指针的后一个指针（头指针退不到）</p>
</li>
<li><p>分值：跳跃表中<strong>所有节点都是按照分值从小到大来排序</strong></p>
</li>
<li><p>成员：<strong>obj属性，指向一个字符串对象，而字符串对象则保存着一个SDS值。</strong></p>
</li>
</ul>
</li>
</ul>
<p>另外可以保存相同分值的节点，分值相同的节点将按照成员对象在字典序中的大小进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较小的节点则会排在后面，<strong>成员对象一定是唯一的</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>跳跃表是有序集合的底层实现之一</li>
<li>Redis跳跃表由<code>zskiplist</code> 和<code>zskiplistNode</code> 两个结构组成，这两个结构一定要记得。</li>
<li>每个跳跃表节点的层数是1-32之间的随机数。</li>
<li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</li>
<li>节点按照分值大小排序，分值相同，则按照成员对象大小进行排序。</li>
</ul>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>​    整数集合<code>intset</code>是集合键的底层实现之一，当一个集合<strong>只包含整数值元素，并且这个集合的元素数量不多</strong>时，Redis会将其作为集合键的底层实现。</p>
<h4 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h4><p>​    整数集合可以保存类型为<code>int16_t, int32_t或者 int64_t</code>的整数值，并且<strong>保证集合中不会出现重复元素</strong>（毕竟是set）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intset.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint_t</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>contents 数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项(items),各个项在数组中<strong>按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</strong></li>
<li>length属性记录了整数集合包含的元素数量。</li>
</ul>
<p>虽然contents数组类型是<code>int8_t</code>， 但是这数组并不保存任何<code>int8_t</code>类型的值，<strong>contents数组的真正类型取决于encoding属性的值。</strong></p>
<ul>
<li>encoding属性<ul>
<li>如果encoding属性的值为<code>INTSET_ENC_INT16</code>,那么contents就是一个<code>int16_t</code>类型数组大小。</li>
<li>同样的，如果为<code>INTSET_ENC_INT32</code>，则<code>int32_t</code>； 如果为<code>INTSET_ENC_INT64</code>，则<code>int64_t</code></li>
</ul>
</li>
</ul>
<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>​    当我们要<strong>将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时</strong>，整数集合需要先进行<strong>升级</strong>，才能将新元素添加到整数集合里去。</p>
<p>​    升级并添加新元素共分为三步：</p>
<ul>
<li><p>根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间（扩容）</p>
</li>
<li><p>将原有的元素转换成新元素的类型，并将类型转换后的元素放在正确的位上，在放置元素的过程中，<strong>底层数组有序性质不改变</strong>。（转类型）</p>
</li>
<li><p>将新元素加入底层数组。（添加新元素）</p>
</li>
</ul>
<p>由于引发升级的新元素的长度总是比整数集合现有所有元素的长度都打，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素。</p>
<ul>
<li>大于现有元素，插入到最后面</li>
<li>小于现有元素，插入到最前面</li>
</ul>
<p>升级的好处：</p>
<ul>
<li>提升整数集合的灵活性</li>
<li>节约内存</li>
</ul>
<h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p>​    <strong>整数集合不支持降级操作，一旦升级了，就算数组中的高位数被删除了，维持的依旧是高位。</strong></p>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>​    压缩列表是<strong>列表键和哈希键</strong>的底层实现之一。<strong>当列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表作为底层实现</strong>。</p>
<h4 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h4><p>​    压缩列表是为了节约内存而开发的，是由<strong>一系列特殊编码的连续内存块组成的顺序型数据结构。</strong>一个压缩列表可以包含任意多个节点，<strong>每个节点保存一个字节数组或者一个整数值</strong>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">|  属性     |   类型   |   长度   |          用途</span><br><span class="line">- zlbytes	 <span class="built_in">uint</span>32_t   <span class="number">4</span>bytes 		记录整个压缩列表占用的内存字节数：对压缩列表进行内存重分配或者计算zlend位置时使用。</span><br><span class="line">- zltail	 <span class="built_in">uint</span>32_t  	<span class="number">4</span>bytes		记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过该偏移量确定表尾节点位置-O(<span class="number">1</span>)</span><br><span class="line">- zllen      <span class="built_in">uint</span>16_t   <span class="number">4</span>bytes      记录压缩列表包含的节点数量，当节点数大于<span class="built_in">uint</span>16_MAX时,真实节点数必须遍历得到。</span><br><span class="line">- entryX 	 列表节点	  不定		压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</span><br><span class="line">- zlend 	 <span class="built_in">uint</span>8_t    <span class="number">1</span>bytes		特殊值<span class="number">0xFF</span>(<span class="number">255</span>),用于标记压缩列表的末端。</span><br></pre></td></tr></table></figure>



<h4 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h4><p>每个压缩节点可以保存一个<strong>字节数组或者一个整数值</strong>。</p>
<p>其中字节数组可以是一下三种长度之一</p>
<ul>
<li>长度小于等于63字节的字节数组 (2^6-1)</li>
<li>长度小于等于16383字节的字节数组(2^14-1)</li>
<li>长度小于等于2^32-1字节的字节数组</li>
</ul>
<p>整数值则可以是以下六种长度之一</p>
<ul>
<li>4位长，介于0-12的无符号整数</li>
<li>1字节长的有符号整数</li>
<li>3字节长的有符号整数</li>
<li>int16_t 类型整数</li>
<li>int32_t 类型整数</li>
<li>int64_t 类型整数</li>
</ul>
<p>每个压缩列表节点都有<code>previous_entry_length、 encoding、 content</code>组成</p>
<ul>
<li><p><code>previous_entry_length</code>: 以字节为单位，<strong>记录了压缩列表中的前一个节点的长度</strong>。（可以是1字节也可以是5字节，取决于前一个节点的长度）</p>
<p><strong>由于压缩列表是顺序型存储，当我们知道某个节点起始地址的指针，那么通过这个指针和<code>previous_entry_length</code>就可以往前回溯，最终达到头结点</strong></p>
</li>
<li><p><code>encoding</code>: 记录了节点的content属性所保存的类型以及长度</p>
<ul>
<li>值最高00,01,10这种编码表示节点content属性保存着的是字节数组</li>
<li>值最高位以11开头的是整数编码</li>
</ul>
</li>
<li><p><code>content</code>: 负责保存节点值。</p>
</li>
</ul>
<h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>​    由于压缩列表是顺序存放的，如果在<strong>一些临界值特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”</strong>。（在<code>previous_entry_length</code>的长度介于1字节和5字节之间的时候，添加节点或者删除节点，可能会造成连锁更新)</p>
<p>​    因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N),所以连锁更新的最坏复杂度为O(N^2).但是最坏的情况基本不会发生，因此我们放心使用API，我们只要清楚知道什么是连锁更新，连锁更新做了什么就行。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Redis设计与实现》</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp语法</title>
    <url>/posts/14ad0c05/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章用问答的方式记录一些C++(11及11以前）常见的语法，常见语法包括基本关键字和一些基本的语法知识等。</p>
</blockquote>
<span id="more"></span>



<h4 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h4><p>static关键字既可以修饰函数也可以修饰变量，用来定义静态函数和静态变量。其作用是根据其作用域来决定的。</p>
<ul>
<li><p>当static关键字的作用域为整个文件时(即全局静态变量/函数)</p>
<ul>
<li>该全局变量和函数只能被本文件所”看见“——<strong>全局静态变量只能在本文件中访问，全局静态变量函数只能在本文件中调用。在其他文件中是不可见的。</strong></li>
<li>该全局变量的生命周期是整个程序。</li>
</ul>
</li>
<li><p>当static关键字的作用域为一个类时（即类内静态成员变量/函数）</p>
<ul>
<li><p><strong>静态成员变量在类内进行声明，在类外进行定义和初始化，类外定义和初始化的时候不能带有static关键字</strong>。</p>
</li>
<li><p>静态成员变量是类作用域的全局变量，被所有类的对象共享，包括派生类的对象。因此计算对象大小要把static变量剔除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof A = 4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//	int b;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sizeof B = 1</span></span><br></pre></td></tr></table></figure></li>
<li><p>静态成员在类第一次创建对象的时候就已经创建了，生命周期为类的生命周期。</p>
</li>
<li><p>静态成员变量可以作为成员函数的参数，因为在调用该函数的时候，静态成员变量已经被定义了</p>
</li>
<li><p><strong>静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> A s_var; <span class="comment">// 正确，静态数据成员</span></span><br><span class="line">    A var;          <span class="comment">// error: field &#x27;var&#x27; has incomplete type &#x27;A&#x27;</span></span><br><span class="line">    A *p;           <span class="comment">// 正确，指针</span></span><br><span class="line">    A &amp;var1;        <span class="comment">// 正确，引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>静态成员函数是类作用域的全局函数，<strong>没有this指针</strong>，因此不能调用非静态成员变量和非静态成员函数</p>
</li>
<li><p>静态成员函数不能被声明为虚函数，const函数和volatile函数，因为没有this指针，修饰它没有任何意义。</p>
</li>
</ul>
</li>
<li><p>当static的作用域为一个函数时，称为局部变量</p>
<ul>
<li>局部变量的生命周期为该函数，在函数定义时开始，从函数结束时结束</li>
</ul>
</li>
<li><p>static修饰的变量都被放在<code>.data</code>和<code>.bss</code>段</p>
</li>
</ul>
<h4 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h4><p><strong>作用</strong>：</p>
<ul>
<li><p>const 修饰<strong>成员变量</strong>，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。</p>
</li>
<li><p>const 修饰<strong>函数参数</strong>，使得传递过来的函数参数的值不能改变。</p>
</li>
<li><p>const 修饰<strong>成员函数</strong>，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用</p>
<p>非 const <strong>成员函数</strong>，因为非 const 成员函数可能会修改成员变量。</p>
</li>
</ul>
<p><strong>在类中的用法</strong>：</p>
<ul>
<li><p>const 成员变量：</p>
<ul>
<li>c<strong>onst 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化</strong>。</li>
<li>const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此<strong>不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。</strong></li>
</ul>
</li>
<li><p>const 成员函数：</p>
<ul>
<li>不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。</li>
<li>不能调用非常量成员函数，以防修改成员变量的值。</li>
<li>带const和不带const的函数是重载函数，并不会出问题。</li>
</ul>
</li>
</ul>
<p><strong>底层const和顶层const:</strong></p>
<ul>
<li>顶层const:  对象本身是const； （常量的定义就是一个top-level const的对象类型）</li>
<li>底层const：指针（对象本身）所指的对象是const（一般来说本身是个指针）</li>
</ul>
<p><strong>它和constexpr的区别:</strong></p>
<ul>
<li>const关键字只是在编译期编译器将其标记为一个常量，但是其具体的值并不清楚。</li>
<li>constexpr关键字在编译期不仅知道其为一个常量，还知道具体的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 在编译期，a被标记为整型常量，b被标记为整型数字4</span></span><br></pre></td></tr></table></figure>

<p><strong>它和define的区别：</strong></p>
<ul>
<li><p><strong>编译阶段</strong>：define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值。</p>
</li>
<li><p><strong>安全性</strong>：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</p>
</li>
<li><p><strong>内存占用</strong>：define 定义的宏常量，<strong>在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的局部常量在栈上，全局常量在<code>.data</code>段，程序运行过程中只有一份。</strong></p>
</li>
<li><p><strong>调试</strong>：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const 定义的常量可以进行调试。</p>
</li>
</ul>
<h4 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h4><ol>
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用this指针：<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
<h4 id="inline关键字"><a href="#inline关键字" class="headerlink" title="inline关键字"></a>inline关键字</h4><p>inline关键字用来修饰内联函数。</p>
<p><strong>内联函数的作用</strong>：</p>
<ul>
<li><p><strong>消除函数调用的开销。</strong><br>在内联函数出现之前，程序员通常用 #define 定义一些“函数”来消除调用这些函数的开销。内联函数设计的目的之一，就是取代 #define 的这项功能。</p>
</li>
<li><p><strong>去除函数只能定义一次的限制</strong>。<br><strong>内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。</strong></p>
</li>
</ul>
<p><strong>关于减少函数调用的开销：</strong></p>
<ul>
<li>内联函数一定会被编译器在调用点展开吗？<ul>
<li>错<strong>，inline 只是对编译器的建议，而非命令</strong>。编译器可以选择忽视 inline。当程序员定义的 inline 函数包含复杂递归，或者 inlinie 函数本身比较长，编译器一般不会将其展开，而仍然会选择函数调用。</li>
</ul>
</li>
<li>“调用”普通函数时，一定是调用吗？<ul>
<li>错，<strong>即使是普通函数，编译器也可以选择进行优化，将普通函数在“调用”点展开</strong>。</li>
</ul>
</li>
<li>既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？<ul>
<li>错。首先，如第一点所言，编译器可以选择调用内联函数，而非展开内联函数。因此，内存中仍然需要一份内联函数的定义，以供调用。<br>而且，一致性是所有语言都应该遵守的准则。普通函数可以有指向它的函数指针，那么，内联函数也可以有指向它的函数指针，因此，内存中需要一份内联函数的定义，使得这样的函数指针可以存在。</li>
</ul>
</li>
</ul>
<p><strong>关于去除函数只能定义一次的限制：</strong></p>
<ul>
<li><p>该程序会报错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;function 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;function 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">myPrint</span>();  <span class="comment">// error，会出现链接时错误， myPrint 函数被定义了两次。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用内联函数不会报错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;inline function 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;inline function 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">myPrint</span>()	<span class="comment">// 正常运行;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>因此，<strong>内联函数可以在头文件中定义</strong>（即多个 .cpp 源文件可以定义函数名、参数都一样的内联函数，而不会有重定义错误）</p>
</li>
</ul>
<p><strong>内联函数缺点</strong>：</p>
<ul>
<li>导致代码膨胀</li>
<li>inline函数无法随着函数库升级，inline函数改变需要重新编译。</li>
<li>是否内联编译器说的算，程序员不可控。</li>
</ul>
<h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p><strong>volatile关键字的作用：</strong></p>
<ul>
<li>该关键字的作用很简单，仅仅是<strong>让编译器不会对相应的对象进行优化，即不会将变量从内存中写入寄存器中。</strong></li>
</ul>
<p><strong>延伸：</strong></p>
<ul>
<li>虽然作用很简单，但是这个作用让变量值一直在内存中，这样多线程对该变量进行操作的时候，就只能对该变量本身操作，而不会出现既操作内存又操作寄存器的场景，这样很可能会在操作变量时出错。</li>
<li><strong>volatile和原子性无关</strong></li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>当多线程都用到某一变量，而且该变量可能会改变时，那就用volatile关键字修饰它，防止操作出错。</li>
<li>中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 <code>volatile</code> 关键字修饰。</li>
</ul>
<h4 id="new-free关键字"><a href="#new-free关键字" class="headerlink" title="new/free关键字"></a>new/free关键字</h4><p>new/free关键字是C++用来动态分配/释放内存空间的函数组。</p>
<p><strong>new/free函数</strong></p>
<p>new函数分为两个步骤</p>
<ul>
<li><strong>首先分配一块内存 （operator new 这个步骤和malloc是一样的（都是在堆上调用mmap系统调用，都是面向内存的）</strong></li>
<li><strong>然后针对对象类型进行构造 （placement new 这个步骤保证了new的类型安全</strong>）</li>
</ul>
<p>free则是反向操作。</p>
<p>和malloc/delete之间还有个差别是new/free自动计算分配空间大小，而malloc需要自己指定。</p>
<h4 id="std-move-和-std-forward是什么？std-forward为何可以称为完美转发"><a href="#std-move-和-std-forward是什么？std-forward为何可以称为完美转发" class="headerlink" title="std::move 和 std:forward是什么？std::forward为何可以称为完美转发"></a>std::move 和 std:forward是什么？std::forward为何可以称为完美转发</h4><p>std::move的作用很简单，只是将变量本身类型转换成<strong>右值引用类型（&amp;&amp;）</strong></p>
<p><strong>引用</strong></p>
<p>引用分为左值引用(&amp;)和右值引用（&amp;&amp;）。</p>
<ul>
<li><p>左值引用我们都很熟悉，在汇编层面相当于普通的指针，不过定义引用变量必须初始化，和一个对象或变量进行绑定。那如果是一个常数呢，左值引用就不行了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;var = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>因为数字10无法进行取地址操作，毕竟10存在寄存器中，而非在内存中，没有地址。</p>
<p>当然我们可以，const能够生成临时变量保存const，不过这样就不可能修改数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; var = <span class="number">10</span>;	</span><br></pre></td></tr></table></figure>

<p>于是c++引入了右值引用的概念</p>
</li>
<li><p>右值引用</p>
<ul>
<li>可以取地址的，有名字的，<strong>非临时</strong>的就是左值引用；</li>
<li>不能取地址的，没有名字的，<strong>临时</strong>，<strong>即将消散</strong>的就是右值引用；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; var = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>右值引用如果修饰对象的话，那么该对象之后会消失（析构）</p>
</li>
<li><p>类中使用</p>
<p>在类中在左值引用基础上引申出<strong>拷贝语义</strong>——拷贝构造函数和拷贝运算符，右值引用基础上引申出<strong>移动语义</strong>——移动构造函数和移动运算符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span>	<span class="comment">// 省略掉类内信息，具体语法在面向对象中详细说明  </span></span><br><span class="line">A a;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;		<span class="comment">// 如果是有拷贝语义，那么b复制了份a，现在内存中有两个A对象实例； </span></span><br><span class="line">  			<span class="comment">// 如果是有移动语义，那么就是将a移动到了b对象所有权下面，此时内存中只有一个A对象实例b</span></span><br></pre></td></tr></table></figure>

<p>拷贝语义：当使用拷贝构造函数创建对象的时候，相当于是复制了个对象。</p>
<p>移动语义：在内存层次将对象移动到新对象实例之中。</p>
<p><strong>拷贝操作是很昂贵的，因为要新建一个完全相同的对象，而移动操作只是控制对象从a移动到b，因此如果不需要保留a的情况下，尽量使用移动操作</strong></p>
</li>
</ul>
<p><strong>std::move</strong></p>
<p>​    说清楚了引用，剩下的都很好办，std::move只有一个作用，<strong>执行强制型别转换：无条件地将实参转换成右值。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面代码是move的实现，就是进行static_cast转换成右值。不过当值转换成右值了，那么就可以进行移动操作了。</p>
<p><strong>std::forward</strong></p>
<p>​    T&amp;&amp;其实有两种含义，一种就是右值引用，另外一种就是既可以是右值引用，也可以是左值引用，称之为万能引用。但是后者一般要涉及到型别推导，当然涉及到形参推演只是一个必要条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;		<span class="comment">// 万能引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;		<span class="comment">// 万能引用</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果没型别推导</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A&amp;&amp; param)</span></span>;		<span class="comment">// 右值引用</span></span><br></pre></td></tr></table></figure>

<p>​    万能引用有一个规则：如果采用右值初始化万能引用，那么就会得到右值引用，如果采用左值初始化，那么得到的是左值引用。</p>
<p>std::forward和std::move一样，也只是强制型别转换：<strong>和一个可供移动的对象进行绑定，只有右值初始化时才会将该对象强制类型成右值型别。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span>&#123;</span><br><span class="line">    name = std::forward&lt;T&gt;(<span class="keyword">new</span> Name);		<span class="comment">// 万能引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这样</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span>&#123;</span><br><span class="line">    name = std::<span class="built_in">move</span>(<span class="keyword">new</span> Name);				<span class="comment">// 也是万能引用，但编译起来糟糕透顶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们必须遵循：<strong>针对右值引用实施std::move,针对万能引用实施std::forward</strong>，别用错了！！</p>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。</p>
<p><strong>智能指针的作用</strong></p>
<ul>
<li>智能指针的作用是管理一个指针，防止造成堆上的内存泄漏。</li>
<li>智能指针是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。</li>
<li>所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</li>
</ul>
<p><strong>auto_ptr</strong>(C98)</p>
<p>采取所有权模式，存在潜在的内存崩溃问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt; <span class="built_in">string</span>&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;I reigned lonely as a cloud.”));</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">// 此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。                                 </span></span></span></span><br></pre></td></tr></table></figure>



<p><strong>unique_ptr</strong>(替换auto_ptr)</p>
<p>依旧采取所有权模式，实现独占式拥有或严格拥有的概念。<strong>保证同一时间内只有一个智能指针可以指向该对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt;;		<span class="comment">// 会生成一个指向A特定实例的指针。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">unique_ptr 和 单例模式的区别</span></span><br><span class="line"><span class="comment">	-&gt; 会生成一个指向A特定实例的指针，unique_ptr&lt;A&gt;不会阻止创建其他A实例对象,</span></span><br><span class="line"><span class="comment">		即不能有两个unique_ptr&lt;A&gt;指向同一个对象</span></span><br><span class="line"><span class="comment">	-&gt; 单例模式是只能有一个A的实例对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;auto&quot;</span>))</span></span>;     </span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4;   	<span class="comment">// 	没问题，如果是单例的话这个时候就出问题了       </span></span><br><span class="line"></span><br><span class="line">p4 = p3;					<span class="comment">//	指向同一个对象，那此时会报错！！</span></span><br></pre></td></tr></table></figure>

<p>当然如果创建一个unique_ptr对象的话，不要用new，而是直接用<code>std::make_unique</code></p>
<p><strong>shared_ptr</strong></p>
<p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用<strong>引用计数机制来表明资源被几个指针共享</strong>。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>当然如果创建一个share_ptr对象的话，不要用new，而是直接用<code>std::make_shared</code></p>
<p><strong>weak_ptr</strong></p>
<p>weak_ptr是一种不控制对象生命周期的智能指针，它指向一个 shared_ptr 管理的对象。</p>
<ul>
<li>进行该对象的内存管理的是那个强引用的 shared_ptr. <strong>weak_ptr只是提供了对管理对象的一个访问手段</strong>。</li>
<li>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</li>
<li><strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。</strong>它是对对象的一种弱引用，不会增加对象的引用计数，<strong>可以和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</strong></li>
<li>不过不能通过weak_ptr直接访问对象，它只是针对shared_ptr相互引用的死锁问题而发明的一个弱引用方法。</li>
</ul>
<h4 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h4><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast。</p>
<p><strong>const_cast</strong></p>
<ul>
<li>用于将<strong>const变量转为非const</strong>（去除const的转换）</li>
</ul>
<p><strong>static_cast</strong></p>
<ul>
<li>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</li>
<li>static_cast基本上代替了一般的隐式转换，这个是最普遍的转换方式</li>
</ul>
<p><strong>dynamic_cast</strong>（运行期转换）</p>
<ul>
<li><p><strong>用于动态类型转换</strong>。只能用于含有虚函数的类，用于类层次间的向上和向下转化。<strong>只能转指针或引用</strong>。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p>
</li>
<li><p>向上转换：指的是子类向基类的转换</p>
</li>
<li><p>向下转换：指的是基类向子类的转换</p>
</li>
<li><p>它通过<strong>判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</strong></p>
</li>
</ul>
<p><strong>reinterpret_cast</strong></p>
<p>几乎什么都可以转，比如将int转指针。这个是将变量所在的内存重新解释，因此可能会出问题，尽量少用。</p>
<p><strong>为什么不使用C的强制转换？</strong></p>
<p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
<p>最后，遇到类型转换一定要养成用显示类型转换的好习惯。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li> 《C++ Primer》</li>
<li> 《Effective Modern C++》</li>
</ol>
<hr>
<p><em>此文档会一直增加新的知识点，如有错误，请不吝指出</em></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
        <tag>C++关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O多路复用</title>
    <url>/posts/7ce262fd/</url>
    <content><![CDATA[<blockquote>
<p>在网络编程中熟知的一个方法。nignx和redis中都实现了该方法，属于网络编程中的基本概念</p>
</blockquote>
<span id="more"></span>



<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>​    I/O多路复用是指程序在单个线程内通过记录每个I/O流的状态，来同时管理多个I/O流。这样使得程序能够在单线程内同时监听多个文件描述符。</p>
<p>   不过值得注意的是，I/O复用虽然能同时监听多个文件描述符，但是其本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外措施，程序就只能按顺序依次处理其中的每个文件描述符。</p>
<p>​    虽然是能够在单个线程同时监听多个文件描述符，但是文件描述符就绪依旧是串行处理，明白这一点就不会将I/O多路复用和并发混淆，因为串行处理事件并不是并发。</p>
<p>​    I/O多路复用有三种熟知的具体实现，分别是Select，Poll 和 Epoll，下面来依次介绍它们。</p>
<h3 id="SELECT系统调用"><a href="#SELECT系统调用" class="headerlink" title="SELECT系统调用"></a>SELECT系统调用</h3><p>​    用途：在指定时间内，<strong>监听用户感兴趣的文件描述符上的可读，可写和异常事件</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">( <span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    由上面的API可以看出，nfds是感兴趣的fd总数，后面三个参数分别是三种fd的集合，最后一个时间参数是指定时间，如果超过时间直接返回。</p>
<pre><code> 而`fd_set`结构体仅仅包含一个整形数组，**该数组的每个元素的每一位标记一个fd。**fd_set能容纳的文件描述符最大数量优先，应该是2^16。
</code></pre>
<p>​    这是select最大的缺点：</p>
<ul>
<li><p><strong>每次去查看文件描述符的状态都要按位去轮询整个数组，O（N），效率不高</strong></p>
</li>
<li><p><strong>而且存储的文件描述符有上限，只能存储几万个</strong>（这个很少，fd的上限能够达到上百万个）</p>
</li>
<li><p>非线程安全</p>
</li>
</ul>
<h3 id="POLL系统调用"><a href="#POLL系统调用" class="headerlink" title="POLL系统调用"></a>POLL系统调用</h3><p>​    poll和select类似，也是在<strong>指定时间轮询一定数量的文件描述符</strong>，以测试其中是否有就绪者。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">  	<span class="keyword">int</span> fd;				<span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;		<span class="comment">// 注册的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents;		<span class="comment">// 活跃的事件，由内核填充</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    看到这个API其实和select也是有点差别的。</p>
<ul>
<li>存放文件描述符的数据结构从数组位变成了</li>
<li>事件类型区分更为细致，select只有三种时间类型，而poll将其细化了。如可读事件分为了POLLIN,POLLRDNORM, POLLDRBAND, POLLPRI四种。</li>
</ul>
<p>不过nfds和timoeout参数都和select相似，这里不赘述。</p>
<p>其缺点也和select类似，</p>
<ul>
<li>遍历所有fd，不活跃fd也会去检查它的状态，O(N)</li>
<li>线程不安全</li>
</ul>
<p>不过因为不是通过数组位存储，因此无上限太低的缺点。</p>
<h3 id="EPOLL系统调用"><a href="#EPOLL系统调用" class="headerlink" title="EPOLL系统调用"></a>EPOLL系统调用</h3><p>接下来就迎来主角了，epoll是Linux特有的I/O复用函数，其实现和前两者有较大差异。</p>
<p>优点</p>
<ul>
<li>epoll使用一组函数实现多路复用，前两者都只有单个函数</li>
<li>epoll将用户关心的文件描述符上的事件放在内核里的一个事件表中，无需O(N)，只需要O(1)地查看关心的事件</li>
<li>检查文件描述符是否就绪的方法更好，epoll采用回调的机制，而前两者采用的轮询机制，随着fd增加，回调效率不怎么降低，而轮询会大大降低。</li>
<li>线程安全</li>
</ul>
<p>略有瑕疵的缺点</p>
<ul>
<li>内核事件表需要额外一个文件描述符表示，浪费了一个文件描述符</li>
<li>只能在Linux上用</li>
</ul>
<h4 id="epoll事件表"><a href="#epoll事件表" class="headerlink" title="epoll事件表"></a>epoll事件表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该API创建一个内核事件表，返回与该事件表绑定的文件描述符。</strong>size无多大含义，只是通知内核告诉它事件表多大。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">  	<span class="keyword">uint32_t</span> events; 	<span class="comment">// epoll 事件</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;	<span class="comment">// 用户数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该API用来操作已创建的内核事件表。当内核缓冲区发生变化，使用该函数向事件表注册事件</strong></p>
<p>参数分析：</p>
<ul>
<li><p>epfd是负责内核事件表的文件描述符</p>
</li>
<li><p>fd是要操作的文件描述符，op是操作类型：</p>
<ul>
<li>EPOLL_CTL_ADD：往事件表注册fd上的事件</li>
<li>EPOLL_CTL_MOD：修改fd上的注册事件</li>
<li>EPOLL_CTL_DEL：删除fd上的注册事件</li>
</ul>
</li>
<li><p>event参数指定事件。事件类型存储在event-&gt;events中。epoll的事件类型和poll类似，只不过在前面加了个E，不过epoll有两种额外的事件——EPOLLET和EPOLLONESHOT。这个后面再讲。</p>
</li>
<li><p>返回值：成功回0，失败回-1并设置errno。</p>
</li>
</ul>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>​    epoll的主要接口是epoll_wait函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该API在一段超时时间内等待一组文件描述符上的事件。</strong></p>
<p>参数：</p>
<ul>
<li>maxevents 指定最多能够监听多少个事件，必须大于0</li>
</ul>
<p><strong>如果检测到事件</strong>，就将所有就绪的事件从内核事件表（由epfd指定）中复制到它的第二个参数events指向的数组中。<strong>这个数组只用于输出epoll_wait检测到的就绪事件，而不像前两者的数组参数那样即用于传入用户注册的事件，又用于输出检测的内核事件。这样极大提高了应用程序索引就绪文件描述符的效率。</strong>（目前还是LT模式的效率提升，因为是检测到事件就返回）</p>
<h4 id="ET和LT模式"><a href="#ET和LT模式" class="headerlink" title="ET和LT模式"></a>ET和LT模式</h4><p>​    epoll对fd的操作用两种模式:ET和LT。其中LT是默认工作模式，这个模式下就是效率提升版的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET时间事，epoll工作模式变成了ET，ET是epoll的高效模式。</p>
<p>​    采用LT模式时，如果检测到有事件发生时，epoll_wait将此事通知给应用程序，应用程序可以不处理它，但是下次调用epoll_wait依旧会通知应用程序来处理它。</p>
<p>​    而ET模式不同，ET模式当通知了应用程序，应用程序必须立即处理该事件，因为后续的epoll_wait调用不再向应用程序通知这一事件。这样一来极大降低了同一事件被重复触发的次数（但是可能通知了没处理直接被漏掉了吗？思考一下）</p>
<p>​    形象的说就是<strong>LT模式是传统的调用epoll_wait有活跃事件就触发（可读事件缓冲区不为空，可写事件缓冲区不满），而ET是增量触发，只有新事件到来才会通知应用程序。</strong></p>
<p>​    （ET必须是非阻塞的！）</p>
<h4 id="EPOLLSHOT事件"><a href="#EPOLLSHOT事件" class="headerlink" title="EPOLLSHOT事件"></a>EPOLLSHOT事件</h4><p>​    即使我们使用ET模式，<strong>一个socket上的某个事件还是可能被触发多次</strong>。这在并发程序中会引起一个问题。比如一个线程在读取完某个socket上的数据后开始处理这些数据，在处理数据过程中又有新数据可读，这样新的线程唤醒去读新数据，那么就出现了<strong>两个线程同时操作一个socket的局面</strong>。但是我们期望的是<strong>一个socket连接在任一时刻都只被一个线程处理。（因为这会导致线程同步问题）</strong></p>
<p>​    这里就可以采用EPOLLSHOT事件，对于注册该事件的fd，<strong>操作系统最多出发其上注册的一个可读、可写或者一长时间，且只触发一次。</strong>这样当一个线程处理这socket，其他线程不能处理该socket。</p>
<p>​    但是反过来思考一下，只触发一次，那下次怎么办？因此触发这一次之后要重置EPOLLSHOT事件，进而让其他工作线程之后有机会处理该socket</p>
<h3 id="三种系统调用的对比"><a href="#三种系统调用的对比" class="headerlink" title="三种系统调用的对比"></a>三种系统调用的对比</h3><p>​    这三组系统调用都通过某种结构体变量来告诉内核监听那些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">SELECT</th>
<th align="center">POLL</th>
<th align="center">EPOLL</th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用数据结构</td>
<td align="center">三个数组构成的位图</td>
<td align="center">统一数据结构<code>epollfd</code></td>
<td align="center">同一数据结构，内核注册表</td>
</tr>
<tr>
<td align="center">事件类型</td>
<td align="center">最基本的三种：可读、可写、异常</td>
<td align="center">带有优先级的事件类型，区分更细致</td>
<td align="center">和poll类似，多了ET和SHOT</td>
</tr>
<tr>
<td align="center">事件监听机制</td>
<td align="center">轮询</td>
<td align="center">轮询</td>
<td align="center">回调</td>
</tr>
<tr>
<td align="center">时间复杂度</td>
<td align="center">O(N)</td>
<td align="center">O(N)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">优点</td>
<td align="center">多平台可用，简单</td>
<td align="center">多平台可用，简单，上限比select高</td>
<td align="center">高效，LT模式下就是O(1)，ET模式下更是减少同一事件的多次触发，线程安全</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">低效，处理的fd有上限，非线程安全</td>
<td align="center">低效，非线程安全</td>
<td align="center">仅LINUX可用</td>
</tr>
</tbody></table>
<p><strong>PS：虽然epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</strong></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>I/O多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/posts/735e5788/</url>
    <content><![CDATA[<blockquote>
<p> 各类排序算法是一个很基础的算法概念，在面试当中，手撕排序算法也只算得上一道简单题。</p>
</blockquote>
<span id="more"></span>

<p>排序算法一般可分为 快速排序， 归并排序，插入排序，冒泡排序，选择排序和堆排序。（其中快排，归并和堆排序比较难，但是要掌握）</p>
<h3 id="C-中的std-sort"><a href="#C-中的std-sort" class="headerlink" title="C++中的std::sort"></a>C++中的<code>std::sort</code></h3><p>​    sort算法主体是一个快速排序，快速排序的时间复杂度为<code>O(NlogN)</code>，但是其对效率有了优化。</p>
<p>首先，快速排序在小区间的效率不如插入排序，因此在小空间的话，就用<strong>插入排序</strong>。 而且快速排序是基于递归的，因此如果数据过大，递归层数过大，这就要转入<strong>堆排序</strong> 。</p>
<p>然后，快速排序的效率取决于pivot的取法，如果pivot取得适中，那么效率最高。因此标准库里面用的是<strong>九取一，</strong>这可以尽可能使得pivot的取值更合理。</p>
<h3 id="经典排序模板"><a href="#经典排序模板" class="headerlink" title="经典排序模板"></a>经典排序模板</h3><h4 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.     快速排序"></a>1.     快速排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// key is the pivot element </span></span><br><span class="line">	<span class="keyword">auto</span> first = l, last = r - <span class="number">1</span>, key = nums[first];</span><br><span class="line">	<span class="keyword">while</span>(first &lt; last) &#123;</span><br><span class="line">		<span class="comment">// deal with the element from the last</span></span><br><span class="line">		<span class="keyword">while</span> (first &lt; last &amp;&amp; nums[last] &gt;= key) &#123;</span><br><span class="line">			--last;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// swap and pivot become to the nums[last]</span></span><br><span class="line">		nums[first] = nums[last];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// deal wiht the element from the first</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(first &lt; last &amp;&amp; nums[first] &lt;= key) &#123;</span><br><span class="line">			++first;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// swap </span></span><br><span class="line">		nums[last] = nums[first];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// put the pivot on the correct position, sun first is the division line</span></span><br><span class="line">	nums[first] = key;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// recursion</span></span><br><span class="line">	<span class="built_in">quicksort</span>(nums, l, first);</span><br><span class="line">	<span class="built_in">quicksort</span>(nums, first + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于partition的排序</span></span><br><span class="line"><span class="comment">// algorithms 4th 所实现的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> first = l, last = r+<span class="number">1</span>, key = nums[first];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[++first] &lt; key) &#123;</span><br><span class="line">			<span class="keyword">if</span> (first == r)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (nums[--last] &gt; key) &#123;</span><br><span class="line">			<span class="keyword">if</span> (last == l)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		std::<span class="built_in">swap</span>(nums[first], nums[last]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::<span class="built_in">swap</span>(nums[l], nums[last]);</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (r &lt;= l)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> last = <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">	<span class="built_in">quicksort</span>(nums, l, last - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quicksort</span>(nums, last + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.     归并排序"></a>2.     归并排序</h4><p>方法：采用一个临时空间，将划分成两部分空间在这个临时空间中排好序，然后再放入原空间数组中。</p>
<p>步骤： 先divide，然后recursion， 再deal with。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, vector&lt;<span class="keyword">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l + <span class="number">1</span> &gt;= r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// divide, recursion first</span></span><br><span class="line">	<span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">mergesort</span>(nums, l, m, temp);</span><br><span class="line">	<span class="built_in">mergesort</span>(nums, m, r, temp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// conquer</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> p = l, q = m, i = l;</span><br><span class="line">	<span class="keyword">while</span>(p &lt; m || q &lt; r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q]))</span><br><span class="line">			temp[i++] = nums[p++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			temp[i++] = nums[q++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">		nums[i] = temp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.     插入排序"></a>3.     插入排序</h4><p>这个没什么讲的，反正记得<strong>插入排序是基于<code>swap</code>的</strong>就行</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">void <span class="keyword">insertsort(vector&lt;int&gt; </span>&amp;nums, int n) &#123;</span><br><span class="line">	for(int i=<span class="number">0</span><span class="comment">; i&lt;n; ++i) &#123;</span></span><br><span class="line">		for(int <span class="keyword">j=i; </span><span class="keyword">j&gt;0&amp;&amp; </span>nums[<span class="keyword">j] </span>&lt; nums[<span class="keyword">j-1]; </span>--<span class="keyword">j) </span>&#123;</span><br><span class="line">			<span class="keyword">swap(nums[j], </span>nums[<span class="keyword">j </span>- <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4.    冒泡排序"></a>4.    冒泡排序</h4><p><strong>冒泡排序同样也是基于swap的</strong>，而且为了节省时间，swap途中会有一个bool变量，来判断后续循环是否已经有序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> swapped;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">		swapped = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i; j &lt; n-i+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[j] &lt; nums[j<span class="number">-1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(nums[j], nums[j - <span class="number">1</span>]);</span><br><span class="line">				swapped = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!swapped)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5.     选择排序"></a>5.     选择排序</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">void selection_sort(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">mid</span>;</span><br><span class="line">	for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">n</span> - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="built_in">mid</span> = i;</span><br><span class="line">		for (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">n</span>; ++j) &#123;</span><br><span class="line">			<span class="built_in">if</span> (nums[j] &lt; nums[<span class="built_in">mid</span>]) &#123;</span><br><span class="line">				<span class="built_in">mid</span> = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(nums[<span class="built_in">mid</span>], nums[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.     堆排序"></a>6.     堆排序</h4><p>基本思路：大根堆为例</p>
<p>​    1：建立大根堆—- 将n个元素组成的无序序列构建一个大根堆</p>
<p>​    2：交换堆元素—- 交换堆尾和堆首元素，使堆尾元素成为最大元素</p>
<p>​    3：重建大根堆—- 将前n-1个元素组成的无序序列调整为大根堆（递归）</p>
<p>重复执行2和3 直到整个序列都有序</p>
<p>C++内部实现： 优先队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapadjust</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> right = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> maxIdx = index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left &lt; len &amp;&amp; nums[left] &gt; nums[maxIdx]) maxIdx = left;</span><br><span class="line">	<span class="keyword">if</span> (right&lt; len &amp;&amp; nums[right] &gt; nums[maxIdx]) maxIdx = right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(maxIdx != index) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(nums[maxIdx], nums[index]);</span><br><span class="line">		<span class="built_in">heapadjust</span>(nums, len, maxIdx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// build a heap</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = size / <span class="number">2</span> <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">heapadjust</span>(nums, size, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// adjust the heap</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=size<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">		<span class="built_in">heapadjust</span>(nums, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>总结：手撕排序算法是面试中最基本的技能，不仅要能口头描述出这些排序的用法和效率，还得在面试官需要的时候能够自己写出实现的代码并进行测试。</strong></p>
<p><strong>在这些排序中，最重要的就是堆排序和快速排序。一定要手撕和会用</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>RedisSDS</title>
    <url>/posts/ddef0534/</url>
    <content><![CDATA[<blockquote>
<p>Redis自己构建了一种名为简单动态字符串（SDS）的抽象类型，并将其设置为Redis默认字符串。</p>
</blockquote>
<span id="more"></span>

<h3 id="1-SDS的定义"><a href="#1-SDS的定义" class="headerlink" title="1 SDS的定义"></a>1 SDS的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sds.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存的字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>tag： 由于SDS遵循C字符串以空字符结尾的惯例， 保存空字符的1字节空间不计算在SDS的Len属性里面，并且为空字符自动生成一个字节空间</em></p>
<h3 id="2-SDS和C字符串的区别"><a href="#2-SDS和C字符串的区别" class="headerlink" title="2 SDS和C字符串的区别"></a>2 SDS和C字符串的区别</h3><p>​    由于Redis对字符串在安全性，效率以及功能上都有需求， 因此SDS比传统字符串有着不少优化。</p>
<ul>
<li><p><strong>常数复杂度获取字符串长度</strong></p>
<p>C字符串获取长度靠<code>strlen</code>(O(n)), Redis是靠着<code>sds.len</code>直接获得。</p>
</li>
<li><p><strong>杜绝缓冲区的溢出</strong></p>
<p>C字符串容易造成缓冲区的溢出，而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求。如果不满足，那么就会执行空间扩展工作。</p>
</li>
<li><p><strong>减少修改字符串时带来的内存重分配次数</strong></p>
<ul>
<li><p>C字符串被增长或者缩短时，程序都要对该字符串进行一次内存重分配操作。</p>
</li>
<li><p>针对未使用空间<code>sds.free</code>， SDS解除了字符串长度和底层数组长度之间的关联。从而实现了<strong>空间预分配和惰性空间释放</strong>两种优化策略。</p>
<ul>
<li><p>空间预分配： 当API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序<strong>不仅会为SDS分配修改所必须要的空间，还会分配额外的未使用空间</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配机制</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> <span class="title">sds</span>;</span></span><br><span class="line"><span class="keyword">int</span> needlen;			<span class="comment">// sds字符串需要存储的字符串长度</span></span><br><span class="line"><span class="keyword">if</span>(sds.len &lt; <span class="number">1024</span>*<span class="number">1024</span>)	<span class="comment">// 1024*1024 = 1MB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 分配空间至len</span></span><br><span class="line">    sds.len = needlen;</span><br><span class="line">    sds.<span class="built_in">free</span> = sds.len <span class="comment">// 保持一样</span></span><br><span class="line">    <span class="comment">//so strlen(sds.buf) = len + free + 1;</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    sds.len = needlen;</span><br><span class="line">    sds.<span class="built_in">free</span> = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>惰性空间释放： 用于优化SDS的字符串缩短操作。 API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量纪录起来，并等待将来使用。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>二进制安全</strong></p>
<ul>
<li><p>C字符串中的字符必须符合某种编码(如ASCII),并且<strong>除了字符串的末尾之外，字符串里面不能含有空字符</strong>（这个是因为程序读C字符串遇到空字符就默认这是字符串结尾）。 由于这些限制，<strong>C字符串只能保存文本数据，而不能保存像图片、音频、视频压缩文件这些二进制数据。</strong></p>
</li>
<li><p>SDS中的buf数组，既可以保存一系列字符，也可以保存一系列二进制数据。（其实可以理解为该数组可以保存空字符串，因为长度是已知的，程序不需要通过空字符串的位置判断这个字符串是否结束）</p>
</li>
</ul>
</li>
<li><p><strong>兼容部分C字符串函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">strcat</span>(s_string, sds-&gt;buf);</span><br><span class="line"><span class="comment">// 可以使用str相关的api</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>总结</strong></p>
<ul>
<li>C字符串：<ul>
<li>获取字符串长度的时间复杂度是O(N)</li>
<li>API不安全，可能会造成缓冲区溢出</li>
<li>修改字符串长度N次<strong>必然</strong>需要执行N次内存重分配</li>
<li>只能保存文本数据</li>
<li>可以使用<strong>所有</strong><code>&lt;string.h&gt;</code>的库函数</li>
</ul>
</li>
<li>SDS：<ul>
<li>获取字符串长度的时间复杂度是O(1)</li>
<li>AP安全，不会造成缓冲区溢出</li>
<li>修改字符串长度N次<strong>最多</strong>需要执行N次内存重分配</li>
<li>能保存文本数据和二进制数据</li>
<li>可以使用<strong>一部分</strong><code>&lt;string.h&gt;</code>的库函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-SDS-API"><a href="#3-SDS-API" class="headerlink" title="3 SDS API"></a>3 SDS API</h3><p>​    |       函数        |                                  作用                                     |                          时间复杂度</p>
<ul>
<li><p><code>sdsnew</code>           创建一个包含给定C字符串的SDS                          <code>O(N), N = strlen(str)</code></p>
</li>
<li><p><code>sdsempty</code>       创建一个不包含任何内容的空SDS                        <code>O(1)</code></p>
</li>
<li><p><code>sdsfree</code>         释放给定的SDS                                                       <code>O(N), N = strlen(str)</code></p>
</li>
<li><p><code>sdslen</code>           返回SDS已使用空间字节数                                    <code>O(1), get from sds-&gt;len</code></p>
</li>
<li><p><code>sdsavail </code>       返回SDS未使用空间字节数                                    <code>O(1), get from sds-&gt;free</code></p>
</li>
<li><p><code>sdsdup</code>           创建一个给定SDS的副本(copy)                             <code>O(N), N = strlen(str)</code></p>
</li>
<li><p><code>sdsclear</code>       清空SDS保存的字符串内容                                    <code>O(1), 惰性空间释放策略！</code>  -&gt; <strong>mark</strong></p>
</li>
<li><p><code>sdscat</code>           将给定C字符串拼接到SDS字符串的末尾               <code>O(N)，N = strlen(str) </code></p>
</li>
<li><p><code>sdscatsds</code>     将给定SDS字符串拼接到另一个SDS字符串末尾   <code>O(N)，N = strlen(str)</code></p>
</li>
<li><p><code>sdscpy</code>           <strong>将给定C字符串复制到SDS里面，</strong></p>
<p>​                            <strong>覆盖SDS原有字符串</strong>                                              <code>O(N)，N = strlen(str)</code></p>
</li>
<li><p><code>sdsgrowzero</code>  用空字符将SDS扩展至给定长度                            <code>O(N),N为扩展新增的字节数</code></p>
</li>
<li><p><code>sdsrange</code>       保留SDS给定区间内的数据，</p>
<p>​                        不在区间内的数据会被覆盖或清除                          <code>O(N),N为保留数据的字节数</code></p>
</li>
<li><p><code>sdstrim</code>         接收一个SDS和一个C字符串作为参数，                <code>O(N*M),M为SDS的长度，N为给定C字符串的长度</code></p>
<p>​                        从SDS左右两端分别移除所有在C字符串中出现过的字符   </p>
</li>
<li><p><code>sdscmp</code>           比较两个SDS字符串是否相同                                 <code>O(N), N为两个SDS中较短的那个SDS的长度</code>                </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
