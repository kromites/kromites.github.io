<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客介绍</title>
    <url>/posts/e627a59/</url>
    <content><![CDATA[<blockquote>
<p>欢迎您访问此博客！ 点开阅读全文可了解到博客的基本信息</p>
</blockquote>
<span id="more"></span>

<p>本博客创建于2021.7.1。作为一名22届毕业的学生，目前的主要精力放在找工作上，因此最近上传的大部分是自己的学习笔记。笔记内容涉及到以下几个主要方面：</p>
<ul>
<li>数据结构与算法</li>
<li>计算机网络</li>
<li>操作系统</li>
<li>网络编程</li>
<li>数据库</li>
<li>项目心得</li>
</ul>
<p>希望自己能够在这个夏天拿到心满意足的Offer！</p>
<p>TO BE CONTINUE~</p>
]]></content>
      <categories>
        <category>非技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用</title>
    <url>/posts/4f5d4e8d/</url>
    <content><![CDATA[<blockquote>
<p>本文简单介绍一下操作系统中的系统调用</p>
</blockquote>
<span id="more"></span>

<p>​    在现代操作系统中，内核提供了用户进程与内核进行交互的一组接口。这些接口让应用设备受限地访问硬件设备。这些接口在应用程序和内核中扮演了“使者”的角色，应用程序负责发出各种请求，而内核负责满足这些请求（或者无法满足时返回一个错误）。 这些接口保证了系统稳定可靠，避免应用程序肆意妄行。</p>
<p>​    这些接口的名字叫做系统调用。</p>
<h4 id="与内核通信"><a href="#与内核通信" class="headerlink" title="与内核通信"></a>与内核通信</h4><p>​    系统调用在用户空间和硬件设备之间添加了一个中间层。</p>
<p>​    该层主要作用有三个：</p>
<ul>
<li>它为用户空间提供了一种硬件的抽象接口。</li>
<li>系统调用保证了系统的稳定和安全。内核可以基于权限、用户类型和其他一些规则对需要进行的访问进行裁决。</li>
<li>每个进程都运行在虚拟系统中，如果没有这层安全性公共接口，就无法实现多任务和虚拟内存。</li>
</ul>
<p>系统调用是用户空间访问内核的唯一手段；除异常和陷入之外，它们是内核唯一的合法入口。</p>
<p>​    </p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul>
<li><p>系统调用号</p>
<ul>
<li><p>每个系统调用被赋予了一个系统调用号，这个独一无二的系统调用号指明了到底要执行哪个系统调用。</p>
</li>
<li><p>系统调用号一旦分配就不再改变。</p>
</li>
<li><p>内核在系统调用表中保存着已经注册过得系统调用的列表，存储在<code>sys_call_table</code>中</p>
</li>
</ul>
</li>
<li><p>系统调用性能</p>
<p>设计原则： 简洁、高效。</p>
<p>原因：上下文切换时间很短。</p>
</li>
</ul>
<h4 id="系统调用处理程序"><a href="#系统调用处理程序" class="headerlink" title="系统调用处理程序"></a>系统调用处理程序</h4><ol>
<li><p>什么是系统调用处理程序</p>
<ul>
<li><p>用户空间的程序无法直接执行内核代码。因为内核主流在受保护的地址空间上，不能直接调用内核空间中的函数。</p>
</li>
<li><p>因此应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，希望系统切换到内核态，这样内核态就可以代表应用程序在内核空间执行系统调用。</p>
</li>
<li><p>通知内核的机制是靠<strong>软中断</strong>实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序。<strong>该异常处理程序实质就是系统调用处理程序</strong></p>
</li>
</ul>
<p>总结：用户程序通过异常或者陷入内核，执行系统调用处理程序。</p>
</li>
<li><p>系统调用处理程序中的参数</p>
<p>所有系统调用陷入内核的方式都一样，但是在陷入内核的过程中，用户程序需要把一些参数一并传递给内核。</p>
<ul>
<li>系统调用号：用户空间通过eax寄存器将系统调用号传递给内核。</li>
<li>外部参数：同样也是按照顺序放入<code>ebx, ecx, edx, esi, edi</code>寄存器</li>
<li>返回值： 同样是放在<code>eax</code>寄存器中传递。</li>
</ul>
</li>
</ol>
<h4 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h4><ol>
<li><p>实现系统调用：</p>
<ol>
<li>首先得决定该系统的用途。</li>
<li>原则：用途明确、简介稳定、通用、可移植、健壮。</li>
</ol>
</li>
<li><p>参数验证：</p>
<p>参数合法有效并正确：<strong>不能让内核访问无权访问的资源。</strong></p>
<p>最重要的检查：<strong>检查用户提供的指针是否有效</strong></p>
<p>该指针必须有以下要求：</p>
<ul>
<li>指向的内存区域属于用户空间。</li>
<li>指向的内存区在进程的地址空间里。</li>
<li>指向的内存区在内存的访问权限范围中。</li>
</ul>
<p>最后的检查：<strong>检查用户权限是否合法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span>(!capable(CAP_SYS_BOOT))&#123;</span><br><span class="line">    <span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// CAP_SYS_BOOT：系统调用</span></span><br><span class="line"><span class="comment">// -EPERM: 返回错误。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h4><ol>
<li><p>上下文</p>
<ol>
<li><strong>内核执行系统调用时是在进程上下文。<code>current</code> 指针指向当前任务，即引发系统调用的进程。</strong>    </li>
<li>在进程上下文中，这就意味着内核可以休眠、被抢占。系统调用是可重入的，这样来说也要对同步问题进行关注。</li>
<li>当系统调用返回是，控制权仍在<code>system_call()</code>中，负责切换到用户空间，并让用户进程继续执行下去。</li>
</ol>
</li>
<li><p>绑定系统调用的最后步骤：</p>
<p>最后步骤是把<strong>它注册成一个正式的系统调用</strong>。</p>
<ul>
<li>在系统调用表中加入表项。</li>
<li>系统调用号定义在<code>asm/unistd.h</code>中。</li>
<li>必须被编译进内核内核映像（不能编译到模块中），放入<code>kernel/</code>下的相关文件中。</li>
</ul>
</li>
<li><p>从用户空间访问系统调用。</p>
<p>系统调用靠C库支持，通常对已经有的系统调用，可以直接调用系统调用（或者调用库函数，再由库函数调用系统调用）。但是如果是自己写的系统调用，glibc库恐怕是不支持的。</p>
<p>不过，Linux提供了一组宏，用于直接对系统调用进行访问。它会设置好寄存器并调用陷入指令。</p>
<p><code>_syscalln()</code>：</p>
<ul>
<li><p>n的范围是0-6，代表着传递给系统调用的参数。</p>
</li>
<li><p>对于每个宏来说，都有2+2*n个参数。</p>
<p>第一个参数： 对应系统调用的返回值</p>
<p>第二个参数：系统调用的名称</p>
<p>按照系统调用参数顺序排列的每个参数的类型和名称。</p>
</li>
</ul>
<p>举个例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flags, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> NR_open 5</span></span></span><br><span class="line"><span class="function">_<span class="title">syscall3</span><span class="params">(<span class="keyword">long</span>, open, <span class="keyword">const</span> <span class="keyword">char</span>*, filename, <span class="keyword">int</span>, flags, <span class="keyword">int</span>, mode)</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在本章中，我们描述了</p>
<ul>
<li>系统调用到底是什么？</li>
<li>它们和库函数，API之间又怎么样的关系（API调用库函数，库函数调用系统调用）。</li>
</ul>
<p>然后我们考察了</p>
<ul>
<li>Linux如何实现系统调用</li>
<li>执行系统调用的步骤：陷入内核，传递调用号和参数，执行系统调用函数，把返回值带回用户空间。</li>
</ul>
<p>最后我们讨论了</p>
<ul>
<li>如何写增加一个系统调用？</li>
<li>写系统调用需要注意的是什么？</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>《Linux内核设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>系统调用</tag>
      </tags>
  </entry>
  <entry>
    <title>文件管理</title>
    <url>/posts/ae533703/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/posts/41e39f2b/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>操作系统简介</title>
    <url>/posts/a6fc81d9/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章来简单介绍一下操作系统是什么以及其构成。该文章只是简单介绍，如果</p>
</blockquote>
<span id="more"></span>

<h3 id="简介：什么是操作系统"><a href="#简介：什么是操作系统" class="headerlink" title="简介：什么是操作系统"></a>简介：什么是操作系统</h3><p>现代计算机由处理器，主存，磁盘，键盘鼠标即其它输入输出设备组成。现代计算机系统是一个复杂的系统，由很多硬件组成，为了管理这些硬件，计算机安装了一层软件，称为<strong>操作系统</strong>。</p>
<p>因此操作系统是一个管理计算机的软件。</p>
<table>
<thead>
<tr>
<th>用户态</th>
<th align="center">用户程序</th>
</tr>
</thead>
<tbody><tr>
<td>用户态</td>
<td align="center">用户接口程序</td>
</tr>
<tr>
<td>内核态</td>
<td align="center">操作系统</td>
</tr>
<tr>
<td>硬件</td>
<td align="center">硬件</td>
</tr>
</tbody></table>
<p>从上表中可以看出计算机的大概结构，用户是直接和用户程序打交道的，用户程序然后通过用户接口程序中的系统调用来进入操作系统内核。操作系统内核是负责管理整个系统的核心。内核通过中断来与硬件进行”交流”。这便是计算机系统的基本结构。</p>
<p><strong>启动Linux系统做了什么？</strong></p>
<ol>
<li>BIOS加电自检，对硬件进行检测和初始化</li>
<li>启动第一个扇区，即主引导记录（MBR)，将其读入到一个固定的内存区域并执行一个名为boot的独立程序。</li>
<li>boot程序读取气动设备的根目录，读入操作系统并把控制权交给内核</li>
<li>系统内核运行，配置内核数据结构等。</li>
</ol>
<h3 id="概念：操作系统里的基本概念"><a href="#概念：操作系统里的基本概念" class="headerlink" title="概念：操作系统里的基本概念"></a>概念：操作系统里的基本概念</h3><h4 id="操作系统状态"><a href="#操作系统状态" class="headerlink" title="操作系统状态"></a>操作系统状态</h4><p>首先，操作系统是有状态的，一般是0~3四种状态，但使用的基本上就是用户态（3）和内核态（0）。</p>
<p>用户态和内核态的区别：</p>
<ul>
<li>用户态和内核态的本质区别在于处于这两个状态的程序的权限不同，用户态只能获得有限的权力，不能修改操作系统的配置。</li>
<li>用户态和内核态的地址空间不同，用户态的地址空间为0<del>3G，内核地址空间为3</del>4G（在32bitOS下）。这样也保证了其权限的不同。</li>
</ul>
<h4 id="内核结构"><a href="#内核结构" class="headerlink" title="内核结构"></a>内核结构</h4><p>​    <img src="/posts/undefined/%E5%BE%AE%E5%86%85%E6%A0%B8.png" class title="内核结构"></p>
<p>上图为内核的基本结构，从上图中我们可以得到一些有关内核的基本知识：</p>
<ul>
<li><p>内核落在硬件之上，负责实现与I/O设备和存储管理单元的交互，并控制对前述设备的访问。</p>
</li>
<li><p>内核也分层次。最底层和硬件交互的是<strong>中断和分配器</strong>，同时还存在一个分派机制。分派机制在中断时发生，<strong>底层代码中止正在运行的进程，并且将其状态存储在内核进程结构中</strong>（这就是利用中断来切换进程），然后启动相应的程序。</p>
</li>
<li><p>在中断之上的层次就是三大部件：<strong>I/O部件， 内存管理部件， 进程管理部件</strong></p>
<ul>
<li><p>I/O部件是负责所有与<strong>设备交互</strong>以及实现<strong>联网</strong>和<strong>存储（文件）</strong>的I/O功能的内核部件。在最高层，这些I/O功能全部整合在一个<strong>虚拟文件系统</strong>层中。</p>
</li>
<li><p>在虚拟文件系统下面安装有三个小类，分别对应上一条的设备交互，联网和存储。其中设备交互类有着字符设备驱动和规则。<strong>联网有着网络设备驱动和网络协议以及套接字。存储有着块设备驱动和I/O调度器，文件系统等。</strong></p>
<p>（其中这里的驱动可以理解为对硬件的管理和抽象）</p>
</li>
<li><p>进程管理部件最主要的任务就是<strong>进程的创建和终止</strong>。这里也有进程调度器，负责选择下一步运行哪个进程或线程。（进程和线程都是统一的调度策略）</p>
</li>
<li><p>内存管理部件：<strong>维护好虚拟地址和物理地址的映射关系，维护最近被访问页面的缓存以及实现一个好的页面置换算法并且根据需要把需要的数据和代码页读入内存中。</strong></p>
</li>
</ul>
</li>
<li><p>处在内核最顶层的就是系统调用接口</p>
</li>
</ul>
<p>对于操作系统中的三大部件，我们分别深入到内核中慢慢分析，并作以笔记。下面我们来继续看一看操作系统中的相关概念。</p>
<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>​    进程是操作系统最核心的概念，进程是对正在运行程序中的一个抽象。操作系统其他所有内容都是围绕着进程来展开的。同时，进程也是多道设计程序的基础，通过进程能够在单CPU很容易的实现并行（伪并发）。</p>
<p>进程相关的知识点有</p>
<ul>
<li>进程的数据结构</li>
<li>进程创建运行终止过程</li>
<li>进程状态</li>
<li>进程切换与调度</li>
<li>进程间通信</li>
</ul>
<p>同时，在进程的基础上有了线程，线程的相关知识点有</p>
<ul>
<li>线程的数据结构</li>
<li>线程的实现</li>
<li>线程和进程的区别（优势和特点）</li>
<li>线程同步</li>
</ul>
<p>随着技术的日新月异，现在又在这二者的基础上创建了协程，协程的相关知识点有</p>
<ul>
<li>协程概念</li>
<li>有栈协程和无栈协程</li>
</ul>
<p>目前现在正在看协程相关知识，但是还没有实际运用，所以对于协程来说能有个基本的了解就可以了</p>
<h4 id="内存及内存管理"><a href="#内存及内存管理" class="headerlink" title="内存及内存管理"></a>内存及内存管理</h4><p><strong>内存</strong></p>
<p>内存是计算机系统不可或缺的硬件，一般来说硬件内存分为以下几个部分。</p>
<img src="/posts/undefined/%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" class title="存储层次结构">

<p>顶级的存储器速度最高，但是容量最小，成本也非常高。这里来介绍一下寄存器和高速缓存和主存</p>
<ul>
<li>存储器的顶层是 CPU 中的<code>寄存器</code>，它们用和 CPU 一样的材料制成，所以和 CPU 一样快。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）</li>
<li>位于寄存器下面的是高速缓存，它多数由硬件控制。主存被分割成高速缓存行(cache lines) 为 64 字节，内存地址的 0 - 63 对应高速缓存行 0 ，地址 64 - 127 对应高速缓存行的 1，等等。使用最频繁的高速缓存行保存在位于 CPU 内部或非常靠近 CPU 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是<strong>高速缓存命中</strong>(cache hit)。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。</li>
<li>在上面的层次结构中再下一层是<code>主存</code>，这是内存系统的主力军，主存通常叫做 <code>RAM(Random Access Memory)</code></li>
</ul>
<p><strong>虚拟内存</strong></p>
<p>操作系统一般都支持虚拟内存的机制，这种机制能够使期望运行的存储空间大于机器的物理存储空间。</p>
<p><strong>其方法是将程序放在磁盘上，而将主存作为一部分缓存，去存放那些使用最为频繁的程序。</strong></p>
<p>虚拟内存和物理内存的准换由MMU完成，是通过多级页表结构来实现转换的。</p>
<p>综上可以总结出内存及内存管理的一些知识点</p>
<ul>
<li><p>物理内存的地址空间</p>
</li>
<li><p>物理内存与虚拟内存的转换</p>
</li>
<li><p>虚拟内存的分页，页表</p>
</li>
<li><p>内存的分配算法</p>
</li>
<li><p>slab分配器</p>
</li>
<li><p>缺页中断和页面置换算法</p>
</li>
<li><p>页缓存和页回写</p>
</li>
</ul>
<h4 id="文件系统与I-O设备"><a href="#文件系统与I-O设备" class="headerlink" title="文件系统与I/O设备"></a>文件系统与I/O设备</h4><p>​    文件是由进程创建的逻辑信息单元，可以将每个文件都看做是一个独立的进程地址空间。进程能够读取已经存在的文件，并在需要时重新创建他们。存储在文件中的信息必须是<code>持久的</code>，这也就是说，不会因为进程的创建和终止而受影响。</p>
<p>​    操作系统内核在底层文件系统接口上建立了一个抽象层，该抽象层叫做VFS层，在VFS中，所有底层文件都是相同的，这样能够方便处理和操作</p>
<p>​    其实文件系统内容很多，但是不算是特别重点，以下这些知识点需要了解</p>
<ul>
<li>VFS及VFS对象<ul>
<li>超级块对象</li>
<li>索引节点对象</li>
<li>目录项对象</li>
<li>文件对象</li>
</ul>
</li>
<li>文件相关的数据结构</li>
</ul>
<p>之后就是I/O设备相关的知识</p>
<ul>
<li><p>流设备相关概念</p>
</li>
<li><p>块设备结构</p>
</li>
<li><p>块设备调度程序（linux电梯）</p>
</li>
<li><p>模块</p>
</li>
</ul>
<h3 id="其他：计算机系统中的接口"><a href="#其他：计算机系统中的接口" class="headerlink" title="其他：计算机系统中的接口"></a>其他：计算机系统中的接口</h3><p>在计算机系统分层中，我们了解到了用户态，内核态和硬件。那么操作系统使用什么手段将这些层次进行分层呢？</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>系统调用是用户态访问内核态的唯一手段</p>
<ul>
<li>系统调用的概念</li>
<li>系统调用程序</li>
<li>系统调用上下文</li>
</ul>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>中断是内核和硬件通信的唯一正常手段（异常不是正常手段）</p>
<ul>
<li>中断的概念</li>
<li>中断处理程序</li>
<li>中断上下文</li>
<li>下半部环境</li>
<li>软中断，tasklet和工作队列</li>
</ul>
<h4 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h4><p>同时，现代计算机系统都有多个CPU，在多个CPU中会出现并发操作，这就需要内核同步方法</p>
<ul>
<li>自旋锁</li>
<li>信号量</li>
<li>互斥锁（基于futex）</li>
<li>顺序锁和屏障</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>内核同步是需要防范死锁，死锁也是个重要知识点</p>
<ul>
<li>死锁概念</li>
<li>死锁的条件</li>
<li>如何防范死锁</li>
</ul>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>最后，我们来学习一下内核中的时间概念</p>
<ul>
<li>节拍率</li>
<li>硬时钟与定时器</li>
<li>时钟中断程序</li>
<li>使用定时器</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《现代操作系统》</li>
<li>《Linux内核设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理</title>
    <url>/posts/852cfab6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Redis对象</title>
    <url>/posts/404ab54a/</url>
    <content><![CDATA[<blockquote>
<p>上篇文章介绍了Redis的所有底层数据结构，但是Redis并没有直接使用这些底层数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，每种对象至少用到了一个底层数据结构，本章我们就来了解Redis的对象。</p>
</blockquote>
<span id="more"></span>



<h3 id="对象简介"><a href="#对象简介" class="headerlink" title="对象简介"></a>对象简介</h3><p>Redis对象系统包含 <strong>字符串对象， 列表对象， 哈希对象， 集合对象和有序集合对象</strong>这五种类型的对象。</p>
<p>使用对象的好处：</p>
<ul>
<li>Redis在执行命令之前，可以通过对象的类型来直接判断执行命令的合法性。</li>
<li>针对不同的使用场景，可以为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</li>
<li>Redis对象实现基于<strong>引用计数技术的内存回收机制</strong>。通过该机制可以实现对象共享机制。</li>
<li>Redis的对象带有<strong>访问时间记录信息</strong>，该信息可以用于计算数据库键的空转时长，在服务器启用了<code>maxmemory</code>功能情况下，空转时长较大的键会优先被服务器删除。</li>
</ul>
<h3 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h3><p>​    Redis通过对象来表示数据库中的键和值，因此每当我们创建一个键值对时，至少创建两个对象，一个是键对象，一个是值对象。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> example</span><br><span class="line">redis &gt; <span class="built_in">set</span> msg <span class="string">&quot;hello world&quot;</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">--&gt; key : msg （字符串对象)</span><br><span class="line">--&gt; value: <span class="string">&quot;hello wordl&quot;</span> (字符串对象)</span><br></pre></td></tr></table></figure>

<p>Redis中的每个对象都有一个<code>redisObject</code>结构表示，该结构中和保存数据有关的三个属性分别是type属性，encoding属性和ptr属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">	<span class="comment">// type</span></span><br><span class="line">    <span class="keyword">unsigned</span> type : <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// encode</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding : <span class="number">4</span>; </span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>类型：type类型常量有五种，type为其中一种。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">REDIS_STRING | <span class="type">REDIS_LIST</span> | <span class="type">REDIS_HASH</span> | <span class="type">REEDIS_SET</span> | <span class="type">REDIS_ZSET</span></span><br><span class="line">字符串对象		列表对象		哈希对象	 集合对象		有序集合对象</span><br></pre></td></tr></table></figure>

<p>因此当我们称呼一个<strong>数据库键为“字符串”键</strong>时，我们指的是“<strong>这个数据库键所对应的值为字符串对象</strong>”</p>
</li>
<li><p>编码和底层实现</p>
<p><strong>对象的ptr指针指向对象的底层数据结构，这些数据结构由对象的encoding属性决定。encoding属性记录了对象使用的编码</strong>。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">编码常量				<span class="string">|			编码所对应的底层数据结构</span></span><br><span class="line">REDIS_ENCODING_INT				long类型的整数</span><br><span class="line">REDIS_ENCODING_EMBSTR			embstr编码的的简单动态字符串</span><br><span class="line">REDIS_ENCODING_RAW				简单动态字符串（sds）</span><br><span class="line">REDIS_ENCODING_HT				字典</span><br><span class="line">REDIS_ENCODING_LIKNEDLIST		双端链表</span><br><span class="line">REDIS_ENCODING_ZIPLIST			压缩列表</span><br><span class="line">REDIS_ENCODING_INTSET			整数集合</span><br><span class="line">REDIS_ENCODING_SKIPLIST			跳跃表和字典</span><br></pre></td></tr></table></figure>

<p>每种类型的对象都至少使用了两种不同的编码作为其底层数据结构。即 类型， 编码， 和对象三者有着不同的对应关系</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">类型					|  				编码					|			对象</span><br><span class="line"></span><br><span class="line">REDIS<span class="emphasis">_STRING			REDIS_ENCODING_INT						使用整数值实现的字符串对象</span></span><br><span class="line"><span class="emphasis">REDIS_STRING			REDIS_ENCODING_EMBSTR					使用embstr编码的SDS实现的字符串对象</span></span><br><span class="line"><span class="emphasis">REDIS_STRING			REDIS_ENCODING_RAW						使用SDS实现的字符串对象</span></span><br><span class="line"><span class="emphasis">	</span></span><br><span class="line"><span class="emphasis">REDIS_LIST				REDIS_ENCODING_ZIPLIST					使用压缩列表实现的列表对象</span></span><br><span class="line"><span class="emphasis">REDIS_LIST				REDIS_ENCODING_</span>LIKNEDLIST				使用双端链表实现的列表对象</span><br><span class="line"></span><br><span class="line">REDIS<span class="emphasis">_HASH				REDIS_ENCODING_ZIPLIST					使用压缩列表实现的哈希对象</span></span><br><span class="line"><span class="emphasis">REDIS_HASH				REDIS_ENCODING_</span>HT						使用字典实现的哈希列表</span><br><span class="line"></span><br><span class="line">REEDIS<span class="emphasis">_SET				REDIS_ENCODING_INTSET					使用整数集合实现的集合对象</span></span><br><span class="line"><span class="emphasis">REEDIS_SET				REDIS_ENCODING_</span>HT						使用字典实现的集合对象</span><br><span class="line"></span><br><span class="line">REDIS<span class="emphasis">_ZSET				REDIS_ENCODING_ZIPLIST					使用压缩列表实现的有序集合列表</span></span><br><span class="line"><span class="emphasis">REDIS_ZSET				REDIS_ENCODING_</span>SKIPLIST					使用跳跃表和字典实现的有序集合对象</span><br></pre></td></tr></table></figure>

<p>通过encoding来设定对象所使用的的编码，而不是为特定类型的对象关联一种固定的编码，极大提升了Redis的灵活性和效率，因为Redis可以根据不同的场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。（数据少用一个编码，数据多转换编码）</p>
</li>
</ul>
<p><em>这里介绍下embstr，这个编码方式是专门用于保存的是一个字符串值，并且这个字符串值的长度小于等于39字节。即专门用于保存短字符串的优化编码模式</em></p>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象可以是 <code>int, raw , embstr</code>。 </p>
<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象将整数型保存在ptr中（将void* 设置为long），并将字符串对象的编码设置为int。</p>
<p>至于raw和embstr的选取。embstr我们都知道是一种专门用于保存短字符串的优化编码。</p>
<p>优化原因：</p>
<ul>
<li><p>raw编码会调用两次内存分配函数来分别创建<code>redisObject</code>结构和<code>sdshdr</code>结构，而在embstr只会调用一次内存分配函数，连续空间包括<code>redisObject</code>结构和<code>sdshdr</code>结构。</p>
</li>
<li><p>同样的，释放embstr编码字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次。</p>
</li>
<li><p>因为embstr编码的字符串对象的所有数据都保存在一块连续内存中，<strong>使用缓存会更高效</strong></p>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">		字符串对象保存各类型值得编码方式</span><br><span class="line">	值									|				编码</span><br><span class="line">可以用<span class="keyword">long</span>类型保存的整数							<span class="keyword">int</span></span><br><span class="line">可以用<span class="keyword">long</span> <span class="keyword">double</span>类型保存的浮点数					embstr或者raw</span><br><span class="line">字符串值，或者长度太大的<span class="keyword">long</span>， <span class="keyword">long</span> <span class="keyword">double</span> 		   embstr或者raw</span><br></pre></td></tr></table></figure>

<p>编码的转换：</p>
<p>​    字符串在条件满足的时候，会对编码进行转换。这个很好的理解，但是注意一点： </p>
<p>由于Redis没有为embstr编码的字符串对象编写任何相应的修改程序，所以<strong>embstr编码字符串时只读</strong>的。要想<strong>修改embstr，那么它会先变成Raw编码的字符串对象</strong></p>
<ul>
<li><p>字符串命令的实现</p>
<p>字符串键的值为字符串对象，所以用于字符串键的所有命令都是针对字符串对象来构建的。</p>
<p>字符串命令有： </p>
<ul>
<li><p>SET</p>
</li>
<li><p>GET</p>
</li>
<li><p>APPEND</p>
</li>
<li><p>INCRBYFLOAT</p>
</li>
<li><p>INCRBY</p>
</li>
<li><p>DECRBY</p>
</li>
<li><p>STRLEN</p>
</li>
<li><p>SETRANGE</p>
</li>
<li><p>GETRANGE.</p>
</li>
</ul>
</li>
</ul>
<p>这些命令具体意思和用法都可以参见原书P68页（实在太多了）</p>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码可以是<code>ziplist</code> 或者<code>linkedlist</code>。</p>
<p>用<code>ziplist</code>编码底层数据结构为压缩列表，每个压缩列表节点保存了一个列表元素。</p>
<p>用<code>linkedlist</code>编码的列表对象使用双端链表作为底层实现，<strong>每个双端链表节点保存着一个字符串对象，每个字符串对象里面保存了一个列表元素</strong>。（二者需要区分）</p>
<p>​    <strong>另外，需要注意的是：字符串对象是Redis中五种类型对象中唯一一个能被其他四个对象嵌套的对象。</strong></p>
<ul>
<li><p>编码转换：</p>
<p>当列表对象可以同时满足以下两个条件时，列表对象用<code>ziplist</code>编码。</p>
<ul>
<li>列表对象保存的所有字符串元素长度都小于64字节</li>
<li>列表对象保存的元素数量小于512个</li>
</ul>
<p>如果不满足，那么就会使用<code>linkedlist</code>编码（全部元素都使用）</p>
<p>（注：以上两个条件的上限值是可以修改的，具体请看配置文件说明）</p>
</li>
<li><p>列表命令的实现</p>
<p>因为列表键的值为列表对象，所以用于列表键的所有命令都是针对列表对象构建的。</p>
<p>以下为部分列表建命令</p>
<ul>
<li>LPUSH</li>
<li>RPUSH</li>
<li>LPOP</li>
<li>RPOP</li>
<li>LINDEX</li>
<li>LLEN</li>
<li>LINSERT</li>
<li>LREM</li>
<li>LTRIM</li>
<li>LSET</li>
</ul>
<p>具体的实现方法以后补充</p>
</li>
</ul>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>​    哈希对象的编码可以是<code>ziplist</code>或者 <code>hashtable</code></p>
<p>​    <code>ziplist</code>编码的哈希对象使用<strong>压缩列表</strong>作为底层实现，当有新键值对要加入哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。</p>
<p>​    因此，哈希表在压缩列表中<strong>存储键和值总是挨着的</strong>，并且先添加的键值对离表头更近。</p>
<p>​    <code>hashtable</code>编码的哈希对象使用<strong>字典</strong>作为底层实现，哈希对象的每个键值对都使用一个字典键值对来保存：</p>
<p>字典中的键和值都是字符串对象，对象分别保存了键值对的键和值。</p>
<ul>
<li><p>编码转换</p>
<p>当哈希对象可以同时满足以下两个条件时，哈希对象用<code>ziplist</code>编码。</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节</li>
<li>哈希对象保存的键值对数量小于512个</li>
</ul>
</li>
</ul>
<p>如果不满足，那么就会使用<code>hashtable</code>编码（全部元素）</p>
<p>（注：以上两个条件的上限值是可以修改的，具体请看配置文件说明）</p>
<ul>
<li><p>哈希命令的实现</p>
<p>因为哈希建的值为哈希对象，所以用于哈西家你的所有命令都是针对哈希对象和来构建的</p>
<p>哈希命令：</p>
<ul>
<li>HSET</li>
<li>HGET</li>
<li>HEXISTS</li>
<li>HDEL</li>
<li>HLEN</li>
<li>HGETALL</li>
</ul>
</li>
</ul>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>​    集合对象的编码可以使<code>intset</code> 或者<code>hashtable</code></p>
<p><code>intset</code>编码的集合对象使用<strong>整数集合</strong>作为底层实现，集合对象的所有元素都保存在整数集合里面。</p>
<p><code>hashtable</code>编码的集合对象使用<strong>字典</strong>作为底层实现，字典的每个键都是一个字符串，每个字符串包含了一个集合元素，而字典的值全部设置为NULL。</p>
<ul>
<li><p>编码转换</p>
<p>当列表对象可以同时满足以下两个条件时，列表对象用<code>intset</code>编码。</p>
<ul>
<li>集合对象保存的所有元素都是整数值</li>
<li>结合对象保存的元素数量小于512个</li>
</ul>
<p>如果不满足，那么就会使用<code>hashtable</code>编码（全部元素都使用）</p>
<p>（注：以上第二个条件的上限值是可以修改的，具体请看配置文件说明）</p>
</li>
<li><p>集合命令的实现</p>
<p>因为集合键的值为集合对象，所有用于集合间的所有命令都是针对集合对象构建的。</p>
<p>集合命令的实现方法</p>
<ul>
<li>SADD</li>
<li>SCARD</li>
<li>SISMEMBER</li>
<li>SMEMBERS</li>
<li>SRANDMEMBER</li>
<li>SPOP</li>
<li>SREM</li>
</ul>
</li>
</ul>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>​    有序集合的编码可以是<code>ziplist</code>或者<code>skiplist</code></p>
<p>​    <code>ziplist</code>编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值。</p>
<p>​    压缩列表的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的位置，而分值较大的元素则被放置在靠近表尾的位置。</p>
<p>​    <code>skiplist</code>编码的有序集合对象使用<code>zset</code>结构作为底层实现，一个<code>zset</code>结构同时包含<strong>一个字典和一个跳跃表</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    <span class="comment">// 跳跃表部分</span></span><br><span class="line">    <span class="comment">// zsl跳跃表按分值从小到大保存了所以集合元素，每个跳跃表节点都保存了一个集合元素：</span></span><br><span class="line">    <span class="comment">// 跳跃表节点的object属性保存了元素成员，score属性保存了元素的分值。</span></span><br><span class="line">    zskiplist* zsl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字典部分</span></span><br><span class="line">    <span class="comment">// dict字典为有序集合创建了一个从成员到分值的映射，每个键值对都保存着集合元素，这保证O（1）复杂度找到</span></span><br><span class="line">    <span class="comment">// 给定成员的分值</span></span><br><span class="line">    dict* dict;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><code>zset</code>结构同时使用跳跃表和字典来保存有序集合</strong>，这两种数据结构都会通过指针来共享相同的成员和分值，所以同时使用<strong>两个结构保存集合元素不会产生任何重复成员或分值，也不会因此浪费额外内存</strong>。</p>
<p>为何要同时使用两种结构？ 是为了我们将两种优点集齐。字典能够O(1)复杂度查找成员分值，而字典是无序的，<code>skiplist</code>能够实现有序集合。</p>
<ul>
<li><p>编码转换</p>
<p>当有序集合对象可以同时满足以下两个条件时，列表对象用<code>ziplist</code>编码。</p>
<ul>
<li>有序集合对象保存的所有元素长度都小于64字节</li>
<li>有序集合保存的元素数量小于128个</li>
</ul>
<p>如果不满足，那么就会使用<code>skiplist</code>编码（全部元素都使用）</p>
<p>（注：以上两个条件的上限值是可以修改的，具体请看配置文件说明）</p>
</li>
</ul>
<ul>
<li><p>有序集合命令的实现</p>
<p>因为有序集合键的值为有序集合对象，所有用于有序集合键的所有命令都是针对有序集合对象来构建。</p>
<p>有序集合命令：</p>
<ul>
<li>ZADD</li>
<li>ZCARD</li>
<li>ZCOUNT</li>
<li>ZRANGE</li>
<li>ZREVRANGE</li>
<li>ZRANK</li>
<li>ZREVRANK</li>
<li>ZREM</li>
<li>ZSCORE</li>
</ul>
</li>
</ul>
<h3 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h3><p>Redis用于操作间的命令基本上可以分为两种类型。</p>
<p>其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令。</p>
<p>另一种命令只能对特定类型的键执行。就相当于前面的一些命令。</p>
<ul>
<li><p>类型检查的实现</p>
<p>类型特定命令所进行的类型检查是通过<code>redisObject</code>结构的<code>type</code>属性来实现的：</p>
<ul>
<li>执行命令前，服务器检查输入数据库键的值对象是否为执行命令所需的类型，是的话，服务器执行指定命令</li>
<li>否则，拒绝执行命令，并向客户端返回一个类型错误。</li>
</ul>
</li>
<li><p>多态命令的实现</p>
<p>多态命令分为两种，一种是DEL这种，基于类型多态——一个命令可以同时用于处理多种不同类型的<strong>键</strong>。而LLEN这种是基于编码的多态——一个命令可以同时用于处理多种不同的<strong>编码</strong>。</p>
</li>
</ul>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>​    C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个<strong>引用计数</strong>（这里的引用计数就是shared_ptr 所实现的技术),这里就不赘述。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>除了实现引用计数内存回收机制之外，引用计数属性还能带来对象共享作用。</p>
<p>在Redis中，让多个键共享同一个值对象需要执行一下两个步骤：</p>
<ul>
<li><strong>将数据库键的值指针指向一个现有的值对象</strong></li>
<li><strong>将被共享的值对象引用计数增一</strong></li>
</ul>
<p>共享对象机制对于节约内存非常有用，数据库中保存的相同值对象越多，对象共享机制就能节约越多的内存。</p>
<p>但是，Redis只能共享<strong>整数值对象</strong>，字符串的对象不共享。因为验证共享对象和目标对象是否相同是需要复杂度的，在整数值对象中复杂度是O(1), 在字符串对象就是O(N),因此为了CPU的考虑，所有只对整数值的字符串对象进行共享。</p>
<h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//引用计数</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru : <span class="number">22</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空转时长是通过将<strong>当前时间减去键的值对象的LRU时间计算得出的</strong>。</p>
<h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul>
<li>Redis数据库每个键值对的键和值都是一个对象</li>
<li>Redis共有字符串，列表，哈希，集合，有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型</li>
<li>Redis的对象系统带有引用计数实现内存回收机制，当一个对象不在被使用时，该对象所占用的内存就会被自动释放。</li>
<li>Redis会共享值为0-9999的字符串对象</li>
<li>对象会记录自己最后一次被访问的时间，这个时间可以用于计算对象的空转时间。</li>
</ul>
<p>这些也是Redis为何不直接用底层结构而是用一层对象进行包装的原因——能够在各个方面更好的管理数据。这些方面有</p>
<ul>
<li>命令判定</li>
<li>内存回收</li>
<li>引用计数</li>
<li>时间记录</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《Redis设计与实现》</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>计网层次模型</title>
    <url>/posts/7e9a112b/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章简要介绍了一下计算机网络的分层模型以及两个分层之间的</p>
</blockquote>
<h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>计算机网络的体系结构是通过分层来展示的，目前来说一般有两种分层模型</p>
<ul>
<li>OSI七层模型</li>
<li>TCP/IP四层模型</li>
</ul>
<img src="/posts/7e9a112b/%E5%B1%82%E6%AC%A1%E5%8D%8F%E8%AE%AE.png" class title="层次模型">



<h4 id="OSI层次"><a href="#OSI层次" class="headerlink" title="OSI层次"></a>OSI层次</h4><p>① 应用层</p>
<p>应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用。该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。在应用层交互的数据单元我们称之为<strong>报文</strong>。</p>
<p>② 表示层</p>
<p>表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。<strong>该层提供的服务主要包括数据压缩，数据加密以及数据描述。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异</strong>。</p>
<p>③ 会话层</p>
<p><strong>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法</strong>。</p>
<p>④ 传输层</p>
<p>传输层的主要任务是为<strong>两台主机进程之间的通信提供服务。应用程序利用该服务传送应用层报文。</strong>该服务并不针对某一特定的应用，多种应用可以使用同一个传输层服务。由于一台主机可同时运行多个线程，因此传输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面传输层的服务，分用和复用相反，是传输层把收到的信息分别交付上面应用层中的相应进程。</p>
<p>⑤ 网络层</p>
<p>两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。<strong>网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送</strong>。在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。</p>
<p>⑥ 数据链路层</p>
<p>数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。</p>
<p>⑦ 物理层</p>
<p>作为 OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。</p>
<h4 id="TCP-IP层次"><a href="#TCP-IP层次" class="headerlink" title="TCP/IP层次"></a>TCP/IP层次</h4><p>① 应用层</p>
<p>TCP/IP 模型将 <strong>OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现</strong>，通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP 等。</p>
<p>② 传输层</p>
<p>该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。<strong>传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）</strong>。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</p>
<p>③ 网际互联层</p>
<p>网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。<strong>除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP</strong>）。（ICMP用在ping上，IGMP用在多播广播上）</p>
<p>④ 网络接入层</p>
<p>网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。</p>
<p>一般来说，作为一个编写代码的普通程序员，最低层次了解到网络层就可以了，本文的重点是在传输层。</p>
<h4 id="二者异同"><a href="#二者异同" class="headerlink" title="二者异同"></a>二者异同</h4><ul>
<li>相同点：<ul>
<li>都是分层模型</li>
<li>都能提供无连接和有链接两种通信服务机制</li>
</ul>
</li>
<li>不同点：<ul>
<li>前者是七层模型，后者是五层模型</li>
<li>OSI先有模型后有规范，TCP是先有的协议族，在有的模型。</li>
<li>前者看起来虽好，但是难以实现，后者实现起来比较方便。</li>
</ul>
</li>
</ul>
<h4 id="为什么表示层和传输层在TCP被去掉了"><a href="#为什么表示层和传输层在TCP被去掉了" class="headerlink" title="为什么表示层和传输层在TCP被去掉了"></a>为什么表示层和传输层在TCP被去掉了</h4><ul>
<li>TCP是基于协议的，表示层的功能是对数据进行压缩处理，会话层是维持会话建立，这些都太抽象了，不好封装成协议</li>
<li>其实表示层和会话层的功能都是在应用程序里面的，应用程序之中几乎无法实现代码抽象，因此不容易被分层。</li>
</ul>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><p><a href="https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/">https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/</a></p>
</li>
<li><p>《TCP/IP详解》 卷一</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>层次模型</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程基础</title>
    <url>/posts/adcb768c/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍一些网络编程的基础知识，如socket介绍，一个完整的ECHO服务器该如何写？至于之后的项目提升，会在之后的文档中再做总结。</p>
</blockquote>
<span id="more"></span>



<h3 id="Socket地址API"><a href="#Socket地址API" class="headerlink" title="Socket地址API"></a>Socket地址API</h3><h4 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h4><p>字节序就是字节在内存中排列的顺序，在计算机中主机上的字节序和网络中的字节序是不一样的，<strong>字节序分为大端和小端，指的是低地址存储的是高位字节还是低位字节</strong>。</p>
<ul>
<li>主机字节序：小端字节序，低位地址存储的是低位字节。</li>
<li>网络字节序：大端字节序，低位地址存储的是高位字节。</li>
</ul>
<p>这样的话，在网络编程中，接收和发送这两个过程都需要将字节序转换。</p>
<p>linux中提供以下四个函数来完成主机字节序和网络字节序之间的转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*	这组函数命名就能看出来，特别简单明了。 </span></span><br><span class="line"><span class="comment">*	在发送的时候需要调用hton,在接收的时候需要调用ntol。</span></span><br><span class="line"><span class="comment">*	至于long和short </span></span><br><span class="line"><span class="comment">*		一般来说转换IP地址使用long</span></span><br><span class="line"><span class="comment">*		转换端口使用short</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="通用Socket地址"><a href="#通用Socket地址" class="headerlink" title="通用Socket地址"></a>通用Socket地址</h4><p>socket网络编程接口中表示socket地址结构体为<code>sockaddr</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">  	<span class="keyword">sa_family_t</span> sa_family;	<span class="comment">// 地址族，一般和协议族相对应——UNIX,IPV4,IPV6</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];		<span class="comment">// socket地址值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个通用的socket地址一般来说不好用，比如设置与获取IP地址和端口号就需要执行繁琐的位操作，所以Linux提供了一组socket结构体。称之为Linux专用Socket地址。</p>
<h4 id="Linux专用Socket地址"><a href="#Linux专用Socket地址" class="headerlink" title="Linux专用Socket地址"></a>Linux专用Socket地址</h4><p>专用地址将Unix，IPv4和IPv6三个分开来了，在这里我们只介绍一下IPv4</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">  	<span class="keyword">sa_family_t</span> sin_family;		<span class="comment">// 地址族：AF_INET</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin_port;			<span class="comment">// 端口号，需要网络字节序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>	<span class="comment">// IPv4地址结构体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">    <span class="keyword">u_int34_t</span> s_addr;			<span class="comment">// IPv4地址，要用网络字节序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个专用地址的各字段含义已经足够明确。只不过需要注意的是，使用这个专用的地址仍需要转变成通用地址<code>sockaddr</code>, 因为所有socket编程接口使用的地址参数的类型都是<code>sockaddr</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 项目中的代码 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Address.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">sockaddr* <span class="title">getAddr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;sockaddr*&gt;(&amp;sockaddr_);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sockaddr_in sockaddr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h4><p>一般人们习惯使用可读性好的字符串来表示IP地址，比如使用点十分制来表示IPv4的地址。而编程中我们必须将其转换成整数（二进制）才能使用。因次这里有几个函数能够将点十分字符数组和网络字节序整数相转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strptr)</span></span>;			<span class="comment">// 将字符数组转化成 网络字节序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp, struct in_addr* inp)</span></span>;	</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;					<span class="comment">// 将 in_addr 地址转变成字符数组</span></span><br></pre></td></tr></table></figure>



<h3 id="Socket基础API"><a href="#Socket基础API" class="headerlink" title="Socket基础API"></a>Socket基础API</h3><p>上一单元介绍Socket地址相关的API，之后就要正式使用socket了。</p>
<p>在Linux中一切皆文件，socket也不例外，因此<strong>socket就是一个可读可写可关闭可控制的文件描述符</strong>。</p>
<h4 id="创建Socket"><a href="#创建Socket" class="headerlink" title="创建Socket"></a>创建Socket</h4><p>Linux通过<code>socket</code>系统调用来创建一个套接字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">*	domain : 使用哪个底层协议族 </span></span><br><span class="line"><span class="comment">*	type: 指定服务类型，一般有两种服务类型 stream 和 ugram （对应着TCP的字节流和UDP的数据包）</span></span><br><span class="line"><span class="comment">*	protocol： 在两个参数下，再选择具体的协议，一般默认为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in Socket.cpp :IPv4 ，字节流 | 非阻塞 | 调用fork关闭socket</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> res = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h4 id="命名Socket"><a href="#命名Socket" class="headerlink" title="命名Socket"></a>命名Socket</h4><p>创建socket之后，我们需要将一个socket和socket地址绑定，这称为socket命名。命名采用的是以下的系统调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">*	feature：该函数将my_addr所指的socket地址分配给未命名的sockfd文件描述符，addrlen参数指的是该socket地址的长度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// in Socket.cpp : 将socket地址与监听描述符绑定，之后这个监听描述符就代表socket</span></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">bind</span>(listenfd, addr.<span class="built_in">getAddr</span>(), addr.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>

<p>在bind的时候容易遇到一个error：98（被绑定的地址正在使用），这是因为处于Time_wait状态，还没有完全释放该地址。</p>
<h4 id="监听Socket"><a href="#监听Socket" class="headerlink" title="监听Socket"></a>监听Socket</h4><p>socket被命名之后，还不能马上接收客户连接，我们需要<strong>使用<code>listen</code>系统调用来创建监听队列以存放待处理的客户连接</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> socketfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// socketfd = listenfd 套接字的文件描述符，backlog为创建的监听队列长度。</span></span><br><span class="line"><span class="comment">// in Socket.cpp </span></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">listen</span>(listenfd, maxLength);</span><br></pre></td></tr></table></figure>

<p><strong>backlog是参数提示内核监听队列的最大长度。如果监听队列的长度超过backlog，那么服务器将不再受理新的客户连接，客户端也将收到<code>ECONNREFUSED</code>的错误信息。注意这个客户连接是处于<code>ESTABLISHED</code>状态的。</strong></p>
<p>再通俗易懂的解释一下，就是在这个服务器上总共最多只能有backlog个连接处于ESTABLISHED状态。</p>
<h4 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h4><p>下面系统调用从listen监听队列中接收一个连接，这个函数是socket基础API中的重头戏。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* feature： 其参数唯一表示一个socket，返回的int是该连接的文件描述符，之后会对该文件描述符进行操作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> connfd = <span class="built_in">accept</span>(sockfd, addr.<span class="built_in">getAddr</span>(), &amp;addrlen);</span><br></pre></td></tr></table></figure>

<p><strong>accept的功能只是通过socket从监听队列中取出连接，而不论连接处于何种状态（如established和close_wait），也不关心任何网络情况。</strong></p>
<p>这个功能有两层意义</p>
<ul>
<li>一般来说从监听队列中取出的连接，其状态为established，但是如果这个时候突然断开连接，成为close_wait，accept也依旧能取出来，它只是做一个取的动作，而不检查其状态是否正常。</li>
<li>不关心任何网络情况：一般来说很多人会以为accept是接收一个连接，完成三次握手，这是错误的！在进入监听队列的时候三次握手已经完成了，不然状态怎么可能为established，三次握手是内核自发完成的，用户系统调用无法干涉，因此accept只是个系统调用——在用户态进入内核，将内核中的连接取出，返回用户态时将连接文件描述符一并带出。</li>
</ul>
<h4 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h4><p>如果说服务器通过listen调用来被动接受连接，那么客户端需要使用<code>connect</code>主动与服务器建立连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// feature: 通过sockfd和sockaddr唯一标识一个socket，然后通过这个socket主动建立连接。</span></span><br><span class="line"><span class="comment">// 			一旦建立链接，那么sockfd唯一标识该连接并返回0，如果失败返回-1并设置errno</span></span><br></pre></td></tr></table></figure>

<p>发起连接是客户端的事情，如果做服务器开发其实只是了解即可。</p>
<h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><p>关闭连接实际上就是关闭该连接对应的socket，一般有两种关闭方式</p>
<p>第一种方式就是使用close像关闭文字描述符的时候直接关闭它，不过fd是有引用计数的，close只不过是将fd的引用计数减1，当减为0才会关闭。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注意默认情况下close是立即关闭，如果关闭时还有数据要传送该怎么办？有一个SO_LINGER选项，能够延迟关闭时间。</p>
<p>第二种方式是一种优雅关闭连接，使用shutdown系统调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br><span class="line"><span class="comment">// howto :  SHUT_RD, SHUT_WR, SHUT_RDWR</span></span><br></pre></td></tr></table></figure>

<p>该系统调用能够分别关闭socket上的读或写，或者都关闭，但是这个关闭只是关闭了通道，并没有释放文件描述符。</p>
<h4 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h4><p>数据读写直接使用read和write。这里就不再赘述。</p>
<h3 id="Socket选项"><a href="#Socket选项" class="headerlink" title="Socket选项"></a>Socket选项</h3><p>socket选项有很多，值得注意的是为socket设置选项的时间一般是有要求的。</p>
<ul>
<li>服务端设置选项需要在<code>listen</code>之前</li>
<li>客户端设置选项需要再<code>connect</code>之前</li>
</ul>
<p>原因是这两个函数启动之后就直接进行三次握手了，设置选项需要在这之前，以下是设置选项的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">const</span> <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span>* option_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sockfd表明指定的socket</span></span><br><span class="line"><span class="comment">// level指定要操作哪个协议的选项（即属性） -&gt; SOL_SOCKET, IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP</span></span><br><span class="line"><span class="comment">// option_xxx 所选选项的信息</span></span><br></pre></td></tr></table></figure>

<p>接下来我们来看看常见的选项。</p>
<h4 id="SO-REUSEADDR选项"><a href="#SO-REUSEADDR选项" class="headerlink" title="SO_REUSEADDR选项"></a><code>SO_REUSEADDR</code>选项</h4><p>之前我们讨论过TIME_WAIT状态，如果关闭服务器重启的话，可能会出现errno 98。这是因为socket地址还没有释放。使用这个选项的话能够让强制使用这个socket地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSERADDR, &amp;reuse, <span class="built_in"><span class="keyword">sizeof</span></span>(reuse));</span><br></pre></td></tr></table></figure>

<h4 id="SO-RCVBUF和SO-SNDBUF选项"><a href="#SO-RCVBUF和SO-SNDBUF选项" class="headerlink" title="SO_RCVBUF和SO_SNDBUF选项"></a><code>SO_RCVBUF</code>和<code>SO_SNDBUF</code>选项</h4><p>​    两个选项分别表示TCP接收缓冲区和发送缓冲区的大小，一般来说接收缓冲期的最小值为256字节，而发送期的最小值为2048个字节。这两个选项的目的是想扩大内核中的接收/发送缓冲区，这样确保TCP连接用于足够的空闲缓冲区来处理拥塞。</p>
<h4 id="SO-RCVLOWAY和SO-SNDLOWAT选项"><a href="#SO-RCVLOWAY和SO-SNDLOWAT选项" class="headerlink" title="SO_RCVLOWAY和SO_SNDLOWAT选项"></a><code>SO_RCVLOWAY</code>和<code>SO_SNDLOWAT</code>选项</h4><p>​    两个选项分表表示接收缓冲区和发送缓冲区的低水位标记。低水位标记是被用于I/O多路复用中判断该socket是否可读或可写，如果缓冲区内可读/可写数据超过了低水位，那么I/O复用系统就会将该事件通知给应用程序说明该socket已经有数据可读/可写了。</p>
<p>​    一般默认的话，低水位标记都为1字节</p>
<h4 id="SO-LINGER选项"><a href="#SO-LINGER选项" class="headerlink" title="SO_LINGER选项"></a><code>SO_LINGER</code>选项</h4><p>​    该选项是用于控制close系统调用在关闭TCP连接时的行为。</p>
<p>​    默认情况下，当我们使用close关闭一个socket时，close会立即返回，<strong>TCP模块负责把该socket对应的TCP缓冲区中残留的数据发送给对方。</strong></p>
<p>​    设置该选项时我们需要为socket传递以下结构体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l_onoff;		<span class="comment">// 0 - 关闭该选项，非0 - 开启该选项</span></span><br><span class="line">    <span class="keyword">int</span> l_linger;		<span class="comment">// 滞留时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据这两个成员变量不同值，close能产生以下行为。</p>
<ul>
<li><code>l_onoff</code>等于0。close使用默认情况关闭socket</li>
<li><code>l_onoff</code>非0，<code>l_linger</code>等于0。 close调用依旧立即返回，不过此时是直接丢弃socket对应的TCP发送缓冲区中的残留数据，同时给对方发送一个RST。这为服务器提供了异常终止一个连接的方法。</li>
<li><code>l_onoff</code>非0，<code>l_linger</code>大于0。此时如果是阻塞的，那么必须等待<code>l_linger</code>时间才能发送并确认，如果不阻塞，将TCP发送完收到确认即可。</li>
</ul>
<h3 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h3><p>socket地址的两大要素：端口和IP地址都是用数值表示，这里有些能够直接记录网络信息的API,这些不是重点，在需要的时候查就行了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    本文记录了一些网络编程的基础知识，在最开始看的时候也觉得全是一些API，这些API都要使用过才能体会到它们的用处和原理。做笔记的时候已经将webserver做完了，这个时候来看这些东西确实很基础，但是在回顾的时候也可以借此机会进行code reveiw，这样能够对套接字编程会有进一步的了解。</p>
<p>​    下一篇相关文章就开始对整个web服务器进行介绍，来探讨一下reactor模型。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《UNP》</li>
<li>《APUE》</li>
<li>《Linux高性能服务器编程》</li>
</ul>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/posts/24cb124c/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章主要介绍一下传输层的常见知识点，比如UDP的基本介绍，TCP的重点介绍。</p>
</blockquote>
<span id="more"></span>

<p>[TOC]</p>
<hr>
<h3 id="UDP相关"><a href="#UDP相关" class="headerlink" title="UDP相关"></a>UDP相关</h3><h4 id="UDP定义"><a href="#UDP定义" class="headerlink" title="UDP定义"></a>UDP定义</h4><p>UDP是一个保留消息边界的<strong>尽力而为的无连接的数据报协议</strong>，协议号为17。其基本特点有三个：</p>
<ul>
<li><p><strong>尽力而为，不可靠</strong>：UDP是一种尽力而为的协议，不保证可靠性，毕竟没有连接的约束，也没有差错纠正。</p>
</li>
<li><p><strong>无连接</strong>：在传输数据之前两端不需要建立链接</p>
</li>
<li><p><strong>数据报</strong>：UDP发送的是数据单元叫做数据报，数据报就是应用程序生成的报文加一个只有<strong>八字节的报文头。</strong>数据报不拆分也不合并，应用程序怎么给我，对方收到的也是同样的。</p>
</li>
</ul>
<p>由于这两个基本特点，衍生出了一些常见的特点：</p>
<ul>
<li><strong>开销小，传输快</strong>：头部只有八字节，又不需要连接和拆分，因此开销和传输都有优势。</li>
<li><strong>传输内容不长</strong>：因为UDP是完整的数据报，那么其传输的内容会被限制在这个数据报中，所以传输有限。</li>
<li><strong>只提供差错检测，不提供差错纠正</strong>：因为头部只有8bytes，只会简单CRC校验，如果出错直接扔。</li>
<li><strong>吞吐量不受传输层的拥塞控制算法影响</strong>：其传输速度在传输层仅仅是受应用程序生成数据的速度，计算机的能力和传输带宽的限制，在接收端只是受应用程序从队列中读取消息段的速度限制。</li>
</ul>
<h4 id="UDP应用场景"><a href="#UDP应用场景" class="headerlink" title="UDP应用场景"></a>UDP应用场景</h4><p>UDP的应用场景很简单，完全取决于其两个特点。</p>
<ul>
<li><strong>多播广播</strong>：由于传输数据不建立连接，因此不需要维护连接状态，这样一来可以轻松在同一台服务器上对多个客户机传输相同的信息。</li>
<li><strong>DHCP，DNS，视频语音等应用</strong>：这些应用（协议）都使用了UDP，因为它们都对<strong>传输速度有要求</strong>。不过后面两个还是用到了TCP，这个是为了对传输内容长度和可靠性而考虑，毕竟TCP传输的东西更多，也更可靠。</li>
</ul>
<p>注意</p>
<ul>
<li>ping是使用ICMP协议，他和上层的TCP和UDP都无任何关系。</li>
</ul>
<h4 id="UDP优缺点"><a href="#UDP优缺点" class="headerlink" title="UDP优缺点"></a>UDP优缺点</h4><p>UDP的优缺点都很明显，全部在上面的特点中展现出来了。</p>
<p>优点：</p>
<ul>
<li>简单，开销小，速度快，适用于多播广播。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不可靠，传输内容少，没有差错检测，而且如果链路复杂丢包率会很高。</li>
</ul>
<h3 id="TCP相关"><a href="#TCP相关" class="headerlink" title="TCP相关"></a>TCP相关</h3><h4 id="TCP与UDP的差别"><a href="#TCP与UDP的差别" class="headerlink" title="TCP与UDP的差别"></a>TCP与UDP的差别</h4><p>好，又到了我最喜欢的差别环节，通过这个差别完全可以理解TCP是什么。</p>
<p>TCP是<strong>可靠的面向连接的字节流</strong>协议，协议号为6。同样的，其基本特点有三个：</p>
<ul>
<li><p><strong>可靠性</strong>：TCP是可靠的，它能够保证数据一定能够传输到对面，可靠性的基础是<strong>ACK重传机制</strong>。</p>
</li>
<li><p><strong>面向连接</strong>：TCP在传输数据之前需要建立端到端的连接，建立链接时需要进行三次握手，释放链接时需要四次挥手。不过因为其面向连接，因此在连接建立和解除的时候需要注意大量的细节，这些细节放在后面讲。</p>
</li>
<li><p><strong>字节流</strong>：TCP传输的是可分割的字节流数据，而不是像UDP一样直接发送整个数据报过去，这样可以保证其发送的应用数据长度不受限制。但是TCP必须在发送端进行切片，在接收端进行重组，如果处理不当，就可能产生“粘包”问题。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否面向连接</th>
<th>传输可靠性</th>
<th>传输形式</th>
<th>传输效率</th>
<th>所需资源</th>
<th>应用场景</th>
<th>首部字节</th>
</tr>
</thead>
<tbody><tr>
<td>TCP</td>
<td>是</td>
<td>可靠</td>
<td>字节流</td>
<td>慢</td>
<td>多</td>
<td>文件传输，邮件传输</td>
<td>20-60</td>
</tr>
<tr>
<td>UDP</td>
<td>否</td>
<td>不可靠</td>
<td>数据报</td>
<td>快</td>
<td>少</td>
<td>即时通讯，域名转换</td>
<td>8</td>
</tr>
</tbody></table>
<h4 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h4><p>TCP报文头部是<strong>20个字节固定头部再加至多40个字节的TCP选项</strong>。</p>
<img src="/posts/24cb124c/TCP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" class title="TCP报文格式">

<p><strong>固定头部：</strong></p>
<p>​    从上图中，可以看出来TCP头部的组成部分。</p>
<ul>
<li><p>端口：源端口和目的端口，再加上IP头部的源IP和目的IP，唯一地标识着一个连接。</p>
</li>
<li><p>序列号和确认号：</p>
<ul>
<li><strong>序列号标识着这个字节流的序列，也是该报文段的第一个字节。</strong></li>
<li><strong>确认号是最后成功被标识的序列号，也是期待收到的下一个序列号。</strong></li>
</ul>
</li>
<li><p>头部长度：因为长度是在20-60之间，所以要有个头部长度进行标识。</p>
</li>
<li><p>位字段：</p>
<ul>
<li>SYN: <strong>当一个连接启动时，发的第一个报文段叫做SYN报文段。</strong></li>
<li>ACK: 确认字段，一般连接开启都是启用状态</li>
<li>RST：充值连接（连接取消，经常是因为错误）</li>
<li>URG：紧急字段，用于传输带外数据</li>
<li>FIN：该报文的发送方不会再给对方发送数据，但是可能会发送ACK，参见四次挥手第一次和第三次会发送FIN。</li>
</ul>
</li>
<li><p>窗口大小：主要用于 <strong>TCP 流量控制</strong>。该字段用来告诉发送方其窗口（缓冲区）大小，以此控制发送速率，从而达到流量控制的目的。</p>
</li>
<li><p>校验和：进行TCP校验，如果出现差错，那么接收方会丢弃该报文。</p>
</li>
</ul>
<p><strong>选项：</strong></p>
<p>​    一般为空，但是在下面的情况下有用：</p>
<ul>
<li><p><strong>TCP 连接初始化时，通信双方确认最大报文长度。</strong>（这个也能完美解决粘包问题）</p>
</li>
<li><p>在高速数据传输时，可使用该选项协商<strong>窗口扩大因子</strong>。</p>
</li>
<li><p><strong>作为时间戳时，提供一个较为精准的RTT</strong>，主要为了更好的实现 TCP拥塞控制协议。</p>
</li>
<li><p>修改MSS，最大保温段长度。</p>
</li>
<li><p>认证选项，生成通信密钥加强连接安全性</p>
</li>
</ul>
<p><strong>总结</strong>：</p>
<p>​    直接看一个TCP报文是记不住任何东西的，必须得让TCP报文中的各个部分和实际的功能结合在一起，这样就能够理解TCP报文为何如此设计了。</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>三次握手流程：</p>
<img src="/posts/24cb124c/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" class title="三次握手">

<p>三次握手相关问题：</p>
<ul>
<li><p>为什么要进行三次握手，两次握手可以吗？</p>
<ul>
<li>不可以，三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。<strong>若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而服务器并不知道客户端是否能够收到自己发送的数据。</strong>这样的话，如果第二次握手失败的话，服务器是不知道的，客户机想重新建立连接的话，服务器这边始终以为是新的连接，会极大浪费资源。</li>
</ul>
</li>
<li><p>三次握手最开始有SYN，了解SYN攻击么？</p>
<ul>
<li>SYN Flood是一种最常见的DDos攻击。</li>
<li>其攻击原理为伪造地址向服务器发送SYN请求，然后服务器会回应一个ACK+SYN。而真实的IP认为自己没有发送请求，不予以回应，这样服务器会重试3-5次等待一个SYN时间，再丢弃这个连接。这样的话如果短时间内很多这个连接出现，那就可能会导致服务器消耗大量资源去处理这些连接。</li>
</ul>
</li>
<li><p>SYN_Flood防御：</p>
<ul>
<li>使用Cookie认证。<strong>原理是syn报文首先由DDOS防护系统来响应syn_ack。带上特定的序列号（记为cookie）。真实的客户端会返回一个ack 并且确认号为cookie+1。 而伪造的客户端，将不会作出响应。这样我们就可以知道那些IP对应的客户端是真实的，将真实客户端IP加入白名单。</strong>这样的话就丧失了超时重传的能力，毕竟如果不在白名单直接丢弃了。</li>
<li>使用代理服务器：先在代理服务器上进行甄别，然后再将合法的链接请求发送给服务器，这样的缺点是链接次数从三次握手变成6次握手了。</li>
</ul>
</li>
</ul>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>四次挥手流程：</p>
<img src="/posts/24cb124c/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" class title="四次挥手">

<p>了解了流程，可以直接看看书上的有限状态机。</p>
<img src="/posts/24cb124c/TCP%E7%8A%B6%E6%80%81.JPG" class title="TCP状态转移">

<p>四次挥手相关问题：</p>
<ul>
<li><p>为什么要进行四次挥手，三次挥手可以吗？</p>
<ul>
<li>不可以。释放 TCP 连接时之所以需要四次挥手，是因为 <strong>FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的</strong>。 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。</li>
<li>简而言之<strong>TCP是全双工的，两个方向的连接需要单独关闭。</strong></li>
</ul>
</li>
<li><p>Close-Wait和Time-Wait的状态和意义</p>
<ul>
<li>Close-Wait是在服务器在四次挥手中服务器端发送确认报文和结束连接的FIN报文之间的状态。这个时候服务器已经收到了关闭请求并告诉客户端自己已经成功收到该请求了，不过这个时候服务器还有一些数据没有传输完成，因此不能立即关闭连接，而 <strong>CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。</strong></li>
<li>Time-Wait发生在客户端收到服务器的FIN报文并发送ACK确认报文之后，知道客户端关闭连接的状态。这是为了保证<strong>客户端发送的最后一个确认报文能够到达服务器端，如果没有成功到达，则服务器超时重传FIN报文段，客户端再重传ACK报文段并重新计时</strong>。Time_Wait的时间一般为2MSL。</li>
</ul>
</li>
<li><p>Time-Wait为什么是2MSL,如果没有设置会出现什么？</p>
<ul>
<li>MSL是TCP报文最大生命周期，2MSL是服务端发出FIN报文和客户端能够发送ACK能保持的最大有效时间。</li>
<li>如果在1MSL时服务器没有收到ACK确认，那么就会重新给客户机发送FIN报文，这样客户端再重传的时间限制也是1MSL，相加就是2MSL。</li>
<li>如果没有设置的话，那就意味着收到FIN就会直接关闭，这样的话如果确认报文对方没收到，对方会重新发送FIN而不会一起关闭。下次再启用这个这个端口对方就不会认为是新连接了，会出现数据异常。</li>
</ul>
</li>
<li><p>服务器中处于Close_Wait的连接过多会怎么办？</p>
<ul>
<li><p>其实这个问题在做web服务器的时候遇到过，太多Close_Wait主要原因是某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接。说明服务器没有给客户端发送FIN报文，这样的话会导致（errno 24：Too many files）因为连接还在继续。这样在短连接时很容易达到文件描述符上限。</p>
</li>
<li><p>解决方法：检测出对方已经关闭的socket，然后关闭它，或者设置定时器，定期检查socket，要么从短连接设置为长连接，开启keepALive选项。</p>
</li>
</ul>
</li>
<li><p>TIME-WAIT会导致什么？</p>
<ul>
<li>这个也遇到过，如果关闭一个服务器重新启动的时候，会发生（errno 98：端口地址被占用），这个就是因为关闭只是发送一个FIN操作，还没有完全关闭，得等最多3MSL（1MSL发送报文，2MSL的time_wait）才能close。</li>
<li>大量情况下如何解决，这种解决方法一般都能从套接字选项本身寻找答案，将端口设置为可重用。</li>
</ul>
</li>
</ul>
<h4 id="TCP可靠性"><a href="#TCP可靠性" class="headerlink" title="TCP可靠性"></a>TCP可靠性</h4><p>TCP是通过以下的基础来保证可靠性</p>
<ul>
<li><strong>数据分块</strong>：应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li><strong>序列号和确认应答</strong>：TCP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</li>
<li><strong>校验和</strong>： TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</li>
<li><strong>流量控制</strong>： TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</li>
<li><strong>拥塞控制</strong>： 当网络某个节点发生拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议</strong>： 也是为了实现可靠传输的，它的基本原理就是<strong>每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组</strong>。（停止等待协议）</li>
<li><strong>超时重传</strong>： 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</li>
</ul>
<h4 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h4><p>超时重传的原理： 发送方在发送一次数据后就开启一个<strong>定时器</strong>，在一定时间内如果没有得到发送数据包的 ACK 报文，那么就重新发送数据，在达到一定次数还没有成功的话就放弃重传并发送一个复位信号。其中<strong>超时时间的计算是超时的核心，而定时时间的确定往往需要进行适当的权衡，因为当定时时间过长会造成网络利用率不高，定时太短会造成多次重传，使得网络阻塞。在 TCP 连接过程中，会参考当前的网络状况从而找到一个合适的超时时间。</strong></p>
<h4 id="流量控制与拥塞控制"><a href="#流量控制与拥塞控制" class="headerlink" title="流量控制与拥塞控制"></a>流量控制与拥塞控制</h4><p><strong>流量控制</strong>：</p>
<ul>
<li>所谓流量控制就是让<strong>发送方的发送速率不要太快，让接收方来得及接收</strong>。如果接收方来不及接收发送方发送的数据，那么就会有分组丢失。<strong>在 TCP 中利用可边长的滑动窗口机制可以很方便的在 TCP 连接上实现对发送方的流量控制</strong>。主要的方式是<strong>接收方返回的 ACK 中会包含自己的接收窗口大小，以控制发送方此次发送的数据量大小（发送窗口大小）</strong>。</li>
</ul>
<p><strong>拥塞控制</strong>：</p>
<ul>
<li>拥塞控制和流量控制不同，<strong>拥塞控制是作用于整个网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。</strong></li>
</ul>
<p><strong>拥塞控制的算法：</strong></p>
<p>​    拥塞控制的算法有慢启动，拥塞避免，快重传和快恢复四种方法。一般来说在TCP建立连接的时候会使用慢启动算法，然后知道丢包之后，才会执行拥塞避免算法</p>
<img src="/posts/24cb124c/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95.png" class title="拥塞控制算法">

<ul>
<li><p>慢启动：当一个<strong>新的TCP连接建立或检测到由重传超时（RTO）导致的丢包时，需要执行慢启动。</strong></p>
<ul>
<li>算法：<strong>以指数增长的方法扩大发送窗口。</strong>如果探到阈值（即发生丢包），那么在上一次成功发送包的基础上使用拥塞避免。</li>
<li>目的：由于是指数增长，这会使得TCP在拥塞避免探寻更多可用带宽之前得到cwnd的值，以及帮助建立ACK时钟。</li>
</ul>
</li>
<li><p>拥塞避免：拥塞避免一般在一次丢包后执行。</p>
<ul>
<li>算法：由于是丢包之后再执行，这样的话必须谨慎的增长cwnd，<strong>以线性增长的方法扩大发送窗口。</strong></li>
<li>目的：由于是线性增长，就希望能够保持高发送窗口（发送窗口大于阈值的一半）的速度发送数据。</li>
</ul>
</li>
<li><p>快重传：快重传一般使用在接收到失序的报文时，立即想对方发送重复确认。</p>
<ul>
<li>算法：假设发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。</li>
<li>目的：在报文失序的时候能够准确的知道未接收的报文是哪一个，这样能够很好的提高网络的吞吐量。</li>
<li>为何有失序情况：因为IP层不能保证包传输是有序的，可能后发的包走的链路更快一点。</li>
</ul>
</li>
<li><p>快恢复：快恢复是和快重传搭配使用的。</p>
<ul>
<li><p>算法：</p>
<p>① 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限 ssthresh 值减半；</p>
<p>② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把 cwnd 值设置为 ssthresh 减半之后的值，然后执行拥塞避免算法，线性增大 cwnd。</p>
</li>
</ul>
</li>
</ul>
<h4 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h4><p>试想一下在一个空闲的TCP连接中双方都不发送数据，那如何能知道连接的情况，什么时候可以和对方断开连接？TCP的保活机制就是为了解决这类情况而设计的。</p>
<ul>
<li>定义：保活机制是一种在不影响数据流内容情况下探测对方的方式。它是由一个<strong>保活计时器</strong>实现的，当计时器被激发，<strong>连接一端将发送一个保活探测报文</strong>，另一端接收报文的同时会发送一个ACK作为响应。</li>
<li>发送保活报文对方的状态：<ol>
<li>对方仍在正常工作，那么回复一个ACK报文，重置计时器时间。</li>
<li>对方主机已经崩溃，那么收不到ACK报文，那请求端会持续发送探测报文，直到保活计时器时间超时，如果还没有收到回复，那么认为对方已经关机，断开连接。</li>
<li>自己主机崩溃且重启，那么请求端会收到保活探测报文的响应，不过这个确认报文带有RST字段，即希望请求端重新建立连接。</li>
<li>对方主机没事但是请求端依旧无法正确收到ACK响应报文，这时处理同2。</li>
</ol>
</li>
</ul>
<h4 id="使用TCP的问题"><a href="#使用TCP的问题" class="headerlink" title="使用TCP的问题"></a>使用TCP的问题</h4><p>一般来说使用TCP的问题在上面都基本提到了，现在再次总结一下：</p>
<ul>
<li><p>三次握手问题</p>
<ul>
<li>为什么三次？</li>
<li>SYN_Flood攻击以及解决办法</li>
</ul>
</li>
<li><p>四次挥手问题</p>
<ul>
<li>为什么四次？</li>
<li>Close_Wait和Time_Wait的状态意义，为什么会发生，如果服务器太多连接处于这个状态会出现什么问题？</li>
</ul>
</li>
<li><p>可靠性</p>
<ul>
<li>可靠性的基础——ACK重传</li>
<li>ARQ协议</li>
<li>超时重传</li>
</ul>
</li>
<li><p>拥塞控制</p>
<ul>
<li>四大算法以及使用条件和用法</li>
</ul>
</li>
<li><p>保活机制</p>
<ul>
<li>定义</li>
<li>分析状态以及处理手段</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>TCP“粘包”</li>
<li>TCP选项</li>
<li>待补充</li>
</ul>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《TCP/IP详解》 卷一</li>
<li><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/">https://leetcode-cn.com/leetbook/read/networks-interview-highlights/</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>拥塞控制</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/posts/a1ede006/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章介绍一下HTTP的基础知识。主要涉及方面有HTTP报文，HTTPS，HTTP2.0的改进等</p>
</blockquote>
<span id="more"></span>



<h3 id="HTTP协议介绍"><a href="#HTTP协议介绍" class="headerlink" title="HTTP协议介绍"></a>HTTP协议介绍</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>HTTP协议叫做超文本传输协议，广泛应用Web间的客户端与服务器之间的通信。现在一般介绍都是HTTP1.1。</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>是一个<strong>无状态的协议</strong>，无状态是指自身不对请求和响应的状态进行保存，这样的话协议对发送过的请求和响应都没有记录，不做持久化处理。这样能够使HTTP更简单。</p>
</li>
<li><p><strong>使用Cookie技术</strong>，虽然是无状态协议，但是依据可能要保证用户的状态，比如进入一个网页要保持登录状态。使用cookie的话能够很好的管理用户的状态。</p>
<ul>
<li>Cookie技术通过在请求和响应报文中写入Cookie信息来控制<strong>客户端</strong>的状态。</li>
<li><strong>服务器生成响应报文</strong>中的<code>Set-Cookie</code>首部字段，通知<strong>客户端保存Cookie</strong>。</li>
</ul>
</li>
<li><p>使用URI定位互联网上的资源，支持多种方法请求，如GET、POST等，请求方法和URI均在请求报文中的请求行中。</p>
</li>
<li><p>采用管线化持久连接： 1.1默认支持管线化和持久连接，这样的话能够减少重复建立和断开锁造成的额外开销，减轻了服务器的负载。管线化指的是可以发送多个请求，不用等待响应再发送，这样请求数多的话，时间差就越明显。</p>
</li>
</ul>
<h3 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h3><h4 id><a href="#" class="headerlink" title></a></h4><p>// todo 图</p>
<ul>
<li>请求行：包括请求方法，请求URI和HTTP版本</li>
<li>状态行：包含状态码，原因短语和HTTP版本</li>
<li>头部</li>
<li>报文主体</li>
</ul>
<p>HTTP在传输中可以使用<strong>分块传输编码</strong>的方法，能够提升HTTP传输的效率</p>
<h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>

<p>请求行最重要的就是请求方法，请求方法有以下几种：</p>
<ul>
<li>GET：获取URI的资源，请求报文主体为空。</li>
<li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。<strong>数据被包含在请求体中</strong>。可能会导致<strong>新的资源的建立或已有资源的更改。</strong></li>
<li>PUT：用于传输文件，报文主体是文件内容，保存到指定的URI中</li>
<li>DELET：删除文件，与PUT相反的操作，一般都不适用</li>
<li>HEAD：和get类似，无报文主体，只是确认一下URI的有效性，验证通信状态。</li>
</ul>
<p>GET和POST的区别：</p>
<ul>
<li><p><strong>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源</strong>。</p>
</li>
<li><p><strong>get 请求只支持 URL 编码，post 请求支持多种编码格式。</strong></p>
</li>
<li><p><strong>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</strong></p>
</li>
<li><p>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制</p>
</li>
<li><p>get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。</p>
</li>
<li><p>get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）。这个是因为POST首先发header过去，和服务器说之后要来东西了，然后再将主体发过去。</p>
</li>
</ul>
<h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure>

<p>状态行主要是告知从服务器端返回的请求结果。</p>
<p>状态码类别</p>
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>信息性状态码</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>成功状态码</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向状态码</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误状态码</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>服务器错误状态码</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<p>重要状态码：</p>
<ul>
<li><p>100 继续，服务器正在处理请求</p>
</li>
<li><p>200 请求成功</p>
</li>
<li><p>204 请求成功但无内容返回</p>
</li>
<li><p>206 范围请求成功</p>
</li>
<li><p>301 <strong>永久重定向</strong>； <strong>30(2|3|7)临时重定向，语义和实现有略微区别</strong>；（指定资源路径最后忘记加斜杠“/“,就会产生301状态码）</p>
</li>
<li><p>304 带if-modified-since 请求首部的条件请求，条件没有满足</p>
</li>
<li><p>400 <strong>语法错误</strong>（前端挨打）</p>
</li>
<li><p>401 需要认证信息</p>
</li>
<li><p>403 拒绝访问</p>
</li>
<li><p>404 找不到资源</p>
</li>
<li><p>412 除if-modified-since 以外的条件请求，条件未满足</p>
</li>
<li><p>500 <strong>服务器错误</strong>（后端挨打）</p>
</li>
<li><p>503 服务器宕机了（DevOps or IT 挨打）</p>
</li>
</ul>
<p>3开头的重定向，如果服务器返回有重定向之后的URL，那么会<strong>强制</strong>客户机再次发送正确的请求报文，毕竟只有2开头算是成功的响应。</p>
<h4 id="HTTP头部"><a href="#HTTP头部" class="headerlink" title="HTTP头部"></a>HTTP头部</h4><p>HTTP头部本质上是一个传送额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部。</p>
<ul>
<li><p>通用头部：请求报文和响应报文都有的头部，主要是提供一些通用的功能</p>
<ul>
<li>Connection：是否是长连接，连接是否关闭</li>
<li>Date：报文创建时间</li>
</ul>
</li>
<li><p>请求头部：请求报文特有的头部，<strong>用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容</strong>。</p>
<ul>
<li>Accept：告诉服务器自己允许哪些媒体类型</li>
<li>Accept-Charset: 浏览器可申明的字符集</li>
<li>Accept-Encoding： 浏览器可接受的响应内容语言列表</li>
<li>HOST：服务器的域名以及服务器所监听的端口号</li>
<li>RANGE：<strong>表示请求某个实体的一部分</strong></li>
<li>Authorization：用于表示 HTTP 协议中需要认证资源的认证信息</li>
</ul>
</li>
<li><p>响应头部：响应报文特有的头部，用于告知服务器上的一些信息</p>
<ul>
<li>Age：创建响应时间</li>
<li>Location： 重定向之后的URL，这个专门为3XX打造</li>
<li>Server：服务器的信息</li>
<li>Vary：缓存控制</li>
</ul>
</li>
<li><p>实体头部：是对实体内容的一些约束和补充说明</p>
<ul>
<li>ALLOW：允许的请求信息，如ALLOW： GET, HEAD</li>
<li>Content-xxx：返回内容的信息<ul>
<li>encoding：编码信息</li>
<li>length：长度，这个对于分块传送很重要</li>
<li>Range： 整个返回体本部分的字节位置</li>
<li>MD5：MD5校验值</li>
</ul>
</li>
<li>Expire：响应的过期时间</li>
<li>Last-Modified：请求资源最后修改的时间</li>
</ul>
</li>
</ul>
<p>其他问题：</p>
<p>HTTP长连接和短连接的区别：</p>
<ul>
<li><p>长连接：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</p>
</li>
<li><p>短连接：用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</p>
</li>
</ul>
<h3 id="HTTPS相关"><a href="#HTTPS相关" class="headerlink" title="HTTPS相关"></a>HTTPS相关</h3><p>HTTP是一个很简单好用的协议，但是对安全性几乎没有保障，其不足点如下：</p>
<ul>
<li>通信使用明文（不加密），内容可能被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以可能已遭到篡改</li>
</ul>
<p>针对以上的不足，HTTPS对其有以下的改进：</p>
<ul>
<li>对通信使用加密技术：通过和SSL或TLS的组合使用，加密HTTP的通信内容。</li>
<li>使用证书来确定通信方的身份：SSL不但提供加密处理，而且还使用一种被称为证书的手段，证书是一个由第三方发布的，伪造起来很难。</li>
<li>HTTP虽然使用<strong>MD5散列值校验和确定文件的数字签名方法</strong>，但是还是不能保证报文完整性，这里使用的依旧是证书的功能，这样传输过程中就不会被破解了。</li>
</ul>
<p>因此由上可得HTTP = HTTP over SSL，SSL能把这些安全性问题都解决。</p>
<h4 id="HTTP和HTTPS的差别："><a href="#HTTP和HTTPS的差别：" class="headerlink" title="HTTP和HTTPS的差别："></a>HTTP和HTTPS的差别：</h4><ul>
<li><p>HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。</p>
</li>
<li><p>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。</p>
</li>
<li><p>HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。</p>
</li>
<li><p>HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。</p>
</li>
</ul>
<h4 id="SSL协商："><a href="#SSL协商：" class="headerlink" title="SSL协商："></a>SSL协商：</h4><p>HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：</p>
<p>① 客户端发起一个 HTTPS 请求，并连接到服务器的 443 端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；</p>
<p>② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。</p>
<p>③ 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。</p>
<p>④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。</p>
<p>⑤ SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secre，并且该报文是经过证书中的公钥加密过的。</p>
<p>⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre 加密的。</p>
<p>⑦ 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。</p>
<p>⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。</p>
<p>当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。</p>
<h4 id="HTTPS加密方式："><a href="#HTTPS加密方式：" class="headerlink" title="HTTPS加密方式："></a>HTTPS加密方式：</h4><p>采取对称加密和非对称加密相结合的方式，首先使用SSL协议协议进行加密传输，为了弥补费对称加密的缺点，采用证书进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端<strong>协商</strong>好之后进行通信传输的<strong>对称加密</strong>，后续的所有信息都通过该对称秘钥进行加密解密。</p>
<p>证书：</p>
<p>在HTTPS中证书一定是值得信任的，证书是由第三方机构颁发的，用户给公共密钥和一些个人身份信息给认证中心，认证中心返还给用户一个数字证书。</p>
<p>对称加密：</p>
<p>对称加密就是双方协商之后的共享秘钥加密。因为其加密解密的秘钥相同，而且是经历过协商，在通信中使用的。</p>
<p>非对称加密：</p>
<p>非对称加密就是公开秘钥加密。因为其有一把公钥和私钥，公开加密处理复杂，因此不适用于通信，但是很适合用于帮助对称加密交换密钥。</p>
<table>
<thead>
<tr>
<th></th>
<th>对称加密（共享加密）</th>
<th>非对称加密（公开加密）</th>
</tr>
</thead>
<tbody><tr>
<td>加密处理</td>
<td>双方使用同一个密钥</td>
<td>使用公钥和私钥，公钥进行加密，私钥进行解密</td>
</tr>
<tr>
<td>特点</td>
<td>处理简单，方便</td>
<td>处理困难，但是安全性高，不会被窃听</td>
</tr>
<tr>
<td>用法</td>
<td>用于通信传输，一般配合证书搭配使用</td>
<td>用于共享密钥的传送，保证共享密钥的安全性</td>
</tr>
</tbody></table>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><table>
<thead>
<tr>
<th></th>
<th>HTTP1.0</th>
<th>HTTP1.1</th>
<th>HTTP2.0</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td>默认无连接</td>
<td><strong>默认长连接，支持管线化</strong></td>
<td><strong>二进制传送，封装成帧</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td>使用缓存处理</td>
<td><strong>多路复用</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td>节约带宽</td>
<td>头部压缩</td>
</tr>
<tr>
<td></td>
<td></td>
<td>使用请求头</td>
<td>服务端推送</td>
</tr>
</tbody></table>
<p>HTTP1.0没什么讲的。</p>
<p>HTTP1.1中的几大特点都是根据头部信息有关：</p>
<ul>
<li>长连接，管线化： Connection字段的Keep-alive</li>
<li>缓存处理：if-modified-since字段负责</li>
<li>节约带宽：通过range只请求部分资源，不需要请求全部资源。</li>
<li>请求头：使用HOST能够声明主机。</li>
</ul>
<p>HTTP2.0的提升就特别大了</p>
<ul>
<li><p>二进制传送：HTTP1.X的传输单位为报文，而2.0将其封装成帧，帧组成数据流，能够实现二进制传送。</p>
</li>
<li><p>多路复用：在封装成帧的概念下，帧里面有流ID和优先级，可以实现多个请求同时传输多个结果同时处理，而且可以ABA（先发A的上半部，再发B，再发B的下半部）这样发请求报文。再加上优先级的概念，这样处理请求可以完全实现多路复用。</p>
</li>
<li><p>头部压缩：。HTTP/2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 HTTP 传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。</p>
</li>
<li><p>服务器推送。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送。</p>
</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>这里来个经典问题</p>
<p>网页解析全过程【用户输入网址到显示对应页面的全过程】</p>
<p>% asset_img 流程图.png 复制构造循环引用 %}</p>
<p>从上图可以看出一般分为以下几个部分</p>
<ol>
<li><p><strong>解析域名</strong>：当用户输入一个网址并按下回车键的时候，浏览器会获得一个域名，而通信首先需要通过域名去找到服务器的IP地址。一般是根据DNS协议去查找IP地址。</p>
</li>
<li><p><strong>DNS原理</strong>：DNS是一个基于UDP的应用层协议，端口号为53，一般来说DNS采取分布式的设计方案，其域名空间采取一种树形的层次。从根到叶总共三层：根服务器，顶级服务器，权威服务器。除此之外还有本地服务器。一般来说DNS请求首先是在本地寻找缓存，如果有缓存的话那就直接用，如果没有就像本地DNS服务器发送一个DNS查询报文，本地DNS服务器中的缓存没有，那就直接将该报文转发到根服务器，然后进行递归迭代查询。</p>
</li>
<li><p><strong>TCP连接</strong>：当查询到了服务器的IP地址，那么就可以通过TCP协议去建立一个连接了，建立连接就是三次握手，这个不再赘述。</p>
</li>
<li><p><strong>发送HTTP请求</strong>：浏览器向Web服务器发起一个HTTP请求，然后服务器处理后浏览器收到响应报文，如果是HTTPS还要进行SSL协商。这个也不再赘述。</p>
</li>
<li><p><strong>浏览器渲染</strong>： 浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这些是前端的知识了。</p>
</li>
<li><p>断开连接：四次挥手，断开连接。</p>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p>《图解HTTP》</p>
</li>
<li><p>《TCP/IP详解》卷一</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>STL空间配置器</title>
    <url>/posts/1cc2fcbf/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章简单记录一下STL中的空间配置器(allocator)</p>
</blockquote>
<span id="more"></span>



<h4 id="空间配置"><a href="#空间配置" class="headerlink" title="空间配置"></a>空间配置</h4><p>​    STL中的空间配置器是实现STL的第一个部件，因为整个STL的操作对象都放在容器中，而容器一定需要配置空间。如果没有了解到STL的空间配置原理的话，在之后学习STL其它组件时会遇到困难。</p>
<p>​    而为什么叫空间配置器而非常见的内存配置器呢？因为这个空间不一定是内存，你也可以写个allocator直接像硬盘中取空间。不过在SGI STL中提供的配置器，配置对象是内存。</p>
<p>​    内存空间的配置和释放在C++语法部分就已经了解到，是通过<code>::operator new</code>和<code>::operator delete</code>来实现的。 这两者通过调用malloc/free来对内存进行操作。这里不再赘述。</p>
<h4 id="SGI中的std-allocator"><a href="#SGI中的std-allocator" class="headerlink" title="SGI中的std::allocator"></a>SGI中的<code>std::allocator</code></h4><p>​    SGI标准的空间配置器为<code>std::allocator</code>，该配置器只是把C++中的<code>::operator new</code>和<code>::operator delete</code>做了一层薄薄的包装而已。这样的话<strong>效率不高</strong>，因此不建议使用。</p>
<h4 id="SGI中的std-alloc"><a href="#SGI中的std-alloc" class="headerlink" title="SGI中的std::alloc"></a>SGI中的<code>std::alloc</code></h4><h5 id="alloc介绍"><a href="#alloc介绍" class="headerlink" title="alloc介绍"></a><code>alloc</code>介绍</h5><p>​    由于标准的空间配置器<code>std::allocator</code>不管用，那么SGI又实现了另外一个空间配置器<code>std::alloc</code>。</p>
<p>​    众所周知，C++内存配置和释放操作一般如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> ... &#125;;</span><br><span class="line">Foo* pf = <span class="keyword">new</span> Foo;</span><br><span class="line"><span class="keyword">delete</span> pf;</span><br></pre></td></tr></table></figure>

<p>其中new算式内含有两个操作：</p>
<ol>
<li>调用<code>::operator new</code>配置内存；</li>
<li>调用<code>Foo::Foo()</code>构造对象。</li>
</ol>
<p>而delete算式内含有两个操作</p>
<ol>
<li>调用<code>Foo:~Foo()</code>析构对象；</li>
<li>调用<code>::operator delete</code>释放内存。</li>
</ol>
<p>因此该配置器将两阶段操作区分开来。内存配置操作由<code>alloc::allocate()</code>负责，对象构造由<code>alloc::construct()</code>负责，内存释放操作同理。</p>
<p>配置器定义域<code>&lt;memory&gt;</code>之内</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in &lt;memory&gt; </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_alloc.h&gt;</span>					<span class="comment">// 负责内存空间的配置与释放</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_construct.h&gt;</span>				<span class="comment">// 负责对象内容的构造与析构</span></span></span><br></pre></td></tr></table></figure>



<h5 id="alloc对象构造和析构工具"><a href="#alloc对象构造和析构工具" class="headerlink" title="alloc对象构造和析构工具"></a><code>alloc</code>对象构造和析构工具</h5><p><code>alloc</code>中的构造和析构工具是使用<code>::placement new</code>和<code>::placement delete</code>，然后使用模板编程进行<code>type_traits</code>来对特定元素进行构造和析构。</p>
<h5 id="alloc内存配置和释放工具"><a href="#alloc内存配置和释放工具" class="headerlink" title="alloc内存配置和释放工具"></a><code>alloc</code>内存配置和释放工具</h5><p>这个才是有意思的地方：<code>alloc</code>没有像之前的<code>std::allocator</code>一样只是对<code>operator new</code>进行一层薄薄的封装，而是通过<strong>双层级配置器</strong>来提升效率。</p>
<ul>
<li>第一级配置器：<ul>
<li>使用情况：<strong>当配置区块大于128bytes时</strong>，使用它</li>
<li>使用方法：直接使用malloc和free</li>
</ul>
</li>
<li>第二级配置器：<ul>
<li>使用情况：当配置区块小于128bytes时，使用它</li>
<li>使用方法：使用复杂的<strong>内存池整理</strong>方式</li>
</ul>
</li>
</ul>
<p>第一级配置器无须赘言，直接看第二级配置器吧</p>
<ul>
<li><p>为什么要进行二级配置？</p>
<ul>
<li>为了避免出现太多小额区块造成内存的碎片。小额区块带来的不仅仅是内存碎片，还会带来额外的管理负担。</li>
<li>这样的话，对于小额区块的利用是有价值的。</li>
</ul>
</li>
<li><p>二级配置原理</p>
<ul>
<li><p><strong>使用内存池管理：每次配置一大块内存，并维护对应的自由链表。</strong></p>
</li>
<li><p>自由链表一般是8的倍数，因此一般配置16个自由链表，分别配置8~128bytes</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自由链表 free-lists的节点结果如下</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">obj</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">obj</span> * <span class="title">free_list_link</span>;</span></span><br><span class="line">    <span class="keyword">char</span> client_data[<span class="number">1</span>];				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用union结构，obj指针不会造成内存浪费。</p>
</li>
<li><p>配置内存时与自由链表空间进行匹配，匹配成功则将该链表的内存空间配置出去，当回收内存时，这块内存区域又会回收到自由链表中。</p>
</li>
</ul>
</li>
<li><p>函数调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    obj * result;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="keyword">size_t</span> __MAX_NYTES)&#123;</span><br><span class="line">        <span class="keyword">return</span> (malloc_alloc::<span class="built_in">allocate</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找16个free lists中适当的一个</span></span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">    result = *my_free_list;</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果没有合适的自由链表，则重新填充free_list</span></span><br><span class="line">        <span class="keyword">void</span> *r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n));</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调整free list</span></span><br><span class="line">    *my_free_list = result-&gt;free-&gt;list-&gt;link;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dellocate</span><span class="params">(<span class="keyword">void</span>* p,<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    obj* <span class="keyword">volatile</span> * my_free_list;</span><br><span class="line">    obj * q = (obj *) p;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="keyword">size_t</span> __MAX_NYTES)&#123;</span><br><span class="line">        malloc_alloc::<span class="built_in">dellocate</span>(p,n);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找对应的free list</span></span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 调整free list，回收区块</span></span><br><span class="line">    q-&gt;free-&gt;list-&gt;link = *my_free_list;</span><br><span class="line">    *my_free_list = q;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果free_list中没有可以区块时，就调用refill()，准备为free_list重新填充空间。新的空间将取自内存池（经由<code>chunk_alloc()</code>完成）</p>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​    STL的空间配置并不难，但是提前了解的话，对于后面容器创建的行为都会很好地理解了。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>《STL源码剖析》——侯捷</li>
</ul>
]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>allocator</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/posts/f1601c3e/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章来介绍线程安全的单例模式怎么写。不仅有传统意义的DLC单例和静态成员变量的单例，还有着C++11的pthread_once如何实现单例模式。</p>
</blockquote>
<span id="more"></span>

<h4 id="传统的单例模式："><a href="#传统的单例模式：" class="headerlink" title="传统的单例模式："></a>传统的单例模式：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 单例模式 1：  在该空间中针对该对象只能创建一个instance，因此该对象的构造函数必须delete。</span></span><br><span class="line"><span class="comment">			那么如何创建那个实例呢？直接用static关键词修饰这个实例，如果该实例已经被创建了，</span></span><br><span class="line"><span class="comment">			那这个实例就一直存在。</span></span><br><span class="line"><span class="comment">			但是多线程中，这个创建过程是安全的吗？</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> T&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(value_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			value_ = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value_;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> T* value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> T* value_ = <span class="literal">nullptr</span>; <span class="comment">// static对象初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="加上锁的单例模式："><a href="#加上锁的单例模式：" class="headerlink" title="加上锁的单例模式："></a>加上锁的单例模式：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 单例模式 2：  在上面的代码加上锁，那么就可以解决多线程下的condition race问题，</span></span><br><span class="line"><span class="comment">			但是每次访问它都要进行加锁，锁也是一种资源，这样会大量耗费资源。</span></span><br><span class="line"><span class="comment">			因此这样性能消耗很大，不提倡。</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> T&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">       	Lock lock;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span>(value_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			value_ = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value_;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> T* value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> T* value_ = <span class="literal">nullptr</span>; <span class="comment">// static对象初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="double-checked-locking的单例模式"><a href="#double-checked-locking的单例模式" class="headerlink" title="double checked locking的单例模式"></a>double checked locking的单例模式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 单例模式 3：  2的性能消耗大的原因是加锁，那么如何让其性能提升呢？</span></span><br><span class="line"><span class="comment">			再通过一次判断，如果满足的话，加锁，不然的话，就不加。	</span></span><br><span class="line"><span class="comment">			因此double checked locking 是为了减少竞争和加锁载荷。</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> T&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二次确认</span></span><br><span class="line">        <span class="keyword">if</span>(value_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">// 获取锁</span></span><br><span class="line">            Lock lock;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(value_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                value_ = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> value_;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> T* value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> T* value_ = <span class="literal">nullptr</span>; <span class="comment">// static对象初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="静态局部变量实现单例（C-11"><a href="#静态局部变量实现单例（C-11" class="headerlink" title="静态局部变量实现单例（C++11)"></a>静态局部变量实现单例（C++11)</h4><p>​    上面的单例模式真的对嘛？由于编译器的指令重排，上面的单例模式或多或少都有点问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment">* 单例模式 4：  new函数分为三步：</span></span><br><span class="line"><span class="comment">                    1：分配空间： 调用 operator new 来实现。（底层是用malloc）</span></span><br><span class="line"><span class="comment">                    2：在分配空间中构造对象：调用构造函数实现 placement new</span></span><br><span class="line"><span class="comment">                    2：使得实例value_指向分配的空间。</span></span><br><span class="line"><span class="comment">             由于编译器有指令优化，因此这三个步骤不是严格按照顺序执行的。</span></span><br><span class="line"><span class="comment">             所以可能出现线程A进入了临界区，执行了step1和step3，然后挂起。</span></span><br><span class="line"><span class="comment">             这个时候指针已经指向了一个分配空间，但是分配空间中没有构造对象。(即指针不为nullptr，但是内存里面还是空的)</span></span><br><span class="line"><span class="comment">             这个时候B进入临界区，发现value_ != nullptr,直接出错</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             总之就是指令重排会导致DLC方式的单例不好写。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             因此这里有个使用局部静态变量实现的单例模式——————Meyers Singleton</span></span><br><span class="line"><span class="comment">				局部静态变量智慧初始化一次，因此这个调用这个instance调用的永远是这个value</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> T&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> T value;	<span class="comment">// 局部静态变量</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="C-11的call-once实现单例模式"><a href="#C-11的call-once实现单例模式" class="headerlink" title="C++11的call_once实现单例模式"></a>C++11的call_once实现单例模式</h4><p>​    在多线程编程中，有时某个任务只需要执行一次，此时可以用C++11中的<code>std::call_once</code>函数配合<code>std::once_flag</code>来实现。如果多个线程需要同时调用某个函数，<code>std::call_once</code>可以保证多个线程对该函数只调用一次。也可用在解决线程安全的单例模式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class Callable, class... Args &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_once</span><span class="params">(std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> std::once_flag s_flag;</span><br><span class="line">    std::<span class="built_in">call_once</span>(s_flag, [&amp;]() &#123;</span><br><span class="line">      instance_.<span class="built_in">reset</span>(<span class="keyword">new</span> Singleton);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *instance_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> std::unique_ptr&lt;Singleton&gt; instance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;Singleton&gt; Singleton::instance_;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>STL介绍</title>
    <url>/posts/171e944c/</url>
    <content><![CDATA[<blockquote>
<p>STL向来是C++中的一个重要组成部分。STL是一个包罗算法与数据结构的软件框架，本篇文章用于为STL做一个简要介绍，至于具体的内容看STL分类的后续文章。</p>
</blockquote>
<h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><p>STL有六大组件，彼此可以组合套用：</p>
<ul>
<li><p>容器：各种数据结构</p>
<ul>
<li>顺序容器： vector, list, deque</li>
<li>关联容器： set, map</li>
</ul>
</li>
<li><p>算法：各种模板算法（template function: 在各种容器都有适配性）</p>
<ul>
<li><code>#include &lt;algorithm&gt;</code>: sort, search, copy, erase等</li>
</ul>
</li>
<li><p>迭代器：本质是<strong>泛型指针</strong>，算法与容器之间的胶合剂。</p>
<ul>
<li>共有五种类型：（之后待补充）</li>
<li>实际上是将一些operator进行重载的class template</li>
<li>所有STL容器都有自己专属的迭代器。</li>
<li>原生指针也是一种迭代器</li>
</ul>
</li>
<li><p>仿函数：行为类似函数，可作为算法的某种策略</p>
<ul>
<li>可以被视为一种重载了operator()的class 或 class template</li>
<li>一般的函数指针为狭义的仿函数</li>
</ul>
</li>
<li><p>配接器：一种用来修饰容器或仿函数或迭代器接口的东西。比如stack和queue，因为它们的底层是由deque实现的，所有操作也都是deque操作。</p>
<ul>
<li>改变functor接口者，称为function adapter</li>
<li>改变container接口者，称为container adapter</li>
<li>改变iterator接口者，称为iterator adapter</li>
</ul>
</li>
<li><p>配置器：负责空间配置与管理</p>
<ul>
<li>从实现角度来看，配置器是实现了动态空间配置、空间管理、空间释放的class template</li>
</ul>
</li>
</ul>
<p>六大主件之间的关系：</p>
<p>​    Container通过Allocator取得数据储存空间，Algorithm通过Iterator存取Container内容，Functor可以协助Algorithm完成不同策略变化，Adapter可以修饰或套接Functor。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>编译内存相关</title>
    <url>/posts/3e94d9ed/</url>
    <content><![CDATA[<blockquote>
<p>C/C++文件如何从一个源文件{.c/.cpp}变成一个可执行文件？在这过程中，其内存管理又是怎么样的？</p>
<p>本篇文章就来讲一讲这些内容。</p>
</blockquote>
<span id="more"></span>



<h3 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h3><p>程序编译分为四个过程： 预处理，编译（编译，优化）， 汇编， 链接。</p>
<ul>
<li><p>预处理：处理以#开头的指令，如果是头文件则将头文件插入到源文件中，如果是宏，则将宏展开，删除注释。（不过#pragma指令会保留，因为编译器要用到它）</p>
</li>
<li><p>编译、优化： 将源文件(.cpp)翻译为汇编代码(.s)。</p>
</li>
<li><p>汇编：将汇编代码翻译成机器指令文件(.o)。</p>
</li>
<li><p>链接：汇编程序生成的目标文件，不会立即执行。因为可能会出现.cpp文件函数引用了另一个.cpp文件中定义的符号或者调用某个库文件中的函数，这样的话需要将这些文件链接成一个整体，生成(.exe)可执行文件。</p>
</li>
</ul>
<img src="/posts/3e94d9ed/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" class title="编译过程">

<img src="/posts/3e94d9ed/%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B.png" class title="链接过程">



<h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h3><p>C++内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。</p>
<ul>
<li>栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。</li>
<li>堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</li>
<li>全局区/静态存储区（.bss 段和 .data 段）：<strong>存放全局变量和静态变量</strong>，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。</li>
<li>常量存储区（.data 段）：<strong>存放的是常量，不允许修改</strong>，程序运行结束自动释放。</li>
<li>代码区（.text 段）：<strong>存放代码，不允许修改，但可以执行</strong>。编译后的二进制文件存放在这里。</li>
</ul>
<img src="/posts/3e94d9ed/%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5.png" class title="内存分段">

<p>从图中可以看出，32bitCPU可寻址<strong>4G线性空间</strong>，每个进程都有各自对的4G逻辑地址，其中0<del>3G是用户态，3</del>4G是内核态空间。</p>
<p>各个段说明如下：</p>
<p>3G用户空间和1G内核空间</p>
<ul>
<li><p>静态区域：</p>
<ul>
<li>text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</li>
<li>data segment(数据段)：存储程序中已初始化的全局变量和静态变量</li>
<li>bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0</li>
</ul>
</li>
<li><p>动态区域：</p>
<ul>
<li>heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。</li>
<li>memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）</li>
<li>stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。</li>
</ul>
<p>栈地址是由高到低扩展的，堆地址是由低到高扩展的。</p>
</li>
</ul>
<h3 id="编译器做了什么"><a href="#编译器做了什么" class="headerlink" title="编译器做了什么"></a>编译器做了什么</h3><p>从最直观的角度来讲，编译器就是将<strong>高级语言翻译成机器语言</strong>的一个工具。</p>
<p>编译过程一般分为6步： 扫描、语法分析、语义分析、源代码优化、代码生成、目标代码优化。</p>
<img src="/posts/3e94d9ed/%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.jpg" class title="编译流程">

<p>实际上就是三步：分析代码，优化代码，生成代码。</p>
<h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>​    首先将源代码程序输入到扫描器（Scanner），然后在其中进行词法分析。词法分析是简单借助有限状态机将源代码的字符序列分割成一系列的记<strong>号</strong>，然后逐个去判断是否有<strong>词法错误</strong>。</p>
<h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>​    进行词法分析之后，接下来语法分析器会对之前产生的记号进行语法分析，从而产生<strong>语法树</strong>。整个分析过程采用了上下文无关语法。在语法分析的同时，<strong>运算符的优先级和含义</strong>被确定了下来（如*是乘法还是对指针取内容的表达式）。如果出现了表达式不合法现象，编译器会报告语法分析阶段的错误。</p>
<p>​    语法分析仅仅是完成了对表达式的语法层面的分析。</p>
<h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>​    接下来，语义分析器来分析语句的真正含义，是否有意义。语义分为两种，静态语义和动态语义。编译阶段只能分析其<strong>静态语义</strong>，动态语义只能在运行期才能确定。</p>
<p>​    静态语义通常包括<strong>声明和类型的匹配，类型的转换</strong>。（其实就是分析和类型相关的合法性，比如将一个浮点数赋值给一个指针，如果类型不匹配会报错）。语义的分析是语法树上进行的，在语法分析阶段，语法树上只有运算符的优先级和含义，在语义分析阶段中，<strong>语法树上的表达式都被表示了类型</strong>。</p>
<h4 id="源代码优化"><a href="#源代码优化" class="headerlink" title="源代码优化"></a>源代码优化</h4><p>​    进行了以上三个分析之后，源代码会进行响应的优化。 现代的编译器有着很多层次的优化，源代码级优化是必不可少的。</p>
<p>举个例子：(2+6)在这一步就被优化成了8.（<strong>其它与临时变量相关的代码都是在这一步优化的</strong>）</p>
<p>在语法树上直接优化比较困难，因此<strong>源代码优化器一般将整个语法树转换成中间代码</strong>（中间代码即为语法树的顺序表示）。转换的中间代码是机器无关的，优化之后将中间代码转换成目标机器代码，这样就能够在相应的机器上运行。</p>
<h4 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h4><p>​    在编译器中生成的目标代码是汇编代码，汇编代码是非常依赖机器的，因此中间代码转换成目标机器代码是有必要的。</p>
<p>​    最后，在汇编阶段对代码进行优化：</p>
<ul>
<li><p>为什么要在汇编阶段再次优化呢？源代码阶段不是已经优化过了么？</p>
<ul>
<li><p>汇编代码优化是<strong>为了选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等。</strong></p>
</li>
<li><p>举个例子：乘法是由一条相对复杂的基址变址寻址的lea完成的。</p>
</li>
</ul>
</li>
</ul>
<p>至此，一个完整的编译过程就这样结束了。不过，在该过程中，编译器似乎没有考虑到内存地址，假如有个变量**<code>int index = 0;</code>定义在和源代码同一单元内，那么编译器直接可以为<code>index</code>分配空间并确定地址<strong>，那如果</strong><code>index</code>定义在其他模块呢**？这该怎么办？</p>
<p>这样，就引入了下一个话题——链接。所以再次总结一下：</p>
<p><strong>现代编译器可以将一个源文件变异成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。</strong></p>
<h3 id="链接器做了什么"><a href="#链接器做了什么" class="headerlink" title="链接器做了什么"></a>链接器做了什么</h3><p>链接器是将编译器或汇编器生成的若干个目标模块，整合成一个被称为载入模块或可执行文件的实体。</p>
<h4 id="链接分类"><a href="#链接分类" class="headerlink" title="链接分类"></a>链接分类</h4><p>链接分为两种：</p>
<ul>
<li>静态链接：代码从其所在的静态链接库中<strong>拷贝</strong>到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li>
<li>动态链接：代码被放到动态链接库或共享对象的某个目标文件中，<strong>链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息</strong>。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li>
</ul>
<p>二者优缺点对比：</p>
<ul>
<li><p>静态链接：将程序调用的库一起打包到可执行文件中，这样执行时就不需要调用别的库了，<strong>速度快</strong>，但是<strong>链接的时候可能同一个库链接了好几次，导致空间浪费，而且如果该库更新了的话，整个程序需要重新编译</strong>（更新困难）；</p>
<img src="/posts/3e94d9ed/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5.png" class title="静态链接"></li>
<li><p>动态链接：在程序执行时才载入引用的库，因此<strong>方便更新</strong>。而且只需要一次拷贝，<strong>节省内存</strong>。但是每次执行都需要链接，相比静态链接会有一定的性能损失。</p>
<img src="/posts/3e94d9ed/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png" class title="动态链接"></li>
</ul>
<p>明确了链接的分类之后，想必都明白在编译过程中的链接一般都指的是静态链接。</p>
<p>下面我们介绍链接器做了什么。</p>
<h4 id="静态链接器的工作"><a href="#静态链接器的工作" class="headerlink" title="静态链接器的工作"></a>静态链接器的工作</h4><p>​    链接器如何将输入文件中的各个段合并到输出文件？如果只是单纯的按照目标文件次序叠加，那这样在目标文件中会有很多零散的段，这样会造成内存空间大量的内部碎片，所以这并不是一个很好的方案。</p>
<ul>
<li><p>相似段合并：该方法顾名思义，将输入文件中相似的段合并成到统一的区域中，这样的话目标文件中就依然还是正常的内存分区，不过，如何将输入文件正确映射到输出文件相应的段？ 在这里采用<strong>两步链接</strong>的方法。</p>
</li>
<li><p>两步链接：</p>
<ul>
<li>第一步，空间与地址分配：扫描所有的输入目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个<strong>全局符号表</strong>。在这一步，链接器能够获得所有输入文件段的长度，并将其合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。</li>
<li>第二步，符号解析与重定位：利用第一步收集到的所有信息，读取输入文件段的数据，重定位信息，惊醒符号分析和重定位，调整代码中的地址等。事实上第二步才是链接过程的核心。</li>
</ul>
</li>
</ul>
<h4 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h4><p>​    空间与地址分配该步骤做了以下两件事：（当然，这种地址空间都是虚拟地址）</p>
<ul>
<li><p>根据输入文件的段长、属性等给输<strong>出文件分配一个内存地址空间</strong>，而且还在内存地址空间中划分了各个段的地址。</p>
</li>
<li><p>生成一个<strong>全局符号表</strong>，全局符号表中有着输入文件中符号表中华所有的符号定义和符号引用。为第二步的符号解析和重定位做准备。</p>
<p>（符号——函数和变量的统称）</p>
</li>
</ul>
<h4 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h4><ol>
<li><p><strong>为什么需要重定位？</strong></p>
<p>在重定位之前，输入文件的取址地址都在其原来的文件中，现在那些文件合成一个输出文件，其符号的地址可能会发生变化（尤其是绝对地址，一般都会改变），如何此时还是按照原来的地址进行寻址，会找不到符号的定义，从而产生链接的错误。因此需要进行重定位。</p>
<p>在生成全局符号表之后，链接器已经确认了所有符号的虚拟地址了，那么此时链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。</p>
</li>
<li><p><strong>如何知道什么指令需要重定位？</strong></p>
<p>在ELF目标文件中，有一个重定位表，记录这与重定位相关的信息，用来描述如何修改相应的段里的内容。因此每个<strong>要被重定位的ELF段都有一个重定位表</strong>。</p>
<p>举个例子：如果该文件的代码段<code>.text</code>需要重定位，那么ELF会生成一个重定位表，放在<code>.rel.text</code>中，如果是<code>.data</code>,那也会有<code>.rel.data</code>出现。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -r a.o   						<span class="comment"># 假设有个a.o的目标文件</span></span></span><br><span class="line">a.o: 	file formate elf32-i386</span><br><span class="line"></span><br><span class="line">RELOCATION RECORDS FOR [.text]			# .text段需要重定位</span><br><span class="line">OFFSET		TYPE			VALUE		# 这表明有两个重定位入口，以下两行展示了其偏移地址，类型和符号名称的信息</span><br><span class="line">0000001c	R_386_32	 	shared</span><br><span class="line">00000027	R_386_PC32		swap	</span><br></pre></td></tr></table></figure></li>
<li><p>重定位地址</p>
<ul>
<li>重定位入口：每个要被重定位的地方，在上面的代码中两行代表两个入口。</li>
<li>偏移： 重定位入口在该段的偏移地址，即该段中需要被调整的位置。</li>
</ul>
</li>
<li><p><strong>符号解析</strong></p>
<p>还是按照上面那个例子，如果直接汇编执行<code>a.o</code>的话，会出现<code>shared</code>和<code>swap</code>两个符号没有被定义，从而链接错误。</p>
<p>通过在重定位中对符号进行解析，对需要重定位的符号查询全局符号表，找到相应的符号和符号地址进行重定位。</p>
</li>
</ol>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><ul>
<li><p>申请方式：栈是系统自动分配，堆是程序员主动申请。</p>
</li>
<li><p>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，<strong>堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除</strong>，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</p>
</li>
<li><p>栈在内存中是<strong>连续</strong>的一块空间（向低地址扩展）<strong>最大容量是系统预定好的</strong>，<strong>堆在内存中的空间（向高地址扩展）是不连续的</strong>。</p>
</li>
<li><p>申请效率：栈是有<strong>系统自动分配，申请效率高，但程序员无法控制</strong>；堆是由<strong>程序员主动申请，效率低，使用起来方便但是容易产生碎片</strong>。</p>
</li>
<li><p>存放的内容：<strong>栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制</strong>。</p>
</li>
</ul>
<h4 id="对象创建限制在堆或栈上"><a href="#对象创建限制在堆或栈上" class="headerlink" title="对象创建限制在堆或栈上"></a>对象创建限制在堆或栈上</h4><p>说明：C++ 中的类的对象的建立分为两种：静态建立、动态建立。</p>
<ul>
<li>静态建立：<strong>由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象</strong>。例如：A a;</li>
<li>动态建立：<strong>使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配</strong>；然后，调用类的构造函数创建对象。</li>
</ul>
<p>限制对象在堆上：</p>
<ul>
<li>将构造函数和析构函数设置为<code>protected</code>（对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成private。）</li>
<li>使用一个静态函数完成构造，（因为该对象还没有被创建，所以想使用类内的方法必须得是<code>static</code>函数，这点和单例模式一样）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> A *<span class="title">create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>限制对象在栈上：</p>
<ul>
<li>直接将<code>operator new</code> 和 <code>operator delete</code>给<code>=delete</code>标识。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span> </span>= <span class="keyword">delete</span>;  	<span class="comment">// 注意函数的第一个参数和返回值都是固定的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>= <span class="keyword">delete</span>; 	<span class="comment">// 重载了 new 就需要重载 delete</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="malloc的底层实现"><a href="#malloc的底层实现" class="headerlink" title="malloc的底层实现"></a>malloc的底层实现</h4><p>先简单说一说，malloc底层是使用了brk和mmap系统调用。</p>
<p>brk系统调用是通过进程向内核申请一个小数据堆，使得进程地址空间内堆空间扩展，然后再通过mmap系统调用创建一个新的线性地址区间。</p>
<p>malloc是在堆上进行内存分配的函数。进程可以通过<strong>增加堆的大小来分配内存，堆是一段长度可变的连续虚拟内存，始于进程的未初始化数据段末尾，随着内存的分配和释放而增减（见下图)。通常将堆的当前内存边界称为“program break”。</strong></p>
<ul>
<li><p>brk：</p>
<p>改变堆的大小（即分配或释放内存），其实就是命令内核改变进程的program break位置。最初，program break正好位于未初始化数据段末尾之后（如下图所示，与&amp;end位置相同）。</p>
<p>在program break的位置抬升后，<strong>程序可以访问新分配区域内的任何内存地址，而此时物理内存页尚未分配。内核会在进程首次试图访问这些虚拟内存地址时自动分配新的物理内存页。</strong></p>
<p>（实际上就是将堆的头指针往高地址延伸，从而能够获得新的虚拟地址）</p>
<img src="/posts/3e94d9ed/brk.jpg" class title="brk"></li>
<li><p>mmap： 创建一个新的线性地址区间，如果两个地址区间访问权限相同，那么会合并为一个区间。</p>
</li>
</ul>
<p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p>《C陷阱与缺陷》</p>
</li>
<li><p>《程序员的自我修养——链接、装载与库》</p>
</li>
<li><p>《Linux内核设计与实现》</p>
</li>
<li><p><a href="https://www.zhihu.com/question/21098367">知乎回答：brk和sbrk所指的program break到底是什么？</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/posts/16518a5d/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章来介绍一种在栈的应用——单调栈，单调栈本质还是栈，只不过是在每次新元素入栈后，栈内的元素都保持单调（单调递增或者递减）。</p>
<p>单调栈的用途并不广泛，只是用来处理一种情况——Next Greater Element，不过在处理这种典型问题上还是很有效率的，因此特来记录一下。</p>
</blockquote>
<span id="more"></span>



<h3 id="解题模板"><a href="#解题模板" class="headerlink" title="解题模板"></a>解题模板</h3><p>单调栈，就是栈内元素都是单调呈现的，如果新加入的节点不符合单调性的话，则将栈内的节点弹出，直到最后形成单调区间。</p>
<h4 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h4><p>首先来看下这道题目。这类题目是使用单调栈的最常使用情况——下一个更大/小问题。</p>
<p>我们可以将数组抽象成正在排队的人，下一个更大的元素就是往后看看到的比自己高的第一个人。</p>
<p>这样的话可以通过题目，写出代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(num.size())</span></span>;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt;= nums[i])&#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是单调队列解决问题的模板。由于是找下一个最大的，然后用的又是栈，因此for循环要从后往前扫描元素，倒着入栈，正着出栈。</p>
<h4 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h4><p>这个题目是延伸：处理循环数组——倍增数组。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LFU</title>
    <url>/posts/3be3e04e/</url>
    <content><![CDATA[<blockquote>
<p>LFU全程Least Frequently Used, 每次淘汰那些使用次数最少的数据。LFU相较于LRU，实现较难，考虑因素也更多。不过这些经典算法套路都是固定的，关键在于逻辑较复杂，不太容易一次就能写出漂亮且没有bug的代码。</p>
</blockquote>
<span id="more"></span>

<h4 id><a href="#" class="headerlink" title></a></h4><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>首先写出一个类，接受<code>capacity</code>参数，实现<code>get()</code>和<code>put()</code>方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="keyword">int</span> capacity):<span class="built_in">cap_</span>(capacity) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个接口和LRU一致，get方法会去缓存中查询键key，如果key存在，则返回key对应的val,否则返回-1；put方法则插入或修改缓存。如果key已存在，则将它对应的值改为val，如果不存在，则插入键值对(key, val)。</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>LFU的一些逻辑要求</p>
<ul>
<li><p>LFU加入了一个<code>freq</code>频率参数，缓存中的数据是靠freq进行排序的。</p>
</li>
<li><p>如果是调用get和put，该key的freq就要加1。</p>
</li>
<li><p>如果容量满了进行插入，则需要将freq最小的key删除，如果最小的freq对应多个key，则删除其中最旧的那个。</p>
</li>
</ul>
<p>要想在O(1)时间内解决这些问题，需要逐个击破：</p>
<ul>
<li><p>关于最基本的get和put，那么需要和LRU一样拥有一个<code>HashMap</code>存储<code>key</code>到<code>value</code>的映射，这样就可以快速操作<code>get(key)</code></p>
</li>
<li><p>加入freq，而且缓存中数据靠freq排序，这就说明一定要有个 <strong><code>freq</code>到<code>key</code>的映射</strong></p>
</li>
<li><p>要想在容量满的时候快速删除freq最小的key，这需要使用一个变量来指明最小freq，使用变量<code>minFreq</code></p>
</li>
<li><p>如果最小的freq对应多个key，而且要删除最旧的，我们可以用<strong>双向链表</strong>结构来存放一个freq对应的多个key</p>
</li>
<li><p>如果最小的freq只对应一个key，删除完之后需要minFreq++</p>
</li>
</ul>
<p>总结一下：我们可以用Node节点来存储{key, value, freq},这样 LFU所用到的数据结构有一个以key为索引的哈希映射和一个以freq为索引的哈希链表。</p>
<h3 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><p>这样接口如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">int</span> freq;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> value, <span class="keyword">int</span> freq) : <span class="built_in">key</span>(key), <span class="built_in">value</span>(value), <span class="built_in">freq</span>(freq) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LFUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">cap_</span>(capacity), <span class="built_in">minFreq_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		keyToNode.<span class="built_in">clear</span>();</span><br><span class="line">		freqToNode.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cap_ == <span class="number">0</span>) <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = keyToNode.<span class="built_in">find</span>(key);</span><br><span class="line">		<span class="keyword">if</span> (it == keyToNode.<span class="built_in">end</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">increaseFreq</span>(key);</span><br><span class="line">		<span class="keyword">return</span> keyToNode[key]-&gt;value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(keyToNode.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">			keyToNode[key]-&gt;value = value;</span><br><span class="line">			<span class="built_in">increaseFreq</span>(key);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(keyToNode.<span class="built_in">size</span>() == cap_) &#123;</span><br><span class="line">				<span class="comment">// 容量已经满了,删除频率最小时序最差的node</span></span><br><span class="line">				<span class="built_in">deleteMinFreq</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 插入新值</span></span><br><span class="line">			freqToNode[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">			keyToNode[key] = freqToNode[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">            minFreq_ = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteMinFreq</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> cap_;</span><br><span class="line">	<span class="keyword">int</span> minFreq_;</span><br><span class="line">	<span class="comment">// 由于key和node是一对一的关系，因此是 unordered_map&lt;int, list&lt;Node&gt;::iterator&gt;</span></span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;::iterator&gt; keyToNode;</span><br><span class="line">	<span class="comment">// 由于freq和node是一对多的关系，因此是 unordered_map&lt;int, list&lt;Node&gt;&gt;</span></span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;&gt; freqToNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>上面的接口基本上把流程全部写出来了。</p>
<p>数据结构</p>
<ul>
<li>Node：存储{key，value，freq}。一个Node相当于是一个信息的最小单元，每个信息都拥有这三个信息。（该数据结构和LRU中的pair&lt;int,int&gt;对应）</li>
<li>keyToNode：以key为索引的哈希映射，由于每个key对应一条信息，因此只需要存储一个Node节点就行。这里还是和LRU一样，借助了iterator的优势，其映射值存储的只是一个迭代器，而无需将整个Node存储进该映射 ，因此其数据结构为<code>unordered_map&lt;int, list&lt;Node&gt;::iterator&gt;</code></li>
<li>freqToNode: 以freq为索引的哈希映射，由于每个freq会对应多个节点，而且是删除最低频率的最旧节点，因此和LRU一样依旧带有时序性，这样的话依旧使用一个双向链表来该哈希映射的值部分，因此其数据结构为<code>unordered_map&lt;int, list&lt;Node&gt;&gt;</code></li>
</ul>
<p>方法流程</p>
<ul>
<li><p><code>get()</code>：该方法依旧和LRU一样，如果链表中没有该<code>key</code>,则返回-1。如果有，<strong>将其频率提升，</strong>返回其value</p>
</li>
<li><p><code>put()</code>：该方法的主要思想也依旧和LRU相似，如下图所示</p>
<p><img src="/posts/3be3e04e/put%E6%B5%81%E7%A8%8B.jpg" class title="put()大致逻辑 }&lt;&#x2F;p&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;h3 id&#x3D;代码细节&gt;&lt;a href&#x3D;#代码细节 class&#x3D;headerlink title&#x3D;代码细节&gt;&lt;&#x2F;a&gt;代码细节&lt;&#x2F;h3&gt;&lt;p&gt;get和put方法调用了两个函数方法，一个是&lt;code&gt;increaseFreq(int key)&lt;&#x2F;code&gt; ，一个是&lt;code&gt;deleteMinFreq();&lt;&#x2F;code&gt;&lt;&#x2F;p&gt; &lt;p&gt;下面来实现他们的细节&lt;&#x2F;p&gt; <figure class=" highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 首先处理freqToNode</span></span><br><span class="line">		<span class="keyword">auto</span> node = keyToNode[key];</span><br><span class="line">		<span class="keyword">int</span> freq = node-&gt;freq;</span><br><span class="line">		<span class="keyword">int</span> val = node-&gt;value;</span><br><span class="line">		freqToNode[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">		<span class="comment">// 如果freq是一对一，则整个freq都要删掉</span></span><br><span class="line">		<span class="keyword">if</span>(freqToNode[freq].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			freqToNode.<span class="built_in">erase</span>(freq);</span><br><span class="line">			<span class="keyword">if</span> (minFreq_ == freq)</span><br><span class="line">				minFreq_++;</span><br><span class="line">		&#125;</span><br><span class="line">		freqToNode[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, val, freq + <span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 然后再处理keyToNode</span></span><br><span class="line">		keyToNode[key] = freqToNode[freq+<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteMinFreq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 删除MinFreq最旧的Node</span></span><br><span class="line">		<span class="keyword">auto</span> node = freqToNode[minFreq_].<span class="built_in">back</span>();</span><br><span class="line">		keyToNode.<span class="built_in">erase</span>(node.key);</span><br><span class="line">		freqToNode[minFreq_].<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">if</span>(freqToNode[minFreq_].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			freqToNode.<span class="built_in">erase</span>(minFreq_);</span><br><span class="line">			minFreq_++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table> &lt;p&gt;至此，一个完整的LFU实现了&lt;&#x2F;p&gt; <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">int</span> freq;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> value, <span class="keyword">int</span> freq) : <span class="built_in">key</span>(key), <span class="built_in">value</span>(value), <span class="built_in">freq</span>(freq) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LFUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">cap_</span>(capacity), <span class="built_in">minFreq_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		keyToNode.<span class="built_in">clear</span>();</span><br><span class="line">		freqToNode.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cap_ == <span class="number">0</span>) <span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = keyToNode.<span class="built_in">find</span>(key);</span><br><span class="line">		<span class="keyword">if</span> (it == keyToNode.<span class="built_in">end</span>())</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">increaseFreq</span>(key);</span><br><span class="line">		<span class="keyword">return</span> keyToNode[key]-&gt;value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(keyToNode.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">			keyToNode[key]-&gt;value = value;</span><br><span class="line">			<span class="built_in">increaseFreq</span>(key);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(keyToNode.<span class="built_in">size</span>() == cap_) &#123;</span><br><span class="line">				<span class="comment">// 容量已经满了,删除频率最小时序最差的node</span></span><br><span class="line">				<span class="built_in">deleteMinFreq</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 插入新值</span></span><br><span class="line">			freqToNode[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">			keyToNode[key] = freqToNode[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">			<span class="comment">// 设置最小频率</span></span><br><span class="line">			minFreq_ = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 首先处理freqToNode</span></span><br><span class="line">		<span class="keyword">auto</span> node = keyToNode[key];</span><br><span class="line">		<span class="keyword">int</span> freq = node-&gt;freq;</span><br><span class="line">		<span class="keyword">int</span> val = node-&gt;value;</span><br><span class="line">		freqToNode[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">		<span class="comment">// 如果freq是一对一，则整个freq都要删掉</span></span><br><span class="line">		<span class="keyword">if</span>(freqToNode[freq].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			freqToNode.<span class="built_in">erase</span>(freq);</span><br><span class="line">			<span class="keyword">if</span> (minFreq_ == freq)</span><br><span class="line">				minFreq_++;</span><br><span class="line">		&#125;</span><br><span class="line">		freqToNode[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, val, freq + <span class="number">1</span>));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 然后再处理keyToNode</span></span><br><span class="line">		keyToNode[key] = freqToNode[freq+<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteMinFreq</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 删除MinFreq最旧的Node</span></span><br><span class="line">		<span class="keyword">auto</span> node = freqToNode[minFreq_].<span class="built_in">back</span>();</span><br><span class="line">		keyToNode.<span class="built_in">erase</span>(node.key);</span><br><span class="line">		freqToNode[minFreq_].<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">if</span>(freqToNode[minFreq_].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			freqToNode.<span class="built_in">erase</span>(minFreq_);</span><br><span class="line">			minFreq_++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> cap_;</span><br><span class="line">	<span class="keyword">int</span> minFreq_;</span><br><span class="line">	<span class="comment">// 由于key和node是一对一的关系，因此是 unordered_map&lt;int, list&lt;Node&gt;::iterator&gt;</span></span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;::iterator&gt; keyToNode;</span><br><span class="line">	<span class="comment">// 由于freq和node是一对多的关系，因此是 unordered_map&lt;int, list&lt;Node&gt;&gt;</span></span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, list&lt;Node&gt;&gt; freqToNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> &lt;h3 id&#x3D;与LRU比较&gt;&lt;a href&#x3D;#与LRU比较 class&#x3D;headerlink title&#x3D;与LRU比较&gt;&lt;&#x2F;a&gt;与LRU比较&lt;&#x2F;h3&gt;&lt;ul&gt; &lt;li&gt;&lt;p&gt;概念上，LFU比LRU增加了一个频率的概念，相对复杂了不少。&lt;&#x2F;p&gt; &lt;&#x2F;li&gt; &lt;li&gt;&lt;p&gt;数据结构上：&lt;&#x2F;p&gt; &lt;ul&gt; &lt;li&gt;LRU：由于LRU只需要考虑时序性和O(1)的get和put，因此其使用的数据结构就是一个双向链表&lt;code&gt;list&lt;pair(int,int)&gt;&lt;&#x2F;code&gt;（&lt;code&gt;pair&lt;int,int&gt;&lt;&#x2F;code&gt;作为一个node）和一个{key: node}的哈希映射，node的话可以使用迭代器进行优化成&lt;code&gt;unordered_map&lt;int, list&lt;pair(int,int)&gt;::iterator&gt;&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt; &lt;li&gt;LFU：&lt;ul&gt; &lt;li&gt;首先LFU增加了一个频率&lt;code&gt;freq&lt;&#x2F;code&gt;变量，因此不使用pair&lt;int,int&gt;存储{key，value}；而是使用Node(key, value, freq)存储节点信息。&lt;&#x2F;li&gt; &lt;li&gt;关于主要的哈希映射{key：node}，由于都是一对一的映射，因此和LRU一样使用&lt;code&gt;unordered_map&lt;int, list&lt;Node&gt;::iterator&gt;&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt; &lt;li&gt;LFU的特点是&lt;strong&gt;增加了一个以频率为索引的哈希映射&lt;&#x2F;strong&gt;，由于频率映射可能有一对多的情况，就不能是{freq : node}了，而必须使用{freq : list&lt;Node&gt;}，因此LFU新增了一个哈希映射&lt;code&gt;unordered_map&lt;int, list&lt;Node&gt;&gt;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;li&gt; &lt;li&gt;&lt;p&gt;接口实现上：&lt;&#x2F;p&gt; &lt;p&gt;两个接口的流程和逻辑基本相同，不过LFU中&lt;strong&gt;调用函数接口相应freq也会增加&lt;&#x2F;strong&gt;，相应所需的功能封装在&lt;code&gt;void increaseFreq(int key)&lt;&#x2F;code&gt;中。&lt;&#x2F;p&gt; &lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;h3 id&#x3D;参考资料&gt;&lt;a href&#x3D;#参考资料 class&#x3D;headerlink title&#x3D;参考资料&gt;&lt;&#x2F;a&gt;参考资料&lt;&#x2F;h3&gt;&lt;p&gt;《labuladong的算法小抄》&lt;&#x2F;p&gt;"></p></li></ul>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LFU</tag>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/posts/28239a8d/</url>
    <content><![CDATA[<h4 id="对OOP的理解"><a href="#对OOP的理解" class="headerlink" title="对OOP的理解"></a>对OOP的理解</h4><p>​    面向对象是一种将数据封装成类，针对类进行操作的方法。其核心思想是数据抽象、继承和动态绑定。（这也是oop的三大特性）</p>
<ul>
<li>封装：通过数据抽象，可以将类的接口与实现分离，同时对外界隐蔽类内的实现细节，只提供接口；</li>
<li>继承：可以定义相似的类型并对其相似关系进行建模，将相似类联系在一起构成一种层次关系，层次关系根部叫做基类，其他继承该类的叫做派生类；</li>
<li>多态：使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一方式使用它们的对象。</li>
</ul>
<h4 id="explict-显示-关键字"><a href="#explict-显示-关键字" class="headerlink" title="explict(显示)关键字"></a>explict(显示)关键字</h4><ul>
<li>explicit 修饰构造函数时，可以<strong>防止隐式转换和复制初始化</strong>（一般来说是用来</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">按语境转换</a> 除外</li>
</ul>
<h4 id="重载、重写、隐藏的区别"><a href="#重载、重写、隐藏的区别" class="headerlink" title="重载、重写、隐藏的区别"></a>重载、重写、隐藏的区别</h4><ul>
<li><p>重载：是指同一访问去内被声明几个具有不同参数（有const和无const也算）的同名函数，根据参数列表来调用哪个函数，<strong>重载不关心函数返回类型</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span>)</span></span>;			<span class="comment">// 重载</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">A</span><span class="params">()</span> <span class="keyword">const</span>	<span class="comment">// 重载</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>;			<span class="comment">// 不是重载，因为重载不在意返回类型，这个函数声明会报错</span></span><br></pre></td></tr></table></figure>

<p>重载其实在编译器是有差别的，在编译器每个重载函数的函数名是独一无二的，根据参数能定位到具体的函数。<strong>函数签名包含了一个函数的信息</strong>，包括函数名、它的类型参数，它所在的类和名称空间及其他信息。</p>
</li>
<li><p>隐藏：是指<strong>派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏</strong>。（只要是同名函数，就会被隐藏）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp, <span class="keyword">float</span> tmp1)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp, float tmp1)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun(int tmp)&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 隐藏基类中的同名函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive ex;</span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>);       <span class="comment">// Derive::fun(int tmp)</span></span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>, <span class="number">0.01</span>); <span class="comment">// error: candidate expects 1 argument, 2 provided 基类函数被隐藏了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>重写（override）：是指<strong>派生类中存在重新定义的函数</strong>。<strong>函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。</strong>派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有 virtual 修饰。（重写是动态多态）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; &#125; <span class="comment">// 重写基类中的 fun 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    p-&gt;<span class="built_in">fun</span>(<span class="number">3</span>); <span class="comment">// Derived::fun(int) : 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>重写和重载的区别：</p>
<p>范围区别：对于类中函数的重载或者重写而言，<strong>重载发生在同一个类的内部，重写发生在不同的类之间</strong>（子类和父类之间）。<br>参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。<br>virtual 关键字：<strong>重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。</strong></p>
</li>
<li><p>隐藏和重写，重载的区别：</p>
<p>范围区别：隐藏与重载范围不同，隐藏发生在不同类中。<br>参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。</p>
</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态：多态其实是不同继承类的对象，对同一消息做出不同的响应。多态分为静态多态和动态多态。</p>
<ul>
<li>静态多态：是指在编译期发生的多态。编译期的多态有两种实现方法，一种上面的重载，对象调用相同的函数名执行的不同的函数体。这个不赘述；另外一种是通过泛型编程，不同类型的对象参数能够使用同一个泛型模板。</li>
<li>动态多态：是指在运行期发生的多态。运行期多态是我们日常生活中说的多态，指的是基类的函数通过<code>virtual</code>关键字修饰后，在派生类重写该函数，运行时会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，那就调用派生类的函数，否则就调用基类的函数。</li>
</ul>
<p>实现方法： 多态是通过虚函数实现的，虚函数的地址保存在<strong>虚函数表中</strong>，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</p>
<p>实现过程：</p>
<ul>
<li>在类中用 virtual 关键字声明的函数叫做虚函数；</li>
<li>存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，<strong>该对象</strong>有一个指向虚函数表的<strong>虚表指针</strong>（<strong>虚函数表和类对应的，虚表指针是和对象对应</strong>）；</li>
<li>当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">	p-&gt;<span class="built_in">fun</span>(); <span class="comment">// Derive::fun() 调用派生类中的虚函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基类的虚函数表如下</p>
<img src="/posts/28239a8d/%E8%99%9A%E5%87%BD%E6%95%B01.png" class title="基类虚函数表">

<p>派生类的虚函数表如下</p>
<img src="/posts/28239a8d/%E8%99%9A%E5%87%BD%E6%95%B02.png" class title="派生类虚函数表">

<p>简单解释：当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数 Derive::f() 进行调用。</p>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>​    上个回答我们已经知道了什么是虚函数，那么什么是纯虚函数呢？</p>
<p>纯虚函数：</p>
<ul>
<li><p>纯虚函数在类中声明时，加上 =0；</p>
</li>
<li><p><strong>含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法</strong>；</p>
</li>
<li><p>继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。</p>
</li>
</ul>
<p>说明：</p>
<ul>
<li><strong>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型</strong>；</li>
<li>可以声明抽象类指针，可以声明抽象类的引用；</li>
<li><strong>子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。</strong></li>
</ul>
<p>与虚函数的区别：</p>
<ul>
<li>使用方式不同：虚函数可以直接食用，纯虚函数必须在派生类中实现后才能使用</li>
<li>定义形式不同：纯虚函数得加个 <code>=0</code></li>
<li>虚函数必须实现，否则会报错。</li>
<li>析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</li>
</ul>
<p>虚函数的实现机制</p>
<p>虚函数通过<strong>虚函数表</strong>来实现。<strong>虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”）</strong>，通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。</p>
<p>虚函数表相关知识点：</p>
<p>虚函数表存放的内容：类的虚函数的地址。<br>虚函数表建立的时间：<strong>编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中</strong>。<br>虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</p>
<p>注：虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。</p>
<h4 id="构造函数和虚构函数是否定义为虚函数？"><a href="#构造函数和虚构函数是否定义为虚函数？" class="headerlink" title="构造函数和虚构函数是否定义为虚函数？"></a>构造函数和虚构函数是否定义为虚函数？</h4><p>构造函数不能定义为虚函数，原因如下：</p>
<ul>
<li>从存储空间角度来看，构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用，但是调用构造函数的时候该函数还未创建，因此无法进行虚函数的调用。</li>
<li>从实用角度来看，虚函数是基类的指针指向派生类的对象是，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。</li>
<li>从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。</li>
<li>从类型上考虑：在创建对象时必须明确其类型。</li>
</ul>
<p>析构函数一般必须得定义为虚函数，原因如下：</p>
<ul>
<li><strong>防止内存泄漏</strong>，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。</li>
</ul>
<h4 id="拷贝构造函数的参数为什么必须加引用"><a href="#拷贝构造函数的参数为什么必须加引用" class="headerlink" title="拷贝构造函数的参数为什么必须加引用"></a>拷贝构造函数的参数为什么必须加引用</h4><p>拷贝构造函数一般如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">const</span> A&amp; tmp);				<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;tmp);		<span class="comment">// 赋值函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果其中的<code>A(const A&amp; tmp)</code> 变为<code>A(const A temp)</code>,那么<code>const A temp</code>这个形参和实参<code>A b(a)</code>相结合的时候是<strong>要调用本类的拷贝构造函数，这样的话就成了死循环！</strong></p>
<img src="/posts/28239a8d/cpctor.jpg" class title="复制构造循环引用">

<h4 id="为什么会使用初始化列表？"><a href="#为什么会使用初始化列表？" class="headerlink" title="为什么会使用初始化列表？"></a>为什么会使用初始化列表？</h4><ul>
<li><p>当没有初始化列表之前，对象的成员变量初始化动作是在调用默认构造函数的时候发生的，因此对成员变量初始化，最开始是必须得调用一次默认构造函数。</p>
</li>
<li><p>当有了初始化列表之后，能在变量初始化的过程中少使用一次默认构造函数，而是直接调用该成员变量的相应构造函数，调用相应构造函数之前首先调用默认的构造函数为成员变量设置初值，进入函数体后，再调用构造函数。</p>
</li>
<li><p>总而言之就是少了一次默认构造函数调用，提高了构造函数的效率。</p>
</li>
</ul>
<h4 id="实例化一个对象需要哪几个阶段？"><a href="#实例化一个对象需要哪几个阶段？" class="headerlink" title="实例化一个对象需要哪几个阶段？"></a>实例化一个对象需要哪几个阶段？</h4><ol>
<li><p>分配空间</p>
<p>创建类的对象首先要为该对象分配内存空间。当然，不同的对象为其分配空间的时机未必相同。但是分配空间是第一步。</p>
</li>
<li><p>初始化</p>
<p>初始化发生在赋值之前，初始化列表优先于构造函数体内的代码执行。</p>
</li>
<li><p>赋值</p>
<p>对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在累的构造函数的函数体中。当执行完该函数体，也就意味着实例化完成了。</p>
</li>
</ol>
<p>总结：<strong>实例化对象就是为该对象分配空间到该对象执行完相应的构造函数这一段时间。</strong></p>
<h4 id="友元函数的作用及使用场景"><a href="#友元函数的作用及使用场景" class="headerlink" title="友元函数的作用及使用场景"></a>友元函数的作用及使用场景</h4><p>作用：<strong>友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制</strong>。通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。</p>
<p>友元实际上是一个破除面向对象封装的手段。</p>
<p>使用场景：</p>
<ul>
<li>普通函数定义为友元函数，使普通函数能够访问类的私有成员。</li>
<li>友元类：类之间共享数据。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>Cpp语法</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU</title>
    <url>/posts/154d371b/</url>
    <content><![CDATA[<blockquote>
<p>LRU全称Least Recently Used, 最少最近使用。该算法广泛应用在各个项目中，比如redis缓存，页面置换算法等。</p>
<p>本篇文章记录一下如何设计一个LRU数据结构。</p>
</blockquote>
<span id="more"></span>



<h3 id="算法介绍："><a href="#算法介绍：" class="headerlink" title="算法介绍："></a>算法介绍：</h3><p><strong>设计类的算法最大的困难点选取合适的数据结构</strong></p>
<ul>
<li><p>算法链接：<a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></p>
</li>
<li><p>算法介绍：Least Recently Used， 在O(1)时间复杂度内进行put和get两个操作。</p>
<p>put：将新数据放入LRU中； get：获得最近使用的数据。（放入的数据是一个键值对）</p>
</li>
<li><p>算法实现： 本题目就是为了设计一个LRU数据结构。这个数据结构首先需要接收一个capacity参数作为缓存最大容量。</p>
<p>这里的话我们可以用链表来存储数据，<code>list&lt;pair&lt;int,int&gt;&gt;</code>, 因为这里要实现O(1)的插入。 那要实现O(1)的查找该怎么办呢？用哈希表来实现。 总而言之，我们最后选用一个复合数据结构—–&gt; <strong>哈希链表</strong>（哈希表和链表组合）</p>
</li>
</ul>
<p>最终，经过分析，选取了哈希链表，但是如何利用C++的优势简化哈希双向链表的实现？ 我们可以采用迭代器<code>iterator</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap_;										<span class="comment">// cap_ save the capacity of lru</span></span><br><span class="line">    <span class="comment">// 传统双向链表</span></span><br><span class="line">    <span class="keyword">using</span> DoubleList = list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;; 		<span class="comment">// pair save (key, value);</span></span><br><span class="line">    DoubleList L;</span><br><span class="line">    <span class="comment">// 哈希表存储迭代器</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, DoubleList::iterator&gt; M; 	<span class="comment">// hashmap -&gt; &#123;key : iterator&#125;;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设计好了合适的数据结构，代码便只需要写接口就行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity):cap_(capacity) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 放入lru中的话，两种情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = M.find(key);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 1. 本身该key就在list中, 先把索引值删除</span></span><br><span class="line">        <span class="keyword">if</span>(it != M.end())</span><br><span class="line">            L.erase(it-&gt;second);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除完之后就转入第二种情况，链表中没有这个键值对。</span></span><br><span class="line">        <span class="comment">// 在链表最前面添加key,value 键值对</span></span><br><span class="line">        L.push_front(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并且将其在mp登记他</span></span><br><span class="line">        M[key] = L.begin();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果链表超过容量，那么删除最远的那组</span></span><br><span class="line">        <span class="keyword">if</span>(L.size() &gt; cap_)&#123;</span><br><span class="line">            <span class="keyword">int</span> key = L.back().first;</span><br><span class="line">            M.erase(key);</span><br><span class="line">            L.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 调用的话，记得调用完调用结果要放到首位去</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = M.find(key);</span><br><span class="line">        <span class="keyword">if</span>(it == M.end())   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = it-&gt;second-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除原先的位置并把其放到首位</span></span><br><span class="line">        L.erase(it-&gt;second);</span><br><span class="line">        L.push_front(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line"></span><br><span class="line">        M[key] = L.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap_;										<span class="comment">// cap_ save the capacity of lru</span></span><br><span class="line">    <span class="comment">// 传统双向链表</span></span><br><span class="line">    <span class="keyword">using</span> DoubleList = <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;; 		<span class="comment">// pair save (key, value);</span></span><br><span class="line">    DoubleList L;</span><br><span class="line">    <span class="comment">// 哈希表存储迭代器</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DoubleList::iterator&gt; M; 	<span class="comment">// hashmap -&gt; &#123;key : iterator&#125;;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至此，一个简易版的LRU算法就写好了，这个LRU算法不算难，但是由于之前的算法题目一般都是函数式编程，只需要设计好一个函数，在函数内实现功能。而这种算法设计相当于是在设计一个类，不仅仅要考虑到函数内的实现，其难点还在于如何设计一个良好的数据结构以及如何去应用它。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构</title>
    <url>/posts/85682d75/</url>
    <content><![CDATA[<blockquote>
<p>redis除了有sds外，还使用了一些常见的数据结构如链表，字典，跳跃表，整数集合和压缩列表等作为其底层数据结构。在使用的同时，Redis也对这些数据结构进行了一些优化。</p>
</blockquote>
<!--*more*-->



<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。 由于C语言没有内置这种数据结构，所以Redis构建了自己的链表实现。</p>
<p>使用场景：<strong>当一个列表键包含了数量比较多的元素，又或者列表中的包含的元素都是比较长的字符串时</strong>，Redis就会使用链表作为列表键的底层实现。</p>
<h4 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h4><p>链表我们都很熟悉，一般可以用一个struct来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双端链表节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>* value; <span class="comment">// node 节点值</span></span><br><span class="line">    ListNode* prev;	<span class="comment">// 前驱</span></span><br><span class="line">    ListNode* next; <span class="comment">// 后置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然只要使用多个<code>ListNode</code>就能够组成链表。但是这个双端链表给的信息不是很多，Redis一般使用这个Struct来表示节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;adlist.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">	<span class="comment">// 表头结点</span></span><br><span class="line">    ListNode* head;</span><br><span class="line">    <span class="comment">// 表尾结点</span></span><br><span class="line">    ListNode* tail;</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// 节点复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Redis的链表特性可以总结如下：</p>
<ul>
<li>双端：链表节点有<code>prev</code>和<code>next</code>指针，可以O(1)时间获取节点的前驱和后置节点。</li>
<li>无环：不是环状链表</li>
<li>带表头指针和表尾指针：有着head和tail节点</li>
<li>带链表长度计数器：<code> len</code>属性对链表进行技术，程序获得链表种节点数量的复杂度为O(1)</li>
<li>多态：<code>void* value</code> 节点值的类型多态。并且可以通过三个节点函数来设置类型。链表可以用于保存各种不同类型的值。</li>
</ul>
<h4 id="链表和链表节点的API"><a href="#链表和链表节点的API" class="headerlink" title="链表和链表节点的API"></a>链表和链表节点的API</h4><p>详情请见《Redis设计与实现》 P22</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典又称符号表，映射。是一种用于保存键值对的抽象数据结构。(key-value)</p>
<p>在字典中，一个key和一个value进行关联。<strong>每个key是独一无二的</strong>，用户通过寻找键来得到与之关联的值。</p>
<p>字典也是哈希键的底层实现之一。</p>
<h4 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h4><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对</p>
<ul>
<li><p>哈希表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dict.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    <span class="comment">// table是一个数组， 数组中存放的元素是一个指向dicEntry结构的指针</span></span><br><span class="line">    <span class="comment">// dicEntry 结构保存着一个键值对</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>哈希表节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">  	<span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span>* key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向下一个哈希表节点，形成链表</span></span><br><span class="line">    <span class="comment">// 这个指针可以将多个 哈希值相同 的键值对链接在一起，一次来解决键冲突的问题</span></span><br><span class="line">    dicEntry *next;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure></li>
<li><p>字典</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dicType* type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> privdata;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="comment">// 字典只使用ht[0], h[1]哈希表会在对ht[0]哈希表进行rehash时使用。</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当rehash不在进行时，设置为-1</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx;      <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>type属性是一个指向<code>dicType</code>的指针，每个<code>dicType</code>结构保存了一簇用于操作特定类型键值对的函数，Redis会为<strong>用途不同的字典设置不同的类型特定函数。</strong></li>
<li>而<code>privdata</code>属性则保存了需要传给那些<strong>类型特定函数的可选参数</strong> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">	<span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* key)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*keyDup) (<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span>* key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span>* (*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span>* obj);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare) (<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span>* key1, <span class="keyword">const</span> <span class="keyword">void</span>* key2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor) (<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 销毁值得函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor) (<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>​    当需要将一个键值对添加到字典中，程序需要先根据键值对的KEY计算出哈希值和索引值，再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的制定索引上面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"><span class="comment">// ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemark;</span><br></pre></td></tr></table></figure>

<pre><code> Redis使用MurmurHash2算法来计算键的哈希值，这个算法的更多信息可以参考该算法的主页：[MurmurHash2算法](http://code.google.com/p/smhasher)
</code></pre>
<h4 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h4><p>​    <strong>键冲突是指当有两个或以上数量的键被分配到了哈希数组的同一索引上面。</strong>Redis使用<strong>链地址法</strong>来解决键冲突。Redis出于速度考虑，程序总是将新节点添加到链表的表头位置（复杂度为O(1)）。</p>
<h4 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h4><p>rehash实际上就是二次哈希</p>
<ul>
<li><p>rehash的目的：随着操作不断执行，哈希表保存的键值对会逐渐地增多或者减少，<strong>为了让哈希表的负载因子（load factor）维持在一个合理的范围之内</strong>，当<strong>哈希表保存的键值对数量太多或者太少</strong>时，程序需要对哈希表的大小进行相应的扩展或收缩，这个时候用到了rehash。</p>
</li>
<li><p>rehash的步骤：</p>
<ul>
<li>为字典ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）<ul>
<li>如果执行<strong>扩展</strong>操作， *<em>ht[1]的大小为第一个大于等于ht[0].used <em>2 的 2^n</em></em>(2的n次方幂)</li>
<li>如果执行<strong>收缩</strong>操作，<strong>ht[1]的大小为第一个大于等于ht[0].used 的 2^n</strong>（二者是除以2的关系）</li>
</ul>
</li>
<li>将保存在ht[0]中的所有键值对rehash到ht[1]上面：<strong>rehash指的是重新计算键的哈希值和索引值，然后将键值对房知道ht[1]的指定位置上。</strong></li>
<li><strong>当ht[0]上全部键值对都转移到ht[1]上之后，释放ht[0],将ht[1]设置为ht[0], ht[1]设置为空白哈希表，为下一次rehash做好准备。</strong>（相当于ht[1]是一个后备缓存）</li>
</ul>
</li>
<li><p>扩展收缩的条件</p>
<ul>
<li><p>扩展操作条件</p>
<ul>
<li>服务器目前<strong>没有</strong>执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，并且负载因子大于等于1</li>
<li>服务器目前<strong>正在</strong>执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，并且负载因子大于等于5</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面两个命令相当于服务器正在创建服务器进程的子进程，由于写时复制的问题，在子程序存在期间，服务器会提高执行扩展操作使用的负载因子。从而避免在子进程存在期间进行扩展操作，以此节约内存。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span></span><br><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure></li>
<li><p>收缩操作条件： 负载因子小于等于0.1</p>
</li>
</ul>
</li>
</ul>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>​    <strong>rehash动作不是一次性完成的，而是分多次、渐进式的完成。</strong>（如何渐进式完成，通过索引计数器）</p>
<ul>
<li><p>渐进式rehash步骤</p>
<ul>
<li>为ht[1]分配空间，让字典同时持有两个hash表</li>
<li>字典中维持的索引计数器变量<code>rehashidx</code>从-1变为0，表示rehash工作正式开始</li>
<li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定操作以外，还会<strong>顺带ht[0]哈希表在<code>rehashidx</code>索引上的所有键值对rehash到ht[1]</strong>,当rehash工作完成之后，程序将<code>rehashidx</code>属性自增1</li>
<li>随着字典不断执行，ht[0]所有键值对都会被rehash至ht[1],这时程序将<code>rehashidx</code>属性设置为-1</li>
</ul>
<p>索引计数器从-1到0开始，完成之后置为-1。</p>
</li>
</ul>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>​    <strong>跳跃表是一种有序数据结构，通过在每个节点维持多个指向其他节点的指针，从而达到快速访问节点的目的。</strong></p>
<p>​    跳跃表TC： 平均O(logN)，最坏 O(N)进行节点查找，可以通过顺序性操作来批量处理节点。（效率高，大部分和平衡树媲美，但是比平衡树简单）</p>
<p>​    <strong>一般用于有序集合键的底层实现</strong>，或者用于集群节点中作为内部数据结构。</p>
<p>(特点：通过每个节点维持指向其他节点的指针来维持有序行)</p>
<h4 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h4><p>redis的跳跃表有以下两个结构定义，其中一个结构用于表示跳跃表的节点，另外一个结构表示跳跃表的相关信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;redis.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳跃表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>* <span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>* <span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳跃表节点相关信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>* <span class="title">header</span>;</span>	<span class="comment">// 指向跳跃变的表头节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>* <span class="title">tail</span>;</span>	<span class="comment">// 指向跳跃表的表尾节点</span></span><br><span class="line">    <span class="keyword">int</span> level;				<span class="comment">// 记录跳跃表内，层数最大的那个节点层数（表头节点不计算在内）O(1)</span></span><br><span class="line">    <span class="keyword">int</span> length;				<span class="comment">// 记录跳跃表的长度，即包含节点的数量（表头节点不计入在内） O(1)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>跳跃表节点：</p>
<ul>
<li><p>层： 跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，<strong>层的数量越多，访问其他节点速度越快。</strong> 每次创建一个新跳跃表节点，程序根据幂次定律（越大的数出现概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是<strong>层的高度</strong></p>
</li>
<li><p>前进指针：每个层都有指向表尾方向的前进指针(level[i].forward)，用于从表头向表尾方向访问节点。（前进指针有多个）</p>
</li>
<li><p>跨度： 用于记录两个节点之间的距离：</p>
<ul>
<li>两个节点之间跨度越大，相距越远。</li>
<li>指向nullptr的跨度都为0，因为没有连向任何节点。</li>
</ul>
</li>
<li><p>后退指针：用于表尾向表头访问的节点，<strong>每个节点只有一个后退指针，只能退一个节点</strong>，后退指针最多退到头指针的后一个指针（头指针退不到）</p>
</li>
<li><p>分值：跳跃表中<strong>所有节点都是按照分值从小到大来排序</strong></p>
</li>
<li><p>成员：<strong>obj属性，指向一个字符串对象，而字符串对象则保存着一个SDS值。</strong></p>
</li>
</ul>
</li>
</ul>
<p>另外可以保存相同分值的节点，分值相同的节点将按照成员对象在字典序中的大小进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较小的节点则会排在后面，<strong>成员对象一定是唯一的</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>跳跃表是有序集合的底层实现之一</li>
<li>Redis跳跃表由<code>zskiplist</code> 和<code>zskiplistNode</code> 两个结构组成，这两个结构一定要记得。</li>
<li>每个跳跃表节点的层数是1-32之间的随机数。</li>
<li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</li>
<li>节点按照分值大小排序，分值相同，则按照成员对象大小进行排序。</li>
</ul>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>​    整数集合<code>intset</code>是集合键的底层实现之一，当一个集合<strong>只包含整数值元素，并且这个集合的元素数量不多</strong>时，Redis会将其作为集合键的底层实现。</p>
<h4 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h4><p>​    整数集合可以保存类型为<code>int16_t, int32_t或者 int64_t</code>的整数值，并且<strong>保证集合中不会出现重复元素</strong>（毕竟是set）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intset.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint_t</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>contents 数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项(items),各个项在数组中<strong>按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</strong></li>
<li>length属性记录了整数集合包含的元素数量。</li>
</ul>
<p>虽然contents数组类型是<code>int8_t</code>， 但是这数组并不保存任何<code>int8_t</code>类型的值，<strong>contents数组的真正类型取决于encoding属性的值。</strong></p>
<ul>
<li>encoding属性<ul>
<li>如果encoding属性的值为<code>INTSET_ENC_INT16</code>,那么contents就是一个<code>int16_t</code>类型数组大小。</li>
<li>同样的，如果为<code>INTSET_ENC_INT32</code>，则<code>int32_t</code>； 如果为<code>INTSET_ENC_INT64</code>，则<code>int64_t</code></li>
</ul>
</li>
</ul>
<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>​    当我们要<strong>将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时</strong>，整数集合需要先进行<strong>升级</strong>，才能将新元素添加到整数集合里去。</p>
<p>​    升级并添加新元素共分为三步：</p>
<ul>
<li><p>根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间（扩容）</p>
</li>
<li><p>将原有的元素转换成新元素的类型，并将类型转换后的元素放在正确的位上，在放置元素的过程中，<strong>底层数组有序性质不改变</strong>。（转类型）</p>
</li>
<li><p>将新元素加入底层数组。（添加新元素）</p>
</li>
</ul>
<p>由于引发升级的新元素的长度总是比整数集合现有所有元素的长度都打，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素。</p>
<ul>
<li>大于现有元素，插入到最后面</li>
<li>小于现有元素，插入到最前面</li>
</ul>
<p>升级的好处：</p>
<ul>
<li>提升整数集合的灵活性</li>
<li>节约内存</li>
</ul>
<h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p>​    <strong>整数集合不支持降级操作，一旦升级了，就算数组中的高位数被删除了，维持的依旧是高位。</strong></p>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>​    压缩列表是<strong>列表键和哈希键</strong>的底层实现之一。<strong>当列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表作为底层实现</strong>。</p>
<h4 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h4><p>​    压缩列表是为了节约内存而开发的，是由<strong>一系列特殊编码的连续内存块组成的顺序型数据结构。</strong>一个压缩列表可以包含任意多个节点，<strong>每个节点保存一个字节数组或者一个整数值</strong>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">|  属性     |   类型   |   长度   |          用途</span><br><span class="line">- zlbytes	 <span class="built_in">uint</span>32_t   <span class="number">4</span>bytes 		记录整个压缩列表占用的内存字节数：对压缩列表进行内存重分配或者计算zlend位置时使用。</span><br><span class="line">- zltail	 <span class="built_in">uint</span>32_t  	<span class="number">4</span>bytes		记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过该偏移量确定表尾节点位置-O(<span class="number">1</span>)</span><br><span class="line">- zllen      <span class="built_in">uint</span>16_t   <span class="number">4</span>bytes      记录压缩列表包含的节点数量，当节点数大于<span class="built_in">uint</span>16_MAX时,真实节点数必须遍历得到。</span><br><span class="line">- entryX 	 列表节点	  不定		压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</span><br><span class="line">- zlend 	 <span class="built_in">uint</span>8_t    <span class="number">1</span>bytes		特殊值<span class="number">0xFF</span>(<span class="number">255</span>),用于标记压缩列表的末端。</span><br></pre></td></tr></table></figure>



<h4 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h4><p>每个压缩节点可以保存一个<strong>字节数组或者一个整数值</strong>。</p>
<p>其中字节数组可以是一下三种长度之一</p>
<ul>
<li>长度小于等于63字节的字节数组 (2^6-1)</li>
<li>长度小于等于16383字节的字节数组(2^14-1)</li>
<li>长度小于等于2^32-1字节的字节数组</li>
</ul>
<p>整数值则可以是以下六种长度之一</p>
<ul>
<li>4位长，介于0-12的无符号整数</li>
<li>1字节长的有符号整数</li>
<li>3字节长的有符号整数</li>
<li>int16_t 类型整数</li>
<li>int32_t 类型整数</li>
<li>int64_t 类型整数</li>
</ul>
<p>每个压缩列表节点都有<code>previous_entry_length、 encoding、 content</code>组成</p>
<ul>
<li><p><code>previous_entry_length</code>: 以字节为单位，<strong>记录了压缩列表中的前一个节点的长度</strong>。（可以是1字节也可以是5字节，取决于前一个节点的长度）</p>
<p><strong>由于压缩列表是顺序型存储，当我们知道某个节点起始地址的指针，那么通过这个指针和<code>previous_entry_length</code>就可以往前回溯，最终达到头结点</strong></p>
</li>
<li><p><code>encoding</code>: 记录了节点的content属性所保存的类型以及长度</p>
<ul>
<li>值最高00,01,10这种编码表示节点content属性保存着的是字节数组</li>
<li>值最高位以11开头的是整数编码</li>
</ul>
</li>
<li><p><code>content</code>: 负责保存节点值。</p>
</li>
</ul>
<h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>​    由于压缩列表是顺序存放的，如果在<strong>一些临界值特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”</strong>。（在<code>previous_entry_length</code>的长度介于1字节和5字节之间的时候，添加节点或者删除节点，可能会造成连锁更新)</p>
<p>​    因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(N),所以连锁更新的最坏复杂度为O(N^2).但是最坏的情况基本不会发生，因此我们放心使用API，我们只要清楚知道什么是连锁更新，连锁更新做了什么就行。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Redis设计与实现》</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp语法</title>
    <url>/posts/14ad0c05/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章用问答的方式记录一些C++(11及11以前）常见的语法，常见语法包括基本关键字和一些基本的语法知识等。</p>
</blockquote>
<span id="more"></span>



<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h4><p>static关键字既可以修饰函数也可以修饰变量，用来定义静态函数和静态变量。其作用是根据其作用域来决定的。</p>
<ul>
<li><p>当static关键字的作用域为整个文件时(即全局静态变量/函数)</p>
<ul>
<li>该全局变量和函数只能被本文件所”看见“——<strong>全局静态变量只能在本文件中访问，全局静态变量函数只能在本文件中调用。在其他文件中是不可见的。</strong></li>
<li>该全局变量的生命周期是整个程序。</li>
</ul>
</li>
<li><p>当static关键字的作用域为一个类时（即类内静态成员变量/函数）</p>
<ul>
<li><p><strong>静态成员变量在类内进行声明，在类外进行定义和初始化，类外定义和初始化的时候不能带有static关键字</strong>。</p>
</li>
<li><p>静态成员变量是类作用域的全局变量，被所有类的对象共享，包括派生类的对象。因此计算对象大小要把static变量剔除。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof A = 4</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//	int b;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// sizeof B = 1</span></span><br></pre></td></tr></table></figure></li>
<li><p>静态成员在类第一次创建对象的时候就已经创建了，生命周期为类的生命周期。</p>
</li>
<li><p>静态成员变量可以作为成员函数的参数，因为在调用该函数的时候，静态成员变量已经被定义了</p>
</li>
<li><p><strong>静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> A s_var; <span class="comment">// 正确，静态数据成员</span></span><br><span class="line">    A var;          <span class="comment">// error: field &#x27;var&#x27; has incomplete type &#x27;A&#x27;</span></span><br><span class="line">    A *p;           <span class="comment">// 正确，指针</span></span><br><span class="line">    A &amp;var1;        <span class="comment">// 正确，引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>静态成员函数是类作用域的全局函数，<strong>没有this指针</strong>，因此不能调用非静态成员变量和非静态成员函数</p>
</li>
<li><p>静态成员函数不能被声明为虚函数，const函数和volatile函数，因为没有this指针，修饰它没有任何意义。</p>
</li>
</ul>
</li>
<li><p>当static的作用域为一个函数时，称为局部变量</p>
<ul>
<li>局部变量的生命周期为该函数，在函数定义时开始，从函数结束时结束</li>
</ul>
</li>
<li><p>static修饰的变量都被放在<code>.data</code>和<code>.bss</code>段</p>
</li>
</ul>
<h4 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h4><p><strong>作用</strong>：</p>
<ul>
<li><p>const 修饰<strong>成员变量</strong>，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。</p>
</li>
<li><p>const 修饰<strong>函数参数</strong>，使得传递过来的函数参数的值不能改变。</p>
</li>
<li><p>const 修饰<strong>成员函数</strong>，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用</p>
<p>非 const <strong>成员函数</strong>，因为非 const 成员函数可能会修改成员变量。</p>
</li>
</ul>
<p><strong>在类中的用法</strong>：</p>
<ul>
<li><p>const 成员变量：</p>
<ul>
<li>c<strong>onst 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化</strong>。</li>
<li>const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此<strong>不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。</strong></li>
</ul>
</li>
<li><p>const 成员函数：</p>
<ul>
<li>不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。</li>
<li>不能调用非常量成员函数，以防修改成员变量的值。</li>
<li>带const和不带const的函数是重载函数，并不会出问题。</li>
</ul>
</li>
</ul>
<p><strong>底层const和顶层const:</strong></p>
<ul>
<li>顶层const:  对象本身是const； （常量的定义就是一个top-level const的对象类型）</li>
<li>底层const：指针（对象本身）所指的对象是const（一般来说本身是个指针）</li>
</ul>
<p><strong>它和constexpr的区别:</strong></p>
<ul>
<li>const关键字只是在编译期编译器将其标记为一个常量，但是其具体的值并不清楚。</li>
<li>constexpr关键字在编译期不仅知道其为一个常量，还知道具体的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 在编译期，a被标记为整型常量，b被标记为整型数字4</span></span><br></pre></td></tr></table></figure>

<p><strong>它和define的区别：</strong></p>
<ul>
<li><p><strong>编译阶段</strong>：define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值。</p>
</li>
<li><p><strong>安全性</strong>：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</p>
</li>
<li><p><strong>内存占用</strong>：define 定义的宏常量，<strong>在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的局部常量在栈上，全局常量在<code>.data</code>段，程序运行过程中只有一份。</strong></p>
</li>
<li><p><strong>调试</strong>：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const 定义的常量可以进行调试。</p>
</li>
</ul>
<h4 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h4><ol>
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用this指针：<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
<h4 id="inline关键字"><a href="#inline关键字" class="headerlink" title="inline关键字"></a>inline关键字</h4><p>inline关键字用来修饰内联函数。</p>
<p><strong>内联函数的作用</strong>：</p>
<ul>
<li><p><strong>消除函数调用的开销。</strong><br>在内联函数出现之前，程序员通常用 #define 定义一些“函数”来消除调用这些函数的开销。内联函数设计的目的之一，就是取代 #define 的这项功能。</p>
</li>
<li><p><strong>去除函数只能定义一次的限制</strong>。<br><strong>内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。</strong></p>
</li>
</ul>
<p><strong>关于减少函数调用的开销：</strong></p>
<ul>
<li>内联函数一定会被编译器在调用点展开吗？<ul>
<li>错<strong>，inline 只是对编译器的建议，而非命令</strong>。编译器可以选择忽视 inline。当程序员定义的 inline 函数包含复杂递归，或者 inlinie 函数本身比较长，编译器一般不会将其展开，而仍然会选择函数调用。</li>
</ul>
</li>
<li>“调用”普通函数时，一定是调用吗？<ul>
<li>错，<strong>即使是普通函数，编译器也可以选择进行优化，将普通函数在“调用”点展开</strong>。</li>
</ul>
</li>
<li>既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？<ul>
<li>错。首先，如第一点所言，编译器可以选择调用内联函数，而非展开内联函数。因此，内存中仍然需要一份内联函数的定义，以供调用。<br>而且，一致性是所有语言都应该遵守的准则。普通函数可以有指向它的函数指针，那么，内联函数也可以有指向它的函数指针，因此，内存中需要一份内联函数的定义，使得这样的函数指针可以存在。</li>
</ul>
</li>
</ul>
<p><strong>关于去除函数只能定义一次的限制：</strong></p>
<ul>
<li><p>该程序会报错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;function 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;function 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">myPrint</span>();  <span class="comment">// error，会出现链接时错误， myPrint 函数被定义了两次。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用内联函数不会报错</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;inline function 1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;inline function 2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">myPrint</span>()	<span class="comment">// 正常运行;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>因此，<strong>内联函数可以在头文件中定义</strong>（即多个 .cpp 源文件可以定义函数名、参数都一样的内联函数，而不会有重定义错误）</p>
</li>
</ul>
<p><strong>内联函数缺点</strong>：</p>
<ul>
<li>导致代码膨胀</li>
<li>inline函数无法随着函数库升级，inline函数改变需要重新编译。</li>
<li>是否内联编译器说的算，程序员不可控。</li>
</ul>
<h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p><strong>volatile关键字的作用：</strong></p>
<ul>
<li>该关键字的作用很简单，仅仅是<strong>让编译器不会对相应的对象进行优化，即不会将变量从内存中写入寄存器中。</strong></li>
</ul>
<p><strong>延伸：</strong></p>
<ul>
<li>虽然作用很简单，但是这个作用让变量值一直在内存中，这样多线程对该变量进行操作的时候，就只能对该变量本身操作，而不会出现既操作内存又操作寄存器的场景，这样很可能会在操作变量时出错。</li>
<li><strong>volatile和原子性无关</strong></li>
</ul>
<p><strong>使用场景</strong>：</p>
<ul>
<li>当多线程都用到某一变量，而且该变量可能会改变时，那就用volatile关键字修饰它，防止操作出错。</li>
<li>中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用 <code>volatile</code> 关键字修饰。</li>
</ul>
<h4 id="new-free关键字"><a href="#new-free关键字" class="headerlink" title="new/free关键字"></a>new/free关键字</h4><p>new/free关键字是C++用来动态分配/释放内存空间的函数组。</p>
<p><strong>new/free函数</strong></p>
<p>new函数分为两个步骤</p>
<ul>
<li><strong>首先分配一块内存 （operator new 这个步骤和malloc是一样的（都是在堆上调用mmap系统调用，都是面向内存的）</strong></li>
<li><strong>然后针对对象类型进行构造 （placement new 这个步骤保证了new的类型安全</strong>）</li>
</ul>
<p>free则是反向操作。</p>
<p>和malloc/delete之间还有个差别是new/free自动计算分配空间大小，而malloc需要自己指定。</p>
<h4 id="std-move-和-std-forward是什么？std-forward为何可以称为完美转发"><a href="#std-move-和-std-forward是什么？std-forward为何可以称为完美转发" class="headerlink" title="std::move 和 std:forward是什么？std::forward为何可以称为完美转发"></a>std::move 和 std:forward是什么？std::forward为何可以称为完美转发</h4><p>std::move的作用很简单，只是将变量本身类型转换成<strong>右值引用类型（&amp;&amp;）</strong></p>
<p><strong>引用</strong></p>
<p>引用分为左值引用(&amp;)和右值引用（&amp;&amp;）。</p>
<ul>
<li><p>左值引用我们都很熟悉，在汇编层面相当于普通的指针，不过定义引用变量必须初始化，和一个对象或变量进行绑定。那如果是一个常数呢，左值引用就不行了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;var = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>因为数字10无法进行取地址操作，毕竟10存在寄存器中，而非在内存中，没有地址。</p>
<p>当然我们可以，const能够生成临时变量保存const，不过这样就不可能修改数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; var = <span class="number">10</span>;	</span><br></pre></td></tr></table></figure>

<p>于是c++引入了右值引用的概念</p>
</li>
<li><p>右值引用</p>
<ul>
<li>可以取地址的，有名字的，<strong>非临时</strong>的就是左值引用；</li>
<li>不能取地址的，没有名字的，<strong>临时</strong>，<strong>即将消散</strong>的就是右值引用；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; var = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>右值引用如果修饰对象的话，那么该对象之后会消失（析构）</p>
</li>
<li><p>类中使用</p>
<p>在类中在左值引用基础上引申出<strong>拷贝语义</strong>——拷贝构造函数和拷贝运算符，右值引用基础上引申出<strong>移动语义</strong>——移动构造函数和移动运算符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span>	<span class="comment">// 省略掉类内信息，具体语法在面向对象中详细说明  </span></span><br><span class="line">A a;</span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;		<span class="comment">// 如果是有拷贝语义，那么b复制了份a，现在内存中有两个A对象实例； </span></span><br><span class="line">  			<span class="comment">// 如果是有移动语义，那么就是将a移动到了b对象所有权下面，此时内存中只有一个A对象实例b</span></span><br></pre></td></tr></table></figure>

<p>拷贝语义：当使用拷贝构造函数创建对象的时候，相当于是复制了个对象。</p>
<p>移动语义：在内存层次将对象移动到新对象实例之中。</p>
<p><strong>拷贝操作是很昂贵的，因为要新建一个完全相同的对象，而移动操作只是控制对象从a移动到b，因此如果不需要保留a的情况下，尽量使用移动操作</strong></p>
</li>
</ul>
<p><strong>std::move</strong></p>
<p>​    说清楚了引用，剩下的都很好办，std::move只有一个作用，<strong>执行强制型别转换：无条件地将实参转换成右值。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上面代码是move的实现，就是进行static_cast转换成右值。不过当值转换成右值了，那么就可以进行移动操作了。</p>
<p><strong>std::forward</strong></p>
<p>​    T&amp;&amp;其实有两种含义，一种就是右值引用，另外一种就是既可以是右值引用，也可以是左值引用，称之为万能引用。但是后者一般要涉及到型别推导，当然涉及到形参推演只是一个必要条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;		<span class="comment">// 万能引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;		<span class="comment">// 万能引用</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果没型别推导</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A&amp;&amp; param)</span></span>;		<span class="comment">// 右值引用</span></span><br></pre></td></tr></table></figure>

<p>​    万能引用有一个规则：如果采用右值初始化万能引用，那么就会得到右值引用，如果采用左值初始化，那么得到的是左值引用。</p>
<p>std::forward和std::move一样，也只是强制型别转换：<strong>和一个可供移动的对象进行绑定，只有右值初始化时才会将该对象强制类型成右值型别。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span>&#123;</span><br><span class="line">    name = std::forward&lt;T&gt;(<span class="keyword">new</span> Name);		<span class="comment">// 万能引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这样</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span></span>&#123;</span><br><span class="line">    name = std::<span class="built_in">move</span>(<span class="keyword">new</span> Name);				<span class="comment">// 也是万能引用，但编译起来糟糕透顶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们必须遵循：<strong>针对右值引用实施std::move,针对万能引用实施std::forward</strong>，别用错了！！</p>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。</p>
<p><strong>智能指针的作用</strong></p>
<ul>
<li>智能指针的作用是管理一个指针，防止造成堆上的内存泄漏。</li>
<li>智能指针是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。</li>
<li>所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</li>
</ul>
<p><strong>auto_ptr</strong>(C98)</p>
<p>采取所有权模式，存在潜在的内存崩溃问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt; <span class="built_in">string</span>&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;I reigned lonely as a cloud.”));</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">// 此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。                                 </span></span></span></span><br></pre></td></tr></table></figure>



<p><strong>unique_ptr</strong>(替换auto_ptr)</p>
<p>依旧采取所有权模式，实现独占式拥有或严格拥有的概念。<strong>保证同一时间内只有一个智能指针可以指向该对象。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;A&gt;;		<span class="comment">// 会生成一个指向A特定实例的指针。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">unique_ptr 和 单例模式的区别</span></span><br><span class="line"><span class="comment">	-&gt; 会生成一个指向A特定实例的指针，unique_ptr&lt;A&gt;不会阻止创建其他A实例对象,</span></span><br><span class="line"><span class="comment">		即不能有两个unique_ptr&lt;A&gt;指向同一个对象</span></span><br><span class="line"><span class="comment">	-&gt; 单例模式是只能有一个A的实例对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;auto&quot;</span>))</span></span>;     </span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4;   	<span class="comment">// 	没问题，如果是单例的话这个时候就出问题了       </span></span><br><span class="line"></span><br><span class="line">p4 = p3;					<span class="comment">//	指向同一个对象，那此时会报错！！</span></span><br></pre></td></tr></table></figure>

<p>当然如果创建一个unique_ptr对象的话，不要用new，而是直接用<code>std::make_unique</code></p>
<p><strong>shared_ptr</strong></p>
<p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用<strong>引用计数机制来表明资源被几个指针共享</strong>。</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>
<p>当然如果创建一个share_ptr对象的话，不要用new，而是直接用<code>std::make_shared</code></p>
<p><strong>weak_ptr</strong></p>
<p>weak_ptr是一种不控制对象生命周期的智能指针，它指向一个 shared_ptr 管理的对象。</p>
<ul>
<li>进行该对象的内存管理的是那个强引用的 shared_ptr. <strong>weak_ptr只是提供了对管理对象的一个访问手段</strong>。</li>
<li>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。</li>
<li><strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。</strong>它是对对象的一种弱引用，不会增加对象的引用计数，<strong>可以和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</strong></li>
<li>不过不能通过weak_ptr直接访问对象，它只是针对shared_ptr相互引用的死锁问题而发明的一个弱引用方法。</li>
</ul>
<h4 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h4><p>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast。</p>
<p><strong>const_cast</strong></p>
<ul>
<li>用于将<strong>const变量转为非const</strong>（去除const的转换）</li>
</ul>
<p><strong>static_cast</strong></p>
<ul>
<li>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</li>
<li>static_cast基本上代替了一般的隐式转换，这个是最普遍的转换方式</li>
</ul>
<p><strong>dynamic_cast</strong>（运行期转换）</p>
<ul>
<li><p><strong>用于动态类型转换</strong>。只能用于含有虚函数的类，用于类层次间的向上和向下转化。<strong>只能转指针或引用</strong>。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p>
</li>
<li><p>向上转换：指的是子类向基类的转换</p>
</li>
<li><p>向下转换：指的是基类向子类的转换</p>
</li>
<li><p>它通过<strong>判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</strong></p>
</li>
</ul>
<p><strong>reinterpret_cast</strong></p>
<p>几乎什么都可以转，比如将int转指针。这个是将变量所在的内存重新解释，因此可能会出问题，尽量少用。</p>
<p><strong>为什么不使用C的强制转换？</strong></p>
<p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p>
<p>最后，遇到类型转换一定要养成用显示类型转换的好习惯。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li> 《C++ Primer》</li>
<li> 《Effective Modern C++》</li>
</ol>
<hr>
<p><em>此文档会一直增加新的知识点，如有错误，请不吝指出</em></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++语法</tag>
        <tag>C++关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O多路复用</title>
    <url>/posts/7ce262fd/</url>
    <content><![CDATA[<blockquote>
<p>在网络编程中熟知的一个方法。nignx和redis中都实现了该方法，属于网络编程中的基本概念</p>
</blockquote>
<span id="more"></span>



<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>​    I/O多路复用是指程序在单个线程内通过记录每个I/O流的状态，来同时管理多个I/O流。这样使得程序能够在单线程内同时监听多个文件描述符。</p>
<p>   不过值得注意的是，I/O复用虽然能同时监听多个文件描述符，但是其本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外措施，程序就只能按顺序依次处理其中的每个文件描述符。</p>
<p>​    虽然是能够在单个线程同时监听多个文件描述符，但是文件描述符就绪依旧是串行处理，明白这一点就不会将I/O多路复用和并发混淆，因为串行处理事件并不是并发。</p>
<p>​    I/O多路复用有三种熟知的具体实现，分别是Select，Poll 和 Epoll，下面来依次介绍它们。</p>
<h3 id="SELECT系统调用"><a href="#SELECT系统调用" class="headerlink" title="SELECT系统调用"></a>SELECT系统调用</h3><p>​    用途：在指定时间内，<strong>监听用户感兴趣的文件描述符上的可读，可写和异常事件</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">( <span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    由上面的API可以看出，nfds是感兴趣的fd总数，后面三个参数分别是三种fd的集合，最后一个时间参数是指定时间，如果超过时间直接返回。</p>
<pre><code> 而`fd_set`结构体仅仅包含一个整形数组，**该数组的每个元素的每一位标记一个fd。**fd_set能容纳的文件描述符最大数量优先，应该是2^16。
</code></pre>
<p>​    这是select最大的缺点：</p>
<ul>
<li><p><strong>每次去查看文件描述符的状态都要按位去轮询整个数组，O（N），效率不高</strong></p>
</li>
<li><p><strong>而且存储的文件描述符有上限，只能存储几万个</strong>（这个很少，fd的上限能够达到上百万个）</p>
</li>
<li><p>非线程安全</p>
</li>
</ul>
<h3 id="POLL系统调用"><a href="#POLL系统调用" class="headerlink" title="POLL系统调用"></a>POLL系统调用</h3><p>​    poll和select类似，也是在<strong>指定时间轮询一定数量的文件描述符</strong>，以测试其中是否有就绪者。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">  	<span class="keyword">int</span> fd;				<span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;		<span class="comment">// 注册的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents;		<span class="comment">// 活跃的事件，由内核填充</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    看到这个API其实和select也是有点差别的。</p>
<ul>
<li>存放文件描述符的数据结构从数组位变成了</li>
<li>事件类型区分更为细致，select只有三种时间类型，而poll将其细化了。如可读事件分为了POLLIN,POLLRDNORM, POLLDRBAND, POLLPRI四种。</li>
</ul>
<p>不过nfds和timoeout参数都和select相似，这里不赘述。</p>
<p>其缺点也和select类似，</p>
<ul>
<li>遍历所有fd，不活跃fd也会去检查它的状态，O(N)</li>
<li>线程不安全</li>
</ul>
<p>不过因为不是通过数组位存储，因此无上限太低的缺点。</p>
<h3 id="EPOLL系统调用"><a href="#EPOLL系统调用" class="headerlink" title="EPOLL系统调用"></a>EPOLL系统调用</h3><p>接下来就迎来主角了，epoll是Linux特有的I/O复用函数，其实现和前两者有较大差异。</p>
<p>优点</p>
<ul>
<li>epoll使用一组函数实现多路复用，前两者都只有单个函数</li>
<li>epoll将用户关心的文件描述符上的事件放在内核里的一个事件表中，无需O(N)，只需要O(1)地查看关心的事件</li>
<li>检查文件描述符是否就绪的方法更好，epoll采用回调的机制，而前两者采用的轮询机制，随着fd增加，回调效率不怎么降低，而轮询会大大降低。</li>
<li>线程安全</li>
</ul>
<p>略有瑕疵的缺点</p>
<ul>
<li>内核事件表需要额外一个文件描述符表示，浪费了一个文件描述符</li>
<li>只能在Linux上用</li>
</ul>
<h4 id="epoll事件表"><a href="#epoll事件表" class="headerlink" title="epoll事件表"></a>epoll事件表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该API创建一个内核事件表，返回与该事件表绑定的文件描述符。</strong>size无多大含义，只是通知内核告诉它事件表多大。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">  	<span class="keyword">uint32_t</span> events; 	<span class="comment">// epoll 事件</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;	<span class="comment">// 用户数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该API用来操作已创建的内核事件表。</strong></p>
<p>参数分析：</p>
<ul>
<li><p>epfd是负责内核事件表的文件描述符</p>
</li>
<li><p>fd是要操作的文件描述符，op是操作类型：</p>
<ul>
<li>EPOLL_CTL_ADD：往事件表注册fd上的事件</li>
<li>EPOLL_CTL_MOD：修改fd上的注册事件</li>
<li>EPOLL_CTL_DEL：删除fd上的注册事件</li>
</ul>
</li>
<li><p>event参数指定事件。事件类型存储在event-&gt;events中。epoll的事件类型和poll类似，只不过在前面加了个E，不过epoll有两种额外的事件——EPOLLET和EPOLLONESHOT。这个后面再讲。</p>
</li>
<li><p>返回值：成功回0，失败回-1并设置errno。</p>
</li>
</ul>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>​    epoll的主要接口是epoll_wait函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该API在一段超时时间内等待一组文件描述符上的事件。</strong></p>
<p>参数：</p>
<ul>
<li>maxevents 指定最多能够监听多少个事件，必须大于0</li>
</ul>
<p><strong>如果检测到事件</strong>，就将所有就绪的事件从内核事件表（由epfd指定）中复制到它的第二个参数events指向的数组中。<strong>这个数组只用于输出epoll_wait检测到的就绪事件，而不像前两者的数组参数那样即用于传入用户注册的事件，又用于输出检测的内核事件。这样极大提高了应用程序索引就绪文件描述符的效率。</strong>（目前还是LT模式的效率提升，因为是检测到事件就返回）</p>
<h4 id="ET和LT模式"><a href="#ET和LT模式" class="headerlink" title="ET和LT模式"></a>ET和LT模式</h4><p>​    epoll对fd的操作用两种模式:ET和LT。其中LT是默认工作模式，这个模式下就是效率提升版的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET时间事，epoll工作模式变成了ET，ET是epoll的高效模式。</p>
<p>​    采用LT模式时，如果检测到有事件发生时，epoll_wait将此事通知给应用程序，应用程序可以不处理它，但是下次调用epoll_wait依旧会通知应用程序来处理它。</p>
<p>​    而ET模式不同，ET模式当通知了应用程序，应用程序必须立即处理该事件，因为后续的epoll_wait调用不再向应用程序通知这一事件。这样一来极大降低了同一事件被重复触发的次数（但是可能通知了没处理直接被漏掉了吗？思考一下）</p>
<p>​    形象的说就是<strong>LT模式是传统的调用epoll_wait有活跃事件就触发（可读事件缓冲区不为空，可写事件缓冲区不满），而ET是增量触发，只有新事件到来才会通知应用程序。</strong></p>
<p>​    （ET必须是非阻塞的！）</p>
<h4 id="EPOLLSHOT事件"><a href="#EPOLLSHOT事件" class="headerlink" title="EPOLLSHOT事件"></a>EPOLLSHOT事件</h4><p>​    即使我们使用ET模式，<strong>一个socket上的某个事件还是可能被触发多次</strong>。这在并发程序中会引起一个问题。比如一个线程在读取完某个socket上的数据后开始处理这些数据，在处理数据过程中又有新数据可读，这样新的线程唤醒去读新数据，那么就出现了<strong>两个线程同时操作一个socket的局面</strong>。但是我们期望的是<strong>一个socket连接在任一时刻都只被一个线程处理。（因为这会导致线程同步问题）</strong></p>
<p>​    这里就可以采用EPOLLSHOT事件，对于注册该事件的fd，<strong>操作系统最多出发其上注册的一个可读、可写或者一长时间，且只触发一次。</strong>这样当一个线程处理这socket，其他线程不能处理该socket。</p>
<p>​    但是反过来思考一下，只触发一次，那下次怎么办？因此触发这一次之后要重置EPOLLSHOT事件，进而让其他工作线程之后有机会处理该socket</p>
<h3 id="三种系统调用的对比"><a href="#三种系统调用的对比" class="headerlink" title="三种系统调用的对比"></a>三种系统调用的对比</h3><p>​    这三组系统调用都通过某种结构体变量来告诉内核监听那些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">SELECT</th>
<th align="center">POLL</th>
<th align="center">EPOLL</th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用数据结构</td>
<td align="center">三个数组构成的位图</td>
<td align="center">统一数据结构<code>epollfd</code></td>
<td align="center">同一数据结构，内核注册表</td>
</tr>
<tr>
<td align="center">事件类型</td>
<td align="center">最基本的三种：可读、可写、异常</td>
<td align="center">带有优先级的事件类型，区分更细致</td>
<td align="center">和poll类似，多了ET和SHOT</td>
</tr>
<tr>
<td align="center">事件监听机制</td>
<td align="center">轮询</td>
<td align="center">轮询</td>
<td align="center">回调</td>
</tr>
<tr>
<td align="center">时间复杂度</td>
<td align="center">O(N)</td>
<td align="center">O(N)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">优点</td>
<td align="center">多平台可用，简单</td>
<td align="center">多平台可用，简单，上限比select高</td>
<td align="center">高效，LT模式下就是O(1)，ET模式下更是减少同一事件的多次触发，线程安全</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">低效，处理的fd有上限，非线程安全</td>
<td align="center">低效，非线程安全</td>
<td align="center">仅LINUX可用</td>
</tr>
</tbody></table>
<p><strong>PS：虽然epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</strong></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>I/O多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/posts/735e5788/</url>
    <content><![CDATA[<blockquote>
<p> 各类排序算法是一个很基础的算法概念，在面试当中，手撕排序算法也只算得上一道简单题。</p>
</blockquote>
<span id="more"></span>

<p>排序算法一般可分为 快速排序， 归并排序，插入排序，冒泡排序，选择排序和堆排序。（其中快排，归并和堆排序比较难，但是要掌握）</p>
<h3 id="C-中的std-sort"><a href="#C-中的std-sort" class="headerlink" title="C++中的std::sort"></a>C++中的<code>std::sort</code></h3><p>​    sort算法主体是一个快速排序，快速排序的时间复杂度为<code>O(NlogN)</code>，但是其对效率有了优化。</p>
<p>首先，快速排序在小区间的效率不如插入排序，因此在小空间的话，就用<strong>插入排序</strong>。 而且快速排序是基于递归的，因此如果数据过大，递归层数过大，这就要转入<strong>堆排序</strong> 。</p>
<p>然后，快速排序的效率取决于pivot的取法，如果pivot取得适中，那么效率最高。因此标准库里面用的是<strong>九取一，</strong>这可以尽可能使得pivot的取值更合理。</p>
<h3 id="经典排序模板"><a href="#经典排序模板" class="headerlink" title="经典排序模板"></a>经典排序模板</h3><h4 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.     快速排序"></a>1.     快速排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// key is the pivot element </span></span><br><span class="line">	<span class="keyword">auto</span> first = l, last = r - <span class="number">1</span>, key = nums[first];</span><br><span class="line">	<span class="keyword">while</span>(first &lt; last) &#123;</span><br><span class="line">		<span class="comment">// deal with the element from the last</span></span><br><span class="line">		<span class="keyword">while</span> (first &lt; last &amp;&amp; nums[last] &gt;= key) &#123;</span><br><span class="line">			--last;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// swap and pivot become to the nums[last]</span></span><br><span class="line">		nums[first] = nums[last];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// deal wiht the element from the first</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(first &lt; last &amp;&amp; nums[first] &lt;= key) &#123;</span><br><span class="line">			++first;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// swap </span></span><br><span class="line">		nums[last] = nums[first];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// put the pivot on the correct position, sun first is the division line</span></span><br><span class="line">	nums[first] = key;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// recursion</span></span><br><span class="line">	<span class="built_in">quicksort</span>(nums, l, first);</span><br><span class="line">	<span class="built_in">quicksort</span>(nums, first + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于partition的排序</span></span><br><span class="line"><span class="comment">// algorithms 4th 所实现的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> first = l, last = r+<span class="number">1</span>, key = nums[first];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[++first] &lt; key) &#123;</span><br><span class="line">			<span class="keyword">if</span> (first == r)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (nums[--last] &gt; key) &#123;</span><br><span class="line">			<span class="keyword">if</span> (last == l)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		std::<span class="built_in">swap</span>(nums[first], nums[last]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::<span class="built_in">swap</span>(nums[l], nums[last]);</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (r &lt;= l)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> last = <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">	<span class="built_in">quicksort</span>(nums, l, last - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quicksort</span>(nums, last + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.     归并排序"></a>2.     归并排序</h4><p>方法：采用一个临时空间，将划分成两部分空间在这个临时空间中排好序，然后再放入原空间数组中。</p>
<p>步骤： 先divide，然后recursion， 再deal with。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, vector&lt;<span class="keyword">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l + <span class="number">1</span> &gt;= r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// divide, recursion first</span></span><br><span class="line">	<span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">mergesort</span>(nums, l, m, temp);</span><br><span class="line">	<span class="built_in">mergesort</span>(nums, m, r, temp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// conquer</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> p = l, q = m, i = l;</span><br><span class="line">	<span class="keyword">while</span>(p &lt; m || q &lt; r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q]))</span><br><span class="line">			temp[i++] = nums[p++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			temp[i++] = nums[q++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">		nums[i] = temp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.     插入排序"></a>3.     插入排序</h4><p>这个没什么讲的，反正记得<strong>插入排序是基于<code>swap</code>的</strong>就行</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">void <span class="keyword">insertsort(vector&lt;int&gt; </span>&amp;nums, int n) &#123;</span><br><span class="line">	for(int i=<span class="number">0</span><span class="comment">; i&lt;n; ++i) &#123;</span></span><br><span class="line">		for(int <span class="keyword">j=i; </span><span class="keyword">j&gt;0&amp;&amp; </span>nums[<span class="keyword">j] </span>&lt; nums[<span class="keyword">j-1]; </span>--<span class="keyword">j) </span>&#123;</span><br><span class="line">			<span class="keyword">swap(nums[j], </span>nums[<span class="keyword">j </span>- <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4.    冒泡排序"></a>4.    冒泡排序</h4><p><strong>冒泡排序同样也是基于swap的</strong>，而且为了节省时间，swap途中会有一个bool变量，来判断后续循环是否已经有序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> swapped;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">		swapped = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i; j &lt; n-i+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[j] &lt; nums[j<span class="number">-1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(nums[j], nums[j - <span class="number">1</span>]);</span><br><span class="line">				swapped = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!swapped)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5.     选择排序"></a>5.     选择排序</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">void selection_sort(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">mid</span>;</span><br><span class="line">	for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">n</span> - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="built_in">mid</span> = i;</span><br><span class="line">		for (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">n</span>; ++j) &#123;</span><br><span class="line">			<span class="built_in">if</span> (nums[j] &lt; nums[<span class="built_in">mid</span>]) &#123;</span><br><span class="line">				<span class="built_in">mid</span> = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(nums[<span class="built_in">mid</span>], nums[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.     堆排序"></a>6.     堆排序</h4><p>基本思路：大根堆为例</p>
<p>​    1：建立大根堆—- 将n个元素组成的无序序列构建一个大根堆</p>
<p>​    2：交换堆元素—- 交换堆尾和堆首元素，使堆尾元素成为最大元素</p>
<p>​    3：重建大根堆—- 将前n-1个元素组成的无序序列调整为大根堆（递归）</p>
<p>重复执行2和3 直到整个序列都有序</p>
<p>C++内部实现： 优先队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapadjust</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> right = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> maxIdx = index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left &lt; len &amp;&amp; nums[left] &gt; nums[maxIdx]) maxIdx = left;</span><br><span class="line">	<span class="keyword">if</span> (right&lt; len &amp;&amp; nums[right] &gt; nums[maxIdx]) maxIdx = right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(maxIdx != index) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(nums[maxIdx], nums[index]);</span><br><span class="line">		<span class="built_in">heapadjust</span>(nums, len, maxIdx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// build a heap</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = size / <span class="number">2</span> <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">heapadjust</span>(nums, size, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// adjust the heap</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=size<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">		<span class="built_in">heapadjust</span>(nums, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>总结：手撕排序算法是面试中最基本的技能，不仅要能口头描述出这些排序的用法和效率，还得在面试官需要的时候能够自己写出实现的代码并进行测试。</strong></p>
<p><strong>在这些排序中，最重要的就是堆排序和快速排序。一定要手撕和会用</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>RedisSDS</title>
    <url>/posts/ddef0534/</url>
    <content><![CDATA[<blockquote>
<p>Redis自己构建了一种名为简单动态字符串（SDS）的抽象类型，并将其设置为Redis默认字符串。</p>
</blockquote>
<span id="more"></span>

<h3 id="1-SDS的定义"><a href="#1-SDS的定义" class="headerlink" title="1 SDS的定义"></a>1 SDS的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sds.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存的字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>tag： 由于SDS遵循C字符串以空字符结尾的惯例， 保存空字符的1字节空间不计算在SDS的Len属性里面，并且为空字符自动生成一个字节空间</em></p>
<h3 id="2-SDS和C字符串的区别"><a href="#2-SDS和C字符串的区别" class="headerlink" title="2 SDS和C字符串的区别"></a>2 SDS和C字符串的区别</h3><p>​    由于Redis对字符串在安全性，效率以及功能上都有需求， 因此SDS比传统字符串有着不少优化。</p>
<ul>
<li><p><strong>常数复杂度获取字符串长度</strong></p>
<p>C字符串获取长度靠<code>strlen</code>(O(n)), Redis是靠着<code>sds.len</code>直接获得。</p>
</li>
<li><p><strong>杜绝缓冲区的溢出</strong></p>
<p>C字符串容易造成缓冲区的溢出，而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求。如果不满足，那么就会执行空间扩展工作。</p>
</li>
<li><p><strong>减少修改字符串时带来的内存重分配次数</strong></p>
<ul>
<li><p>C字符串被增长或者缩短时，程序都要对该字符串进行一次内存重分配操作。</p>
</li>
<li><p>针对未使用空间<code>sds.free</code>， SDS解除了字符串长度和底层数组长度之间的关联。从而实现了<strong>空间预分配和惰性空间释放</strong>两种优化策略。</p>
<ul>
<li><p>空间预分配： 当API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序<strong>不仅会为SDS分配修改所必须要的空间，还会分配额外的未使用空间</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配机制</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> <span class="title">sds</span>;</span></span><br><span class="line"><span class="keyword">int</span> needlen;			<span class="comment">// sds字符串需要存储的字符串长度</span></span><br><span class="line"><span class="keyword">if</span>(sds.len &lt; <span class="number">1024</span>*<span class="number">1024</span>)	<span class="comment">// 1024*1024 = 1MB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 分配空间至len</span></span><br><span class="line">    sds.len = needlen;</span><br><span class="line">    sds.<span class="built_in">free</span> = sds.len <span class="comment">// 保持一样</span></span><br><span class="line">    <span class="comment">//so strlen(sds.buf) = len + free + 1;</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    sds.len = needlen;</span><br><span class="line">    sds.<span class="built_in">free</span> = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>惰性空间释放： 用于优化SDS的字符串缩短操作。 API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量纪录起来，并等待将来使用。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>二进制安全</strong></p>
<ul>
<li><p>C字符串中的字符必须符合某种编码(如ASCII),并且<strong>除了字符串的末尾之外，字符串里面不能含有空字符</strong>（这个是因为程序读C字符串遇到空字符就默认这是字符串结尾）。 由于这些限制，<strong>C字符串只能保存文本数据，而不能保存像图片、音频、视频压缩文件这些二进制数据。</strong></p>
</li>
<li><p>SDS中的buf数组，既可以保存一系列字符，也可以保存一系列二进制数据。（其实可以理解为该数组可以保存空字符串，因为长度是已知的，程序不需要通过空字符串的位置判断这个字符串是否结束）</p>
</li>
</ul>
</li>
<li><p><strong>兼容部分C字符串函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">strcat</span>(s_string, sds-&gt;buf);</span><br><span class="line"><span class="comment">// 可以使用str相关的api</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>总结</strong></p>
<ul>
<li>C字符串：<ul>
<li>获取字符串长度的时间复杂度是O(N)</li>
<li>API不安全，可能会造成缓冲区溢出</li>
<li>修改字符串长度N次<strong>必然</strong>需要执行N次内存重分配</li>
<li>只能保存文本数据</li>
<li>可以使用<strong>所有</strong><code>&lt;string.h&gt;</code>的库函数</li>
</ul>
</li>
<li>SDS：<ul>
<li>获取字符串长度的时间复杂度是O(1)</li>
<li>AP安全，不会造成缓冲区溢出</li>
<li>修改字符串长度N次<strong>最多</strong>需要执行N次内存重分配</li>
<li>能保存文本数据和二进制数据</li>
<li>可以使用<strong>一部分</strong><code>&lt;string.h&gt;</code>的库函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-SDS-API"><a href="#3-SDS-API" class="headerlink" title="3 SDS API"></a>3 SDS API</h3><p>​    |       函数        |                                  作用                                     |                          时间复杂度</p>
<ul>
<li><p><code>sdsnew</code>           创建一个包含给定C字符串的SDS                          <code>O(N), N = strlen(str)</code></p>
</li>
<li><p><code>sdsempty</code>       创建一个不包含任何内容的空SDS                        <code>O(1)</code></p>
</li>
<li><p><code>sdsfree</code>         释放给定的SDS                                                       <code>O(N), N = strlen(str)</code></p>
</li>
<li><p><code>sdslen</code>           返回SDS已使用空间字节数                                    <code>O(1), get from sds-&gt;len</code></p>
</li>
<li><p><code>sdsavail </code>       返回SDS未使用空间字节数                                    <code>O(1), get from sds-&gt;free</code></p>
</li>
<li><p><code>sdsdup</code>           创建一个给定SDS的副本(copy)                             <code>O(N), N = strlen(str)</code></p>
</li>
<li><p><code>sdsclear</code>       清空SDS保存的字符串内容                                    <code>O(1), 惰性空间释放策略！</code>  -&gt; <strong>mark</strong></p>
</li>
<li><p><code>sdscat</code>           将给定C字符串拼接到SDS字符串的末尾               <code>O(N)，N = strlen(str) </code></p>
</li>
<li><p><code>sdscatsds</code>     将给定SDS字符串拼接到另一个SDS字符串末尾   <code>O(N)，N = strlen(str)</code></p>
</li>
<li><p><code>sdscpy</code>           <strong>将给定C字符串复制到SDS里面，</strong></p>
<p>​                            <strong>覆盖SDS原有字符串</strong>                                              <code>O(N)，N = strlen(str)</code></p>
</li>
<li><p><code>sdsgrowzero</code>  用空字符将SDS扩展至给定长度                            <code>O(N),N为扩展新增的字节数</code></p>
</li>
<li><p><code>sdsrange</code>       保留SDS给定区间内的数据，</p>
<p>​                        不在区间内的数据会被覆盖或清除                          <code>O(N),N为保留数据的字节数</code></p>
</li>
<li><p><code>sdstrim</code>         接收一个SDS和一个C字符串作为参数，                <code>O(N*M),M为SDS的长度，N为给定C字符串的长度</code></p>
<p>​                        从SDS左右两端分别移除所有在C字符串中出现过的字符   </p>
</li>
<li><p><code>sdscmp</code>           比较两个SDS字符串是否相同                                 <code>O(N), N为两个SDS中较短的那个SDS的长度</code>                </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
