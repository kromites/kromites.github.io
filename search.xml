<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客介绍</title>
    <url>/posts/e627a59/</url>
    <content><![CDATA[<blockquote>
<p>欢迎您访问此博客！ 点开阅读全文可了解到博客的基本信息</p>
</blockquote>
<span id="more"></span>

<p>本博客创建于2021.7.1。作为一名22届毕业的学生，目前的主要精力放在找工作上，因此最近上传的大部分是自己的学习笔记。笔记内容涉及到以下几个主要方面：</p>
<ul>
<li>数据结构与算法</li>
<li>计算机网络</li>
<li>操作系统</li>
<li>网络编程</li>
<li>数据库</li>
<li>项目心得</li>
</ul>
<p>希望自己能够在这个夏天拿到心满意足的Offer！</p>
<p>TO BE CONTINUE~</p>
]]></content>
      <categories>
        <category>非技术</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O多路复用</title>
    <url>/posts/7ce262fd/</url>
    <content><![CDATA[<blockquote>
<p>在网络编程中熟知的一个方法。nignx和redis中都实现了该方法，属于网络编程中的基本概念</p>
</blockquote>
<span id="more"></span>



<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>​    I/O多路复用是指程序在单个线程内通过记录每个I/O流的状态，来同时管理多个I/O流。这样使得程序能够在单线程内同时监听多个文件描述符。</p>
<p>   不过值得注意的是，I/O复用虽然能同时监听多个文件描述符，但是其本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外措施，程序就只能按顺序依次处理其中的每个文件描述符。</p>
<p>​    虽然是能够在单个线程同时监听多个文件描述符，但是文件描述符就绪依旧是串行处理，明白这一点就不会将I/O多路复用和并发混淆，因为串行处理事件并不是并发。</p>
<p>​    I/O多路复用有三种熟知的具体实现，分别是Select，Poll 和 Epoll，下面来依次介绍它们。</p>
<h3 id="SELECT系统调用"><a href="#SELECT系统调用" class="headerlink" title="SELECT系统调用"></a>SELECT系统调用</h3><p>​    用途：在指定时间内，<strong>监听用户感兴趣的文件描述符上的可读，可写和异常事件</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">( <span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    由上面的API可以看出，nfds是感兴趣的fd总数，后面三个参数分别是三种fd的集合，最后一个时间参数是指定时间，如果超过时间直接返回。</p>
<pre><code> 而`fd_set`结构体仅仅包含一个整形数组，**该数组的每个元素的每一位标记一个fd。**fd_set能容纳的文件描述符最大数量优先，应该是2^16。
</code></pre>
<p>​    这是select最大的缺点：</p>
<ul>
<li><p><strong>每次去查看文件描述符的状态都要按位去轮询整个数组，O（N），效率不高</strong></p>
</li>
<li><p><strong>而且存储的文件描述符有上限，只能存储几万个</strong>（这个很少，fd的上限能够达到上百万个）</p>
</li>
<li><p>非线程安全</p>
</li>
</ul>
<h3 id="POLL系统调用"><a href="#POLL系统调用" class="headerlink" title="POLL系统调用"></a>POLL系统调用</h3><p>​    poll和select类似，也是在<strong>指定时间轮询一定数量的文件描述符</strong>，以测试其中是否有就绪者。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">  	<span class="keyword">int</span> fd;				<span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">short</span> events;		<span class="comment">// 注册的事件</span></span><br><span class="line">    <span class="keyword">short</span> revents;		<span class="comment">// 活跃的事件，由内核填充</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    看到这个API其实和select也是有点差别的。</p>
<ul>
<li>存放文件描述符的数据结构从数组位变成了</li>
<li>事件类型区分更为细致，select只有三种时间类型，而poll将其细化了。如可读事件分为了POLLIN,POLLRDNORM, POLLDRBAND, POLLPRI四种。</li>
</ul>
<p>不过nfds和timoeout参数都和select相似，这里不赘述。</p>
<p>其缺点也和select类似，</p>
<ul>
<li>遍历所有fd，不活跃fd也会去检查它的状态，O(N)</li>
<li>线程不安全</li>
</ul>
<p>不过因为不是通过数组位存储，因此无上限太低的缺点。</p>
<h3 id="EPOLL系统调用"><a href="#EPOLL系统调用" class="headerlink" title="EPOLL系统调用"></a>EPOLL系统调用</h3><p>接下来就迎来主角了，epoll是Linux特有的I/O复用函数，其实现和前两者有较大差异。</p>
<p>优点</p>
<ul>
<li>epoll使用一组函数实现多路复用，前两者都只有单个函数</li>
<li>epoll将用户关心的文件描述符上的事件放在内核里的一个事件表中，无需O(N)，只需要O(1)地查看关心的事件</li>
<li>检查文件描述符是否就绪的方法更好，epoll采用回调的机制，而前两者采用的轮询机制，随着fd增加，回调效率不怎么降低，而轮询会大大降低。</li>
<li>线程安全</li>
</ul>
<p>略有瑕疵的缺点</p>
<ul>
<li>内核事件表需要额外一个文件描述符表示，浪费了一个文件描述符</li>
<li>只能在Linux上用</li>
</ul>
<h4 id="epoll事件表"><a href="#epoll事件表" class="headerlink" title="epoll事件表"></a>epoll事件表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该API创建一个内核事件表，返回与该事件表绑定的文件描述符。</strong>size无多大含义，只是通知内核告诉它事件表多大。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">  	<span class="keyword">uint32_t</span> events; 	<span class="comment">// epoll 事件</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;	<span class="comment">// 用户数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该API用来操作已创建的内核事件表。</strong></p>
<p>参数分析：</p>
<ul>
<li><p>epfd是负责内核事件表的文件描述符</p>
</li>
<li><p>fd是要操作的文件描述符，op是操作类型：</p>
<ul>
<li>EPOLL_CTL_ADD：往事件表注册fd上的事件</li>
<li>EPOLL_CTL_MOD：修改fd上的注册事件</li>
<li>EPOLL_CTL_DEL：删除fd上的注册事件</li>
</ul>
</li>
<li><p>event参数指定事件。事件类型存储在event-&gt;events中。epoll的事件类型和poll类似，只不过在前面加了个E，不过epoll有两种额外的事件——EPOLLET和EPOLLONESHOT。这个后面再讲。</p>
</li>
<li><p>返回值：成功回0，失败回-1并设置errno。</p>
</li>
</ul>
<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>​    epoll的主要接口是epoll_wait函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>该API在一段超时时间内等待一组文件描述符上的事件。</strong></p>
<p>参数：</p>
<ul>
<li>maxevents 指定最多能够监听多少个事件，必须大于0</li>
</ul>
<p><strong>如果检测到事件</strong>，就将所有就绪的事件从内核事件表（由epfd指定）中复制到它的第二个参数events指向的数组中。<strong>这个数组只用于输出epoll_wait检测到的就绪事件，而不像前两者的数组参数那样即用于传入用户注册的事件，又用于输出检测的内核事件。这样极大提高了应用程序索引就绪文件描述符的效率。</strong>（目前还是LT模式的效率提升，因为是检测到事件就返回）</p>
<h4 id="ET和LT模式"><a href="#ET和LT模式" class="headerlink" title="ET和LT模式"></a>ET和LT模式</h4><p>​    epoll对fd的操作用两种模式:ET和LT。其中LT是默认工作模式，这个模式下就是效率提升版的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET时间事，epoll工作模式变成了ET，ET是epoll的高效模式。</p>
<p>​    采用LT模式时，如果检测到有事件发生时，epoll_wait将此事通知给应用程序，应用程序可以不处理它，但是下次调用epoll_wait依旧会通知应用程序来处理它。</p>
<p>​    而ET模式不同，ET模式当通知了应用程序，应用程序必须立即处理该事件，因为后续的epoll_wait调用不再向应用程序通知这一事件。这样一来极大降低了同一事件被重复触发的次数（但是可能通知了没处理直接被漏掉了吗？思考一下）</p>
<p>​    形象的说就是<strong>LT模式是传统的调用epoll_wait有活跃事件就触发（可读事件缓冲区不为空，可写事件缓冲区不满），而ET是增量触发，只有新事件到来才会通知应用程序。</strong></p>
<p>​    （ET必须是非阻塞的！）</p>
<h4 id="EPOLLSHOT事件"><a href="#EPOLLSHOT事件" class="headerlink" title="EPOLLSHOT事件"></a>EPOLLSHOT事件</h4><p>​    即使我们使用ET模式，<strong>一个socket上的某个事件还是可能被触发多次</strong>。这在并发程序中会引起一个问题。比如一个线程在读取完某个socket上的数据后开始处理这些数据，在处理数据过程中又有新数据可读，这样新的线程唤醒去读新数据，那么就出现了<strong>两个线程同时操作一个socket的局面</strong>。但是我们期望的是<strong>一个socket连接在任一时刻都只被一个线程处理。（因为这会导致线程同步问题）</strong></p>
<p>​    这里就可以采用EPOLLSHOT事件，对于注册该事件的fd，<strong>操作系统最多出发其上注册的一个可读、可写或者一长时间，且只触发一次。</strong>这样当一个线程处理这socket，其他线程不能处理该socket。</p>
<p>​    但是反过来思考一下，只触发一次，那下次怎么办？因此触发这一次之后要重置EPOLLSHOT事件，进而让其他工作线程之后有机会处理该socket</p>
<h3 id="三种系统调用的对比"><a href="#三种系统调用的对比" class="headerlink" title="三种系统调用的对比"></a>三种系统调用的对比</h3><p>​    这三组系统调用都通过某种结构体变量来告诉内核监听那些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">SELECT</th>
<th align="center">POLL</th>
<th align="center">EPOLL</th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用数据结构</td>
<td align="center">三个数组构成的位图</td>
<td align="center">统一数据结构<code>epollfd</code></td>
<td align="center">同一数据结构，内核注册表</td>
</tr>
<tr>
<td align="center">事件类型</td>
<td align="center">最基本的三种：可读、可写、异常</td>
<td align="center">带有优先级的事件类型，区分更细致</td>
<td align="center">和poll类似，多了ET和SHOT</td>
</tr>
<tr>
<td align="center">事件监听机制</td>
<td align="center">轮询</td>
<td align="center">轮询</td>
<td align="center">回调</td>
</tr>
<tr>
<td align="center">时间复杂度</td>
<td align="center">O(N)</td>
<td align="center">O(N)</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">优点</td>
<td align="center">多平台可用，简单</td>
<td align="center">多平台可用，简单，上限比select高</td>
<td align="center">高效，LT模式下就是O(1)，ET模式下更是减少同一事件的多次触发，线程安全</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">低效，处理的fd有上限，非线程安全</td>
<td align="center">低效，非线程安全</td>
<td align="center">仅LINUX可用</td>
</tr>
</tbody></table>
<p><strong>PS：虽然epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</strong></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>I/O多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/posts/735e5788/</url>
    <content><![CDATA[<blockquote>
<p> 各类排序算法是一个很基础的算法概念，在面试当中，手撕排序算法也只算得上一道简单题。</p>
</blockquote>
<span id="more"></span>

<p>排序算法一般可分为 快速排序， 归并排序，插入排序，冒泡排序，选择排序和堆排序。（其中快排，归并和堆排序比较难，但是要掌握）</p>
<h3 id="C-中的std-sort"><a href="#C-中的std-sort" class="headerlink" title="C++中的std::sort"></a>C++中的<code>std::sort</code></h3><p>​    sort算法主体是一个快速排序，快速排序的时间复杂度为<code>O(NlogN)</code>，但是其对效率有了优化。</p>
<p>首先，快速排序在小区间的效率不如插入排序，因此在小空间的话，就用<strong>插入排序</strong>。 而且快速排序是基于递归的，因此如果数据过大，递归层数过大，这就要转入<strong>堆排序</strong> 。</p>
<p>然后，快速排序的效率取决于pivot的取法，如果pivot取得适中，那么效率最高。因此标准库里面用的是<strong>九取一，</strong>这可以尽可能使得pivot的取值更合理。</p>
<h3 id="经典排序模板"><a href="#经典排序模板" class="headerlink" title="经典排序模板"></a>经典排序模板</h3><h4 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.     快速排序"></a>1.     快速排序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// key is the pivot element </span></span><br><span class="line">	<span class="keyword">auto</span> first = l, last = r - <span class="number">1</span>, key = nums[first];</span><br><span class="line">	<span class="keyword">while</span>(first &lt; last) &#123;</span><br><span class="line">		<span class="comment">// deal with the element from the last</span></span><br><span class="line">		<span class="keyword">while</span> (first &lt; last &amp;&amp; nums[last] &gt;= key) &#123;</span><br><span class="line">			--last;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// swap and pivot become to the nums[last]</span></span><br><span class="line">		nums[first] = nums[last];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// deal wiht the element from the first</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(first &lt; last &amp;&amp; nums[first] &lt;= key) &#123;</span><br><span class="line">			++first;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// swap </span></span><br><span class="line">		nums[last] = nums[first];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// put the pivot on the correct position, sun first is the division line</span></span><br><span class="line">	nums[first] = key;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// recursion</span></span><br><span class="line">	<span class="built_in">quicksort</span>(nums, l, first);</span><br><span class="line">	<span class="built_in">quicksort</span>(nums, first + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于partition的排序</span></span><br><span class="line"><span class="comment">// algorithms 4th 所实现的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> first = l, last = r+<span class="number">1</span>, key = nums[first];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (nums[++first] &lt; key) &#123;</span><br><span class="line">			<span class="keyword">if</span> (first == r)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (nums[--last] &gt; key) &#123;</span><br><span class="line">			<span class="keyword">if</span> (last == l)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (first &gt;= last)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		std::<span class="built_in">swap</span>(nums[first], nums[last]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::<span class="built_in">swap</span>(nums[l], nums[last]);</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (r &lt;= l)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> last = <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">	<span class="built_in">quicksort</span>(nums, l, last - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">quicksort</span>(nums, last + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.     归并排序"></a>2.     归并排序</h4><p>方法：采用一个临时空间，将划分成两部分空间在这个临时空间中排好序，然后再放入原空间数组中。</p>
<p>步骤： 先divide，然后recursion， 再deal with。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, vector&lt;<span class="keyword">int</span>&gt; &amp;temp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l + <span class="number">1</span> &gt;= r)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// divide, recursion first</span></span><br><span class="line">	<span class="keyword">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">mergesort</span>(nums, l, m, temp);</span><br><span class="line">	<span class="built_in">mergesort</span>(nums, m, r, temp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// conquer</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> p = l, q = m, i = l;</span><br><span class="line">	<span class="keyword">while</span>(p &lt; m || q &lt; r) &#123;</span><br><span class="line">		<span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q]))</span><br><span class="line">			temp[i++] = nums[p++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			temp[i++] = nums[q++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">		nums[i] = temp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.     插入排序"></a>3.     插入排序</h4><p>这个没什么讲的，反正记得<strong>插入排序是基于<code>swap</code>的</strong>就行</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">void <span class="keyword">insertsort(vector&lt;int&gt; </span>&amp;nums, int n) &#123;</span><br><span class="line">	for(int i=<span class="number">0</span><span class="comment">; i&lt;n; ++i) &#123;</span></span><br><span class="line">		for(int <span class="keyword">j=i; </span><span class="keyword">j&gt;0&amp;&amp; </span>nums[<span class="keyword">j] </span>&lt; nums[<span class="keyword">j-1]; </span>--<span class="keyword">j) </span>&#123;</span><br><span class="line">			<span class="keyword">swap(nums[j], </span>nums[<span class="keyword">j </span>- <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4.    冒泡排序"></a>4.    冒泡排序</h4><p><strong>冒泡排序同样也是基于swap的</strong>，而且为了节省时间，swap途中会有一个bool变量，来判断后续循环是否已经有序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubblesort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> swapped;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; ++i) &#123;</span><br><span class="line">		swapped = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i; j &lt; n-i+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[j] &lt; nums[j<span class="number">-1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(nums[j], nums[j - <span class="number">1</span>]);</span><br><span class="line">				swapped = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!swapped)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5.     选择排序"></a>5.     选择排序</h4><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">void selection_sort(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="built_in">n</span>) &#123;</span><br><span class="line">	<span class="built_in">int</span> <span class="built_in">mid</span>;</span><br><span class="line">	for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">n</span> - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="built_in">mid</span> = i;</span><br><span class="line">		for (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">n</span>; ++j) &#123;</span><br><span class="line">			<span class="built_in">if</span> (nums[j] &lt; nums[<span class="built_in">mid</span>]) &#123;</span><br><span class="line">				<span class="built_in">mid</span> = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(nums[<span class="built_in">mid</span>], nums[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.     堆排序"></a>6.     堆排序</h4><p>基本思路：大根堆为例</p>
<p>​    1：建立大根堆—- 将n个元素组成的无序序列构建一个大根堆</p>
<p>​    2：交换堆元素—- 交换堆尾和堆首元素，使堆尾元素成为最大元素</p>
<p>​    3：重建大根堆—- 将前n-1个元素组成的无序序列调整为大根堆（递归）</p>
<p>重复执行2和3 直到整个序列都有序</p>
<p>C++内部实现： 优先队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapadjust</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> right = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> maxIdx = index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left &lt; len &amp;&amp; nums[left] &gt; nums[maxIdx]) maxIdx = left;</span><br><span class="line">	<span class="keyword">if</span> (right&lt; len &amp;&amp; nums[right] &gt; nums[maxIdx]) maxIdx = right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(maxIdx != index) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(nums[maxIdx], nums[index]);</span><br><span class="line">		<span class="built_in">heapadjust</span>(nums, len, maxIdx);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// build a heap</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = size / <span class="number">2</span> <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">heapadjust</span>(nums, size, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// adjust the heap</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=size<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">		<span class="built_in">heapadjust</span>(nums, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>总结：手撕排序算法是面试中最基本的技能，不仅要能口头描述出这些排序的用法和效率，还得在面试官需要的时候能够自己写出实现的代码并进行测试。</strong></p>
<p><strong>在这些排序中，最重要的就是堆排序和快速排序。一定要手撕和会用</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>RedisSDS</title>
    <url>/posts/ddef0534/</url>
    <content><![CDATA[<blockquote>
<p>Redis自己构建了一种名为简单动态字符串（SDS）的抽象类型，并将其设置为Redis默认字符串。</p>
</blockquote>
<span id="more"></span>

<h3 id="1-SDS的定义"><a href="#1-SDS的定义" class="headerlink" title="1 SDS的定义"></a>1 SDS的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sds.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存的字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>tag： 由于SDS遵循C字符串以空字符结尾的惯例， 保存空字符的1字节空间不计算在SDS的Len属性里面，并且为空字符自动生成一个字节空间</em></p>
<h3 id="2-SDS和C字符串的区别"><a href="#2-SDS和C字符串的区别" class="headerlink" title="2 SDS和C字符串的区别"></a>2 SDS和C字符串的区别</h3><p>​    由于Redis对字符串在安全性，效率以及功能上都有需求， 因此SDS比传统字符串有着不少优化。</p>
<ul>
<li><p><strong>常数复杂度获取字符串长度</strong></p>
<p>C字符串获取长度靠<code>strlen</code>(O(n)), Redis是靠着<code>sds.len</code>直接获得。</p>
</li>
<li><p><strong>杜绝缓冲区的溢出</strong></p>
<p>C字符串容易造成缓冲区的溢出，而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS的API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求。如果不满足，那么就会执行空间扩展工作。</p>
</li>
<li><p><strong>减少修改字符串时带来的内存重分配次数</strong></p>
<ul>
<li><p>C字符串被增长或者缩短时，程序都要对该字符串进行一次内存重分配操作。</p>
</li>
<li><p>针对未使用空间<code>sds.free</code>， SDS解除了字符串长度和底层数组长度之间的关联。从而实现了<strong>空间预分配和惰性空间释放</strong>两种优化策略。</p>
<ul>
<li><p>空间预分配： 当API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序<strong>不仅会为SDS分配修改所必须要的空间，还会分配额外的未使用空间</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配机制</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> <span class="title">sds</span>;</span></span><br><span class="line"><span class="keyword">int</span> needlen;			<span class="comment">// sds字符串需要存储的字符串长度</span></span><br><span class="line"><span class="keyword">if</span>(sds.len &lt; <span class="number">1024</span>*<span class="number">1024</span>)	<span class="comment">// 1024*1024 = 1MB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 分配空间至len</span></span><br><span class="line">    sds.len = needlen;</span><br><span class="line">    sds.<span class="built_in">free</span> = sds.len <span class="comment">// 保持一样</span></span><br><span class="line">    <span class="comment">//so strlen(sds.buf) = len + free + 1;</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    sds.len = needlen;</span><br><span class="line">    sds.<span class="built_in">free</span> = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>惰性空间释放： 用于优化SDS的字符串缩短操作。 API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量纪录起来，并等待将来使用。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>二进制安全</strong></p>
<ul>
<li><p>C字符串中的字符必须符合某种编码(如ASCII),并且<strong>除了字符串的末尾之外，字符串里面不能含有空字符</strong>（这个是因为程序读C字符串遇到空字符就默认这是字符串结尾）。 由于这些限制，<strong>C字符串只能保存文本数据，而不能保存像图片、音频、视频压缩文件这些二进制数据。</strong></p>
</li>
<li><p>SDS中的buf数组，既可以保存一系列字符，也可以保存一系列二进制数据。（其实可以理解为该数组可以保存空字符串，因为长度是已知的，程序不需要通过空字符串的位置判断这个字符串是否结束）</p>
</li>
</ul>
</li>
<li><p><strong>兼容部分C字符串函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">strcat</span>(s_string, sds-&gt;buf);</span><br><span class="line"><span class="comment">// 可以使用str相关的api</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>总结</strong></p>
<ul>
<li>C字符串：<ul>
<li>获取字符串长度的时间复杂度是O(N)</li>
<li>API不安全，可能会造成缓冲区溢出</li>
<li>修改字符串长度N次<strong>必然</strong>需要执行N次内存重分配</li>
<li>只能保存文本数据</li>
<li>可以使用<strong>所有</strong><code>&lt;string.h&gt;</code>的库函数</li>
</ul>
</li>
<li>SDS：<ul>
<li>获取字符串长度的时间复杂度是O(1)</li>
<li>AP安全，不会造成缓冲区溢出</li>
<li>修改字符串长度N次<strong>最多</strong>需要执行N次内存重分配</li>
<li>能保存文本数据和二进制数据</li>
<li>可以使用<strong>一部分</strong><code>&lt;string.h&gt;</code>的库函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-SDS-API"><a href="#3-SDS-API" class="headerlink" title="3 SDS API"></a>3 SDS API</h3><p>​    |       函数        |                                  作用                                     |                          时间复杂度</p>
<ul>
<li><p><code>sdsnew</code>           创建一个包含给定C字符串的SDS                          <code>O(N), N = strlen(str)</code></p>
</li>
<li><p><code>sdsempty</code>       创建一个不包含任何内容的空SDS                        <code>O(1)</code></p>
</li>
<li><p><code>sdsfree</code>         释放给定的SDS                                                       <code>O(N), N = strlen(str)</code></p>
</li>
<li><p><code>sdslen</code>           返回SDS已使用空间字节数                                    <code>O(1), get from sds-&gt;len</code></p>
</li>
<li><p><code>sdsavail </code>       返回SDS未使用空间字节数                                    <code>O(1), get from sds-&gt;free</code></p>
</li>
<li><p><code>sdsdup</code>           创建一个给定SDS的副本(copy)                             <code>O(N), N = strlen(str)</code></p>
</li>
<li><p><code>sdsclear</code>       清空SDS保存的字符串内容                                    <code>O(1), 惰性空间释放策略！</code>  -&gt; <strong>mark</strong></p>
</li>
<li><p><code>sdscat</code>           将给定C字符串拼接到SDS字符串的末尾               <code>O(N)，N = strlen(str) </code></p>
</li>
<li><p><code>sdscatsds</code>     将给定SDS字符串拼接到另一个SDS字符串末尾   <code>O(N)，N = strlen(str)</code></p>
</li>
<li><p><code>sdscpy</code>           <strong>将给定C字符串复制到SDS里面，</strong></p>
<p>​                            <strong>覆盖SDS原有字符串</strong>                                              <code>O(N)，N = strlen(str)</code></p>
</li>
<li><p><code>sdsgrowzero</code>  用空字符将SDS扩展至给定长度                            <code>O(N),N为扩展新增的字节数</code></p>
</li>
<li><p><code>sdsrange</code>       保留SDS给定区间内的数据，</p>
<p>​                        不在区间内的数据会被覆盖或清除                          <code>O(N),N为保留数据的字节数</code></p>
</li>
<li><p><code>sdstrim</code>         接收一个SDS和一个C字符串作为参数，                <code>O(N*M),M为SDS的长度，N为给定C字符串的长度</code></p>
<p>​                        从SDS左右两端分别移除所有在C字符串中出现过的字符   </p>
</li>
<li><p><code>sdscmp</code>           比较两个SDS字符串是否相同                                 <code>O(N), N为两个SDS中较短的那个SDS的长度</code>                </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
